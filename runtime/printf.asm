; Generated by Ripple C99 Compiler (rcc)

; Global '__str_0' at address 0
print_char:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S1, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Call function putchar
    CALL putchar
; Jump to epilogue
    BEQ R0, R0, L_print_char_99999
L_print_char_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
print_str:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
L_print_str_1:
    ADD S2, FP, R0
    STORE S3, SB, S2
    ADDI S1, S2, 1
    STORE A1, SB, S1
    BEQ R0, R0, L_print_str_2
; Unconditional branch to L_print_str_2
; Invalidated 1 alloca bindings
L_print_str_2:
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op5_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD S0, FP, R0
    LOAD T7, SB, S0
    ADDI T6, S0, 1
    LOAD T5, SB, T6
; Bank value in T5 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t3 = load FatPtr(FatPointer { addr: Temp(2), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Mixed })
; LOAD: Pointer t2 has bank info: Dynamic("load_f2_op8_t2_bank_val")
    LI T3, -1
    BEQ T5, T3, L_bc_e5eefe5a_use_global
    LI T2, -2
    BEQ T5, T2, L_bc_e5eefe5a_use_stack
    ADD T4, T5, R0
    BEQ R0, R0, L_bc_e5eefe5a_done
L_bc_e5eefe5a_use_global:
    ADD T4, GP, R0
    BEQ R0, R0, L_bc_e5eefe5a_done
L_bc_e5eefe5a_use_stack:
    ADD T4, SB, R0
L_bc_e5eefe5a_done:
; LOAD: Using bank register T4 for load
    LOAD T1, T4, T7
    BEQ T1, R0, L_print_str_4
; Branch to L_print_str_4 if condition is false
    BEQ R0, R0, L_print_str_3
; Unconditional branch to L_print_str_3 (condition was true)
; Invalidated 1 alloca bindings
L_print_str_3:
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op13_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD T0, FP, R0
    LOAD S1, SB, T0
    ADDI S2, T0, 1
    LOAD T6, SB, S2
; Bank value in T6 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op17_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T0
    ADDI T2, T0, 1
    LOAD T1, SB, T2
; Bank value in T1 - tags: -1 = Global, -2 = Stack, positive = dynamic
    ADDI S0, T3, 1
; GEP: Setting bank info for t6 to Stack
    LI S2, -2
    STORE S0, SB, T0
    ADDI T2, T0, 1
    STORE S2, SB, T2
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op24_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, S1
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE T7, SB, SC
; Spill load_f2_op8_t2_bank_val to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE T5, SB, SC
; Spill load_f2_op8_t2_bank_val to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T5, SB, SC
; Spill load_f2_op9_t3_resolved_bank_2_f2_op10 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T4, SB, SC
; Spill load_f2_op16_t4_bank_val to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE T6, SB, SC
; Spill load_f2_op20_t5_bank_val to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T1, SB, SC
; Spill t5 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T3, SB, SC
; Spill t6 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S0, SB, SC
; Spill t4 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S1, SB, SC
; Spill t7 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_print_str_2
; Unconditional branch to L_print_str_2
L_print_str_4:
; Jump to epilogue
    BEQ R0, R0, L_print_str_99999
L_print_str_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
print_uint:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 29 slots for locals
    ADDI SP, SP, 29
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_print_uint_5:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
    ADD T6, FP, R0
    ADDI T6, T6, 18
    LI T5, 0
    STORE T5, SB, T6
    ADD T4, FP, R0
    ADDI T4, T4, 19
    LI T3, 0
    LI T2, -1
    STORE T3, SB, T4
    ADDI T1, T4, 1
    STORE T2, SB, T1
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op10_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S1
    LI T5, 0
    XOR T1, T0, T5
    LI T2, 1
    SLTU T0, T1, T2
    BEQ T0, R0, L_print_uint_8
; Branch to L_print_uint_8 if condition is false
    BEQ R0, R0, L_print_uint_6
; Unconditional branch to L_print_uint_6 (condition was true)
; Invalidated 5 alloca bindings
L_print_uint_6:
    LI T3, 48
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE S2, SB, SC
; Spill const_f4_op14_48 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 31
    STORE T3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T3, R0
; Call function print_char
    CALL print_char
; Jump to epilogue
    BEQ R0, R0, L_print_uint_99999
    BEQ R0, R0, L_print_uint_8
; Unconditional branch to L_print_uint_8
L_print_uint_8:
    BEQ R0, R0, L_print_uint_9
; Unconditional branch to L_print_uint_9
L_print_uint_9:
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op15_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T1, FP, R0
    LOAD T2, SB, T1
    LI T5, 0
    SLT T2, T5, T2
    BEQ T2, R0, L_print_uint_11
; Branch to L_print_uint_11 if condition is false
    BEQ R0, R0, L_print_uint_10
; Unconditional branch to L_print_uint_10 (condition was true)
; Invalidated 1 alloca bindings
L_print_uint_10:
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op17_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+18
    ADD T0, FP, R0
    ADDI T0, T0, 18
    LOAD T4, SB, T0
    LI T6, 0
    ADD T4, T4, T6
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op19_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, T0
    LI S0, 1
    ADD T7, T7, S0
    STORE T7, SB, T0
; Recompute alloca t4 at FP+2
    ADD S1, FP, R0
    ADDI S1, S1, 2
    ADD S2, T4, R0
    ADD S3, S1, S2
; Runtime bank overflow calculation for dynamic GEP
    LI T5, 4096
    DIV T3, S3, T5
    MOD T2, S3, T5
; Base bank info: Stack
; Clearing binding for 'gep_new_bank_f4_op26_t15'
; Computing new bank gep_new_bank_f4_op26_t15 = SB + bank_delta
    ADD T1, SB, T3
; Result bank tracked as Dynamic(gep_new_bank_f4_op26_t15)
    ADD S3, T2, R0
; GEP: Setting bank info for t15 to Dynamic("gep_new_bank_f4_op26_t15")
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op27_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+19
    ADD T6, FP, R0
    ADDI T6, T6, 19
    LOAD S0, SB, T6
    ADDI S2, T6, 1
    LOAD T3, SB, S2
; Bank value in T3 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op31_t17 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T5, FP, R0
    LOAD T2, SB, T5
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op33_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+1
    ADD S2, FP, R0
    ADDI S2, S2, 1
; Spill t14 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 32
    STORE T7, SB, SC
    LOAD T7, SB, S2
    MOD T2, T2, T7
    ADD T0, T2, R0
    ADD T7, S0, T0
; Runtime bank overflow calculation for dynamic GEP
; Spill t12 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 33
    STORE T4, SB, SC
    LI T4, 4096
    DIV S1, T7, T4
; Spill gep_new_bank_f4_op26_t15 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 34
    STORE T1, SB, SC
    MOD T1, T7, T4
; Base bank info: Dynamic("load_f4_op30_t16_bank_val")
; Clearing binding for 'gep_new_bank_f4_op39_t20'
; Spill t15 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 35
    STORE S3, SB, SC
; Computing new bank gep_new_bank_f4_op39_t20 = load_f4_op30_t16_bank_val + bank_delta
    ADD S3, T3, S1
; Result bank tracked as Dynamic(gep_new_bank_f4_op39_t20)
    ADD T7, T1, R0
; GEP: Setting bank info for t20 to Dynamic("gep_new_bank_f4_op39_t20")
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(20), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(20), bank: Mixed })
; LOAD: Pointer t20 has bank info: Dynamic("gep_new_bank_f4_op39_t20")
    LI S1, -1
    BEQ S3, S1, L_bc_f1976523_use_global
    LI T4, -2
    BEQ S3, T4, L_bc_f1976523_use_stack
    ADD T0, S3, R0
    BEQ R0, R0, L_bc_f1976523_done
L_bc_f1976523_use_global:
    ADD T0, GP, R0
    BEQ R0, R0, L_bc_f1976523_done
L_bc_f1976523_use_stack:
    ADD T0, SB, R0
L_bc_f1976523_done:
; LOAD: Using bank register T0 for load
    LOAD T1, T0, T7
; Reload t15 from slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 35
    LOAD S1, SB, SC
; Reload gep_new_bank_f4_op26_t15 from slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 34
    LOAD T4, SB, SC
    LI T5, -1
    BEQ T4, T5, L_bc_1382fc05_use_global
    LI S2, -2
    BEQ T4, S2, L_bc_1382fc05_use_stack
    ADD T6, T4, R0
    BEQ R0, R0, L_bc_1382fc05_done
L_bc_1382fc05_use_global:
    ADD T6, GP, R0
    BEQ R0, R0, L_bc_1382fc05_done
L_bc_1382fc05_use_stack:
    ADD T6, SB, R0
L_bc_1382fc05_done:
    STORE T1, T6, S1
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op48_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T5, FP, R0
    LOAD S2, SB, T5
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op50_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
; Spill t16 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 36
    STORE S0, SB, SC
; Spill load_f4_op30_t16_bank_val to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 37
    STORE T3, SB, SC
; Recompute alloca t3 at FP+1
    ADD S0, FP, R0
    ADDI S0, S0, 1
; Spill t19 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 38
    STORE T2, SB, SC
    LOAD T2, SB, S0
    DIV S2, S2, T2
    STORE S2, SB, T5
    BEQ R0, R0, L_print_uint_9
; Unconditional branch to L_print_uint_9
; Invalidated 2 alloca bindings
L_print_uint_11:
    BEQ R0, R0, L_print_uint_12
; Unconditional branch to L_print_uint_12
L_print_uint_12:
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op53_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+18
    ADD T2, FP, R0
    ADDI T2, T2, 18
    LOAD T5, SB, T2
    LI S0, 0
    ADD T5, T5, S0
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op55_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T2
; Spill load_f4_op30_t16_bank_val to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 39
    STORE T3, SB, SC
    LI T3, 1
    SUB S0, S0, T3
    STORE S0, SB, T2
    BEQ T5, R0, L_print_uint_14
; Branch to L_print_uint_14 if condition is false
    BEQ R0, R0, L_print_uint_13
; Unconditional branch to L_print_uint_13 (condition was true)
; Invalidated 1 alloca bindings
L_print_uint_13:
; Load instruction: t29 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op58_t29 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+18
    ADD T3, FP, R0
    ADDI T3, T3, 18
    LOAD T5, SB, T3
; Recompute alloca t4 at FP+2
    ADD T2, FP, R0
    ADDI T2, T2, 2
; Spill t20 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 40
    STORE T7, SB, SC
; Spill gep_new_bank_f4_op39_t20 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 41
    STORE S3, SB, SC
; Spill gep_new_bank_f4_op39_t20 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 42
    STORE S3, SB, SC
    ADD S3, T5, R0
    ADD T7, T2, S3
; Runtime bank overflow calculation for dynamic GEP
; Spill load_f4_op40_t21_resolved_bank_4_f4_op41 to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 43
    STORE T0, SB, SC
; Spill t21 to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 44
    STORE T1, SB, SC
    LI T1, 4096
    DIV T0, T7, T1
; Spill t15 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 35
    STORE S1, SB, SC
; Spill gep_new_bank_f4_op26_t15 to slot 16
    ADD SC, FP, R0
    ADDI SC, SC, 45
    STORE T4, SB, SC
    MOD S1, T7, T1
; Base bank info: Stack
; Clearing binding for 'gep_new_bank_f4_op64_t30'
; Spill gep_new_bank_f4_op26_t15 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 34
    STORE T4, SB, SC
; Computing new bank gep_new_bank_f4_op64_t30 = SB + bank_delta
    ADD T4, SB, T0
; Result bank tracked as Dynamic(gep_new_bank_f4_op64_t30)
    ADD T7, S1, R0
; GEP: Setting bank info for t30 to Dynamic("gep_new_bank_f4_op64_t30")
; Load instruction: t31 = load FatPtr(FatPointer { addr: Temp(30), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(30), bank: Mixed })
; LOAD: Pointer t30 has bank info: Dynamic("gep_new_bank_f4_op64_t30")
    LI T0, -1
    BEQ T4, T0, L_bc_a15013b3_use_global
    LI T1, -2
    BEQ T4, T1, L_bc_a15013b3_use_stack
    ADD S3, T4, R0
    BEQ R0, R0, L_bc_a15013b3_done
L_bc_a15013b3_use_global:
    ADD S3, GP, R0
    BEQ R0, R0, L_bc_a15013b3_done
L_bc_a15013b3_use_stack:
    ADD S3, SB, R0
L_bc_a15013b3_done:
; LOAD: Using bank register S3 for load
    LOAD S1, S3, T7
; Spill live registers before call
; Spill store_f4_op44_resolved_bank_4_f4_op45 to slot 17
    ADD SC, FP, R0
    ADDI SC, SC, 46
    STORE T6, SB, SC
; Spill t24 to slot 18
    ADD SC, FP, R0
    ADDI SC, SC, 47
    STORE S2, SB, SC
; Spill t28 to slot 19
    ADD SC, FP, R0
    ADDI SC, SC, 48
    STORE S0, SB, SC
; Spill t29 to slot 20
    ADD SC, FP, R0
    ADDI SC, SC, 49
    STORE T5, SB, SC
; Spill t30 to slot 21
    ADD SC, FP, R0
    ADDI SC, SC, 50
    STORE T7, SB, SC
; Spill gep_new_bank_f4_op64_t30 to slot 22
    ADD SC, FP, R0
    ADDI SC, SC, 51
    STORE T4, SB, SC
; Spill gep_new_bank_f4_op64_t30 to slot 23
    ADD SC, FP, R0
    ADDI SC, SC, 52
    STORE T4, SB, SC
; Spill load_f4_op65_t31_resolved_bank_4_f4_op66 to slot 24
    ADD SC, FP, R0
    ADDI SC, SC, 53
    STORE S3, SB, SC
; Spill t31 to slot 25
    ADD SC, FP, R0
    ADDI SC, SC, 54
    STORE S1, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Call function print_char
    CALL print_char
    BEQ R0, R0, L_print_uint_12
; Unconditional branch to L_print_uint_12
L_print_uint_14:
; Jump to epilogue
    BEQ R0, R0, L_print_uint_99999
L_print_uint_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
print_int:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_print_int_15:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f6_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 0
    SLT S1, S1, S0
    BEQ S1, R0, L_print_int_17
; Branch to L_print_int_17 if condition is false
    BEQ R0, R0, L_print_int_16
; Unconditional branch to L_print_int_16 (condition was true)
; Invalidated 1 alloca bindings
L_print_int_16:
    LI T7, 45
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f6_op4_45 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE T7, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Call function print_char
    CALL print_char
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f6_op5_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD T6, FP, R0
    LOAD T5, SB, T6
    LI T4, 0
    SUB T4, T4, T5
    LI T3, 10
; Spill live registers before call
; Spill t5 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE T4, SB, SC
; Spill const_f6_op7_10 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE T3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T4, R0
; Arg 1 (scalar) to A1
    ADD A1, T3, R0
; Call function print_uint
    CALL print_uint
    BEQ R0, R0, L_print_int_18
; Unconditional branch to L_print_int_18
L_print_int_17:
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f6_op8_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD T2, FP, R0
    LOAD T1, SB, T2
    LI T0, 10
; Spill live registers before call
; Spill t6 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T1, SB, SC
; Spill const_f6_op10_10 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T0, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Call function print_uint
    CALL print_uint
    BEQ R0, R0, L_print_int_18
; Unconditional branch to L_print_int_18
L_print_int_18:
; Jump to epilogue
    BEQ R0, R0, L_print_int_99999
L_print_int_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
printf:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 15 slots for locals
    ADDI SP, SP, 15
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
; Load param 1 bank from A3
L_printf_19:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADDI S0, S1, 1
    STORE A1, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
    STORE S2, SB, T7
    ADDI T6, T7, 1
    STORE A3, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 4
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op10_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, S1
    ADDI T3, S1, 1
    LOAD T2, SB, T3
; Bank value in T2 - tags: -1 = Global, -2 = Stack, positive = dynamic
    STORE T4, SB, T5
    ADDI T1, T5, 1
    STORE T2, SB, T1
    ADD T0, FP, R0
    ADDI T0, T0, 6
    LI S0, 0
    STORE S0, SB, T0
    BEQ R0, R0, L_printf_20
; Unconditional branch to L_printf_20
; Invalidated 4 alloca bindings
L_printf_20:
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op18_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD T6, FP, R0
    ADDI T6, T6, 4
    LOAD T3, SB, T6
    ADDI T1, T6, 1
    LOAD S0, SB, T1
; Bank value in S0 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(7), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Mixed })
; LOAD: Pointer t7 has bank info: Dynamic("load_f8_op21_t7_bank_val")
    LI T5, -1
    BEQ S0, T5, L_bc_1663a9a0_use_global
    LI T7, -2
    BEQ S0, T7, L_bc_1663a9a0_use_stack
    ADD T0, S0, R0
    BEQ R0, R0, L_bc_1663a9a0_done
L_bc_1663a9a0_use_global:
    ADD T0, GP, R0
    BEQ R0, R0, L_bc_1663a9a0_done
L_bc_1663a9a0_use_stack:
    ADD T0, SB, R0
L_bc_1663a9a0_done:
; LOAD: Using bank register T0 for load
    LOAD S1, T0, T3
    BEQ S1, R0, L_printf_22
; Branch to L_printf_22 if condition is false
    BEQ R0, R0, L_printf_21
; Unconditional branch to L_printf_21 (condition was true)
; Invalidated 1 alloca bindings
L_printf_21:
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op26_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD T1, FP, R0
    ADDI T1, T1, 4
    LOAD T5, SB, T1
    ADDI T7, T1, 1
    LOAD S1, SB, T7
; Bank value in S1 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(9), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Mixed })
; LOAD: Pointer t9 has bank info: Dynamic("load_f8_op29_t9_bank_val")
    LI T7, -1
    BEQ S1, T7, L_bc_3989985e_use_global
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S3, SB, SC
    LI S3, -2
    BEQ S1, S3, L_bc_3989985e_use_stack
    ADD T6, S1, R0
    BEQ R0, R0, L_bc_3989985e_done
L_bc_3989985e_use_global:
    ADD T6, GP, R0
    BEQ R0, R0, L_bc_3989985e_done
L_bc_3989985e_use_stack:
    ADD T6, SB, R0
L_bc_3989985e_done:
; LOAD: Using bank register T6 for load
    LOAD T7, T6, T5
    LI S3, 37
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S2, SB, SC
    XOR S2, T7, S3
; Spill t5 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T4, SB, SC
; Spill load_f8_op13_t5_bank_val to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T2, SB, SC
    LI T4, 1
    SLTU T7, S2, T4
    BEQ T7, R0, L_printf_24
; Branch to L_printf_24 if condition is false
    BEQ R0, R0, L_printf_23
; Unconditional branch to L_printf_23 (condition was true)
; Invalidated 1 alloca bindings
L_printf_23:
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op36_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD S2, FP, R0
    ADDI S2, S2, 4
    LOAD T4, SB, S2
    ADDI S3, S2, 1
    LOAD T7, SB, S3
; Bank value in T7 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op40_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S2
    ADDI S3, S2, 1
; Spill load_f8_op13_t5_bank_val to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T2, SB, SC
    LOAD T2, SB, S3
; Bank value in T2 - tags: -1 = Global, -2 = Stack, positive = dynamic
    ADDI S3, T1, 1
; GEP: Setting bank info for t14 to Stack
; Spill t7 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T3, SB, SC
; Spill load_f8_op21_t7_bank_val to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE S0, SB, SC
    LI T3, -2
    STORE S3, SB, S2
; Spill load_f8_op21_t7_bank_val to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE S0, SB, SC
    ADDI S0, S2, 1
    STORE T3, SB, S0
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op47_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, S2
    ADDI T3, S2, 1
; Spill load_f8_op22_t8_resolved_bank_8_f8_op23 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T0, SB, SC
    LOAD T0, SB, T3
; Bank value in T0 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(15), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(15), bank: Mixed })
; LOAD: Pointer t15 has bank info: Dynamic("load_f8_op50_t15_bank_val")
; Spill t9 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T5, SB, SC
; Spill load_f8_op29_t9_bank_val to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE S1, SB, SC
    LI T5, -1
    BEQ T0, T5, L_bc_5f3551d1_use_global
; Spill load_f8_op29_t9_bank_val to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE S1, SB, SC
    LI S1, -2
    BEQ T0, S1, L_bc_5f3551d1_use_stack
    ADD T3, T0, R0
    BEQ R0, R0, L_bc_5f3551d1_done
L_bc_5f3551d1_use_global:
    ADD T3, GP, R0
    BEQ R0, R0, L_bc_5f3551d1_done
L_bc_5f3551d1_use_stack:
    ADD T3, SB, R0
L_bc_5f3551d1_done:
; LOAD: Using bank register T3 for load
    LOAD T5, T3, S0
    LI S1, 115
; Spill load_f8_op30_t10_resolved_bank_8_f8_op31 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T6, SB, SC
    XOR T6, T5, S1
; Spill t12 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T4, SB, SC
; Spill load_f8_op39_t12_bank_val to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE T7, SB, SC
    LI T4, 1
    SLTU T5, T6, T4
    BEQ T5, R0, L_printf_27
; Branch to L_printf_27 if condition is false
    BEQ R0, R0, L_printf_26
; Unconditional branch to L_printf_26 (condition was true)
; Invalidated 1 alloca bindings
L_printf_26:
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op57_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+2
    ADD T6, FP, R0
    ADDI T6, T6, 2
    LOAD T4, SB, T6
    ADDI S1, T6, 1
    LOAD T5, SB, S1
; Bank value in T5 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op61_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+6
    ADD S2, FP, R0
    ADDI S2, S2, 6
    LOAD S1, SB, S2
; Spill load_f8_op39_t12_bank_val to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE T7, SB, SC
    LI T7, 0
    ADD S1, S1, T7
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op63_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S2
; Spill load_f8_op43_t13_bank_val to slot 16
    ADD SC, FP, R0
    ADDI SC, SC, 31
    STORE T2, SB, SC
    LI T2, 1
    ADD T7, T7, T2
    STORE T7, SB, S2
; Spill t13 to slot 17
    ADD SC, FP, R0
    ADDI SC, SC, 32
    STORE T1, SB, SC
    ADD T1, S1, R0
    ADD T2, T4, T1
; Runtime bank overflow calculation for dynamic GEP
; Spill t14 to slot 18
    ADD SC, FP, R0
    ADDI SC, SC, 33
    STORE S3, SB, SC
; Spill t15 to slot 19
    ADD SC, FP, R0
    ADDI SC, SC, 34
    STORE S0, SB, SC
; Spill load_f8_op50_t15_bank_val to slot 20
    ADD SC, FP, R0
    ADDI SC, SC, 35
    STORE T0, SB, SC
    LI S0, 4096
    DIV S3, T2, S0
; Spill load_f8_op50_t15_bank_val to slot 21
    ADD SC, FP, R0
    ADDI SC, SC, 36
    STORE T0, SB, SC
    MOD T0, T2, S0
; Base bank info: Dynamic("load_f8_op60_t18_bank_val")
; Clearing binding for 'gep_new_bank_f8_op70_t23'
; Spill load_f8_op51_t16_resolved_bank_8_f8_op52 to slot 22
    ADD SC, FP, R0
    ADDI SC, SC, 37
    STORE T3, SB, SC
; Computing new bank gep_new_bank_f8_op70_t23 = load_f8_op60_t18_bank_val + bank_delta
    ADD T3, T5, S3
; Result bank tracked as Dynamic(gep_new_bank_f8_op70_t23)
    ADD T2, T0, R0
; GEP: Setting bank info for t23 to Dynamic("gep_new_bank_f8_op70_t23")
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(23), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(23), bank: Mixed })
; LOAD: Pointer t23 has bank info: Dynamic("gep_new_bank_f8_op70_t23")
    LI S3, -1
    BEQ T3, S3, L_bc_857cb054_use_global
    LI S0, -2
    BEQ T3, S0, L_bc_857cb054_use_stack
    ADD T1, T3, R0
    BEQ R0, R0, L_bc_857cb054_done
L_bc_857cb054_use_global:
    ADD T1, GP, R0
    BEQ R0, R0, L_bc_857cb054_done
L_bc_857cb054_use_stack:
    ADD T1, SB, R0
L_bc_857cb054_done:
; LOAD: Using bank register T1 for load
    LOAD T0, T1, T2
    LI S3, -1
; Spill live registers before call
; Spill t22 to slot 23
    ADD SC, FP, R0
    ADDI SC, SC, 38
    STORE T7, SB, SC
; Spill t18 to slot 24
    ADD SC, FP, R0
    ADDI SC, SC, 39
    STORE T4, SB, SC
; Spill load_f8_op60_t18_bank_val to slot 25
    ADD SC, FP, R0
    ADDI SC, SC, 40
    STORE T5, SB, SC
; Spill t20 to slot 26
    ADD SC, FP, R0
    ADDI SC, SC, 41
    STORE S1, SB, SC
; Spill load_f8_op60_t18_bank_val to slot 27
    ADD SC, FP, R0
    ADDI SC, SC, 42
    STORE T5, SB, SC
; Spill t23 to slot 28
    ADD SC, FP, R0
    ADDI SC, SC, 43
    STORE T2, SB, SC
; Spill gep_new_bank_f8_op70_t23 to slot 29
    ADD SC, FP, R0
    ADDI SC, SC, 44
    STORE T3, SB, SC
; Spill gep_new_bank_f8_op70_t23 to slot 30
    ADD SC, FP, R0
    ADDI SC, SC, 45
    STORE T3, SB, SC
; Spill load_f8_op71_t24_resolved_bank_8_f8_op72 to slot 31
    ADD SC, FP, R0
    ADDI SC, SC, 46
    STORE T1, SB, SC
; Spill t24 to slot 32
    ADD SC, FP, R0
    ADDI SC, SC, 47
    STORE T0, SB, SC
; Spill call_arg_fp_global_tag_8_f8_op75 to slot 33
    ADD SC, FP, R0
    ADDI SC, SC, 48
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, T0, R0
    ADD A1, S3, R0
; Call function print_str
    CALL print_str
    BEQ R0, R0, L_printf_28
; Unconditional branch to L_printf_28
L_printf_27:
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op76_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD S0, FP, R0
    ADDI S0, S0, 4
    LOAD T6, SB, S0
    ADDI T7, S0, 1
    LOAD S2, SB, T7
; Bank value in S2 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(25), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(25), bank: Mixed })
; LOAD: Pointer t25 has bank info: Dynamic("load_f8_op79_t25_bank_val")
    LI S1, -1
    BEQ S2, S1, L_bc_48c3a202_use_global
    LI T5, -2
    BEQ S2, T5, L_bc_48c3a202_use_stack
    ADD T4, S2, R0
    BEQ R0, R0, L_bc_48c3a202_done
L_bc_48c3a202_use_global:
    ADD T4, GP, R0
    BEQ R0, R0, L_bc_48c3a202_done
L_bc_48c3a202_use_stack:
    ADD T4, SB, R0
L_bc_48c3a202_done:
; LOAD: Using bank register T4 for load
    LOAD T2, T4, T6
    LI T3, 99
    XOR T1, T2, T3
    LI T0, 1
    SLTU T2, T1, T0
    BEQ T2, R0, L_printf_30
; Branch to L_printf_30 if condition is false
    BEQ R0, R0, L_printf_29
; Unconditional branch to L_printf_29 (condition was true)
; Invalidated 1 alloca bindings
L_printf_29:
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op86_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+2
    ADD S3, FP, R0
    ADDI S3, S3, 2
    LOAD T7, SB, S3
    ADDI S1, S3, 1
    LOAD T5, SB, S1
; Bank value in T5 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t29 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op90_t29 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+6
    ADD T1, FP, R0
    ADDI T1, T1, 6
    LOAD T0, SB, T1
    LI T3, 0
    ADD T0, T0, T3
; Load instruction: t31 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op92_t31 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T1
    LI S0, 1
    ADD T2, T2, S0
    STORE T2, SB, T1
    ADD T3, T0, R0
    ADD S1, T7, T3
; Runtime bank overflow calculation for dynamic GEP
; Spill t25 to slot 34
    ADD SC, FP, R0
    ADDI SC, SC, 49
    STORE T6, SB, SC
; Spill load_f8_op79_t25_bank_val to slot 35
    ADD SC, FP, R0
    ADDI SC, SC, 50
    STORE S2, SB, SC
    LI T6, 4096
    DIV S0, S1, T6
; Spill load_f8_op79_t25_bank_val to slot 36
    ADD SC, FP, R0
    ADDI SC, SC, 51
    STORE S2, SB, SC
    MOD S2, S1, T6
; Base bank info: Dynamic("load_f8_op89_t28_bank_val")
; Clearing binding for 'gep_new_bank_f8_op99_t33'
; Spill load_f8_op80_t26_resolved_bank_8_f8_op81 to slot 37
    ADD SC, FP, R0
    ADDI SC, SC, 52
    STORE T4, SB, SC
; Computing new bank gep_new_bank_f8_op99_t33 = load_f8_op89_t28_bank_val + bank_delta
    ADD T4, T5, S0
; Result bank tracked as Dynamic(gep_new_bank_f8_op99_t33)
    ADD S1, S2, R0
; GEP: Setting bank info for t33 to Dynamic("gep_new_bank_f8_op99_t33")
; Load instruction: t34 = load FatPtr(FatPointer { addr: Temp(33), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(33), bank: Mixed })
; LOAD: Pointer t33 has bank info: Dynamic("gep_new_bank_f8_op99_t33")
    LI S0, -1
    BEQ T4, S0, L_bc_ca1f8316_use_global
    LI T6, -2
    BEQ T4, T6, L_bc_ca1f8316_use_stack
    ADD T3, T4, R0
    BEQ R0, R0, L_bc_ca1f8316_done
L_bc_ca1f8316_use_global:
    ADD T3, GP, R0
    BEQ R0, R0, L_bc_ca1f8316_done
L_bc_ca1f8316_use_stack:
    ADD T3, SB, R0
L_bc_ca1f8316_done:
; LOAD: Using bank register T3 for load
    LOAD S2, T3, S1
; Spill live registers before call
; Spill t32 to slot 38
    ADD SC, FP, R0
    ADDI SC, SC, 53
    STORE T2, SB, SC
; Spill t28 to slot 39
    ADD SC, FP, R0
    ADDI SC, SC, 54
    STORE T7, SB, SC
; Spill load_f8_op89_t28_bank_val to slot 40
    ADD SC, FP, R0
    ADDI SC, SC, 55
    STORE T5, SB, SC
; Spill t30 to slot 41
    ADD SC, FP, R0
    ADDI SC, SC, 56
    STORE T0, SB, SC
; Spill load_f8_op89_t28_bank_val to slot 42
    ADD SC, FP, R0
    ADDI SC, SC, 57
    STORE T5, SB, SC
; Spill t33 to slot 43
    ADD SC, FP, R0
    ADDI SC, SC, 58
    STORE S1, SB, SC
; Spill gep_new_bank_f8_op99_t33 to slot 44
    ADD SC, FP, R0
    ADDI SC, SC, 59
    STORE T4, SB, SC
; Spill gep_new_bank_f8_op99_t33 to slot 45
    ADD SC, FP, R0
    ADDI SC, SC, 60
    STORE T4, SB, SC
; Spill load_f8_op100_t34_resolved_bank_8_f8_op101 to slot 46
    ADD SC, FP, R0
    ADDI SC, SC, 61
    STORE T3, SB, SC
; Spill t34 to slot 47
    ADD SC, FP, R0
    ADDI SC, SC, 62
    STORE S2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Call function print_char
    CALL print_char
    BEQ R0, R0, L_printf_31
; Unconditional branch to L_printf_31
L_printf_30:
; Load instruction: t35 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op104_t35 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD S0, FP, R0
    ADDI S0, S0, 4
    LOAD T6, SB, S0
    ADDI S3, S0, 1
    LOAD T2, SB, S3
; Bank value in T2 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t36 = load FatPtr(FatPointer { addr: Temp(35), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(35), bank: Mixed })
; LOAD: Pointer t35 has bank info: Dynamic("load_f8_op107_t35_bank_val")
    LI T7, -1
    BEQ T2, T7, L_bc_6b27062e_use_global
    LI T0, -2
    BEQ T2, T0, L_bc_6b27062e_use_stack
    ADD T1, T2, R0
    BEQ R0, R0, L_bc_6b27062e_done
L_bc_6b27062e_use_global:
    ADD T1, GP, R0
    BEQ R0, R0, L_bc_6b27062e_done
L_bc_6b27062e_use_stack:
    ADD T1, SB, R0
L_bc_6b27062e_done:
; LOAD: Using bank register T1 for load
    LOAD T5, T1, T6
    LI S1, 100
    XOR T4, T5, S1
    LI T3, 1
    SLTU T5, T4, T3
    BEQ T5, R0, L_printf_33
; Branch to L_printf_33 if condition is false
    BEQ R0, R0, L_printf_32
; Unconditional branch to L_printf_32 (condition was true)
; Invalidated 1 alloca bindings
L_printf_32:
; Load instruction: t38 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op114_t38 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+2
    ADD S2, FP, R0
    ADDI S2, S2, 2
    LOAD S3, SB, S2
    ADDI T7, S2, 1
    LOAD T0, SB, T7
; Bank value in T0 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t39 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op118_t39 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+6
    ADD T4, FP, R0
    ADDI T4, T4, 6
    LOAD T3, SB, T4
    LI S1, 0
    ADD T3, T3, S1
; Load instruction: t41 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op120_t41 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, T4
    LI S0, 1
    ADD T5, T5, S0
    STORE T5, SB, T4
    ADD S1, T3, R0
    ADD T7, S3, S1
; Runtime bank overflow calculation for dynamic GEP
; Spill t35 to slot 48
    ADD SC, FP, R0
    ADDI SC, SC, 63
    STORE T6, SB, SC
; Spill load_f8_op107_t35_bank_val to slot 49
    ADD SC, FP, R0
    ADDI SC, SC, 64
    STORE T2, SB, SC
    LI T6, 4096
    DIV S0, T7, T6
; Spill load_f8_op107_t35_bank_val to slot 50
    ADD SC, FP, R0
    ADDI SC, SC, 65
    STORE T2, SB, SC
    MOD T2, T7, T6
; Base bank info: Dynamic("load_f8_op117_t38_bank_val")
; Clearing binding for 'gep_new_bank_f8_op127_t43'
; Spill load_f8_op108_t36_resolved_bank_8_f8_op109 to slot 51
    ADD SC, FP, R0
    ADDI SC, SC, 66
    STORE T1, SB, SC
; Computing new bank gep_new_bank_f8_op127_t43 = load_f8_op117_t38_bank_val + bank_delta
    ADD T1, T0, S0
; Result bank tracked as Dynamic(gep_new_bank_f8_op127_t43)
    ADD T7, T2, R0
; GEP: Setting bank info for t43 to Dynamic("gep_new_bank_f8_op127_t43")
; Load instruction: t44 = load FatPtr(FatPointer { addr: Temp(43), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(43), bank: Mixed })
; LOAD: Pointer t43 has bank info: Dynamic("gep_new_bank_f8_op127_t43")
    LI S0, -1
    BEQ T1, S0, L_bc_d6bd03f8_use_global
    LI T6, -2
    BEQ T1, T6, L_bc_d6bd03f8_use_stack
    ADD S1, T1, R0
    BEQ R0, R0, L_bc_d6bd03f8_done
L_bc_d6bd03f8_use_global:
    ADD S1, GP, R0
    BEQ R0, R0, L_bc_d6bd03f8_done
L_bc_d6bd03f8_use_stack:
    ADD S1, SB, R0
L_bc_d6bd03f8_done:
; LOAD: Using bank register S1 for load
    LOAD T2, S1, T7
; Spill live registers before call
; Spill t42 to slot 52
    ADD SC, FP, R0
    ADDI SC, SC, 67
    STORE T5, SB, SC
; Spill t38 to slot 53
    ADD SC, FP, R0
    ADDI SC, SC, 68
    STORE S3, SB, SC
; Spill load_f8_op117_t38_bank_val to slot 54
    ADD SC, FP, R0
    ADDI SC, SC, 69
    STORE T0, SB, SC
; Spill t40 to slot 55
    ADD SC, FP, R0
    ADDI SC, SC, 70
    STORE T3, SB, SC
; Spill load_f8_op117_t38_bank_val to slot 56
    ADD SC, FP, R0
    ADDI SC, SC, 71
    STORE T0, SB, SC
; Spill t43 to slot 57
    ADD SC, FP, R0
    ADDI SC, SC, 72
    STORE T7, SB, SC
; Spill gep_new_bank_f8_op127_t43 to slot 58
    ADD SC, FP, R0
    ADDI SC, SC, 73
    STORE T1, SB, SC
; Spill gep_new_bank_f8_op127_t43 to slot 59
    ADD SC, FP, R0
    ADDI SC, SC, 74
    STORE T1, SB, SC
; Spill load_f8_op128_t44_resolved_bank_8_f8_op129 to slot 60
    ADD SC, FP, R0
    ADDI SC, SC, 75
    STORE S1, SB, SC
; Spill t44 to slot 61
    ADD SC, FP, R0
    ADDI SC, SC, 76
    STORE T2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Call function print_int
    CALL print_int
    BEQ R0, R0, L_printf_34
; Unconditional branch to L_printf_34
L_printf_33:
; Load instruction: t45 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op132_t45 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD S0, FP, R0
    ADDI S0, S0, 4
    LOAD T6, SB, S0
    ADDI S2, S0, 1
    LOAD T5, SB, S2
; Bank value in T5 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t46 = load FatPtr(FatPointer { addr: Temp(45), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(45), bank: Mixed })
; LOAD: Pointer t45 has bank info: Dynamic("load_f8_op135_t45_bank_val")
    LI S3, -1
    BEQ T5, S3, L_bc_03cdb907_use_global
    LI T3, -2
    BEQ T5, T3, L_bc_03cdb907_use_stack
    ADD T4, T5, R0
    BEQ R0, R0, L_bc_03cdb907_done
L_bc_03cdb907_use_global:
    ADD T4, GP, R0
    BEQ R0, R0, L_bc_03cdb907_done
L_bc_03cdb907_use_stack:
    ADD T4, SB, R0
L_bc_03cdb907_done:
; LOAD: Using bank register T4 for load
    LOAD T0, T4, T6
    LI T7, 120
    XOR T1, T0, T7
    LI S1, 1
    SLTU T0, T1, S1
    BEQ T0, R0, L_printf_36
; Branch to L_printf_36 if condition is false
    BEQ R0, R0, L_printf_35
; Unconditional branch to L_printf_35 (condition was true)
; Invalidated 1 alloca bindings
L_printf_35:
; Load instruction: t48 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op142_t48 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+2
    ADD T2, FP, R0
    ADDI T2, T2, 2
    LOAD S2, SB, T2
    ADDI S3, T2, 1
    LOAD T3, SB, S3
; Bank value in T3 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t49 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op146_t49 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+6
    ADD T1, FP, R0
    ADDI T1, T1, 6
    LOAD S1, SB, T1
    LI T7, 0
    ADD S1, S1, T7
; Load instruction: t51 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op148_t51 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T1
    LI S0, 1
    ADD T0, T0, S0
    STORE T0, SB, T1
    ADD T7, S1, R0
    ADD S3, S2, T7
; Runtime bank overflow calculation for dynamic GEP
; Spill t45 to slot 62
    ADD SC, FP, R0
    ADDI SC, SC, 77
    STORE T6, SB, SC
; Spill load_f8_op135_t45_bank_val to slot 63
    ADD SC, FP, R0
    ADDI SC, SC, 78
    STORE T5, SB, SC
    LI T6, 4096
    DIV S0, S3, T6
; Spill load_f8_op135_t45_bank_val to slot 64
    ADD SC, FP, R0
    ADDI SC, SC, 79
    STORE T5, SB, SC
    MOD T5, S3, T6
; Base bank info: Dynamic("load_f8_op145_t48_bank_val")
; Clearing binding for 'gep_new_bank_f8_op155_t53'
; Spill load_f8_op136_t46_resolved_bank_8_f8_op137 to slot 65
    ADD SC, FP, R0
    ADDI SC, SC, 80
    STORE T4, SB, SC
; Computing new bank gep_new_bank_f8_op155_t53 = load_f8_op145_t48_bank_val + bank_delta
    ADD T4, T3, S0
; Result bank tracked as Dynamic(gep_new_bank_f8_op155_t53)
    ADD S3, T5, R0
; GEP: Setting bank info for t53 to Dynamic("gep_new_bank_f8_op155_t53")
; Load instruction: t54 = load FatPtr(FatPointer { addr: Temp(53), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(53), bank: Mixed })
; LOAD: Pointer t53 has bank info: Dynamic("gep_new_bank_f8_op155_t53")
    LI S0, -1
    BEQ T4, S0, L_bc_2ac6156d_use_global
    LI T6, -2
    BEQ T4, T6, L_bc_2ac6156d_use_stack
    ADD T7, T4, R0
    BEQ R0, R0, L_bc_2ac6156d_done
L_bc_2ac6156d_use_global:
    ADD T7, GP, R0
    BEQ R0, R0, L_bc_2ac6156d_done
L_bc_2ac6156d_use_stack:
    ADD T7, SB, R0
L_bc_2ac6156d_done:
; LOAD: Using bank register T7 for load
    LOAD T5, T7, S3
    LI S0, 16
; Spill live registers before call
; Spill t52 to slot 66
    ADD SC, FP, R0
    ADDI SC, SC, 81
    STORE T0, SB, SC
; Spill t48 to slot 67
    ADD SC, FP, R0
    ADDI SC, SC, 82
    STORE S2, SB, SC
; Spill load_f8_op145_t48_bank_val to slot 68
    ADD SC, FP, R0
    ADDI SC, SC, 83
    STORE T3, SB, SC
; Spill t50 to slot 69
    ADD SC, FP, R0
    ADDI SC, SC, 84
    STORE S1, SB, SC
; Spill load_f8_op145_t48_bank_val to slot 70
    ADD SC, FP, R0
    ADDI SC, SC, 85
    STORE T3, SB, SC
; Spill t53 to slot 71
    ADD SC, FP, R0
    ADDI SC, SC, 86
    STORE S3, SB, SC
; Spill gep_new_bank_f8_op155_t53 to slot 72
    ADD SC, FP, R0
    ADDI SC, SC, 87
    STORE T4, SB, SC
; Spill gep_new_bank_f8_op155_t53 to slot 73
    ADD SC, FP, R0
    ADDI SC, SC, 88
    STORE T4, SB, SC
; Spill load_f8_op156_t54_resolved_bank_8_f8_op157 to slot 74
    ADD SC, FP, R0
    ADDI SC, SC, 89
    STORE T7, SB, SC
; Spill t54 to slot 75
    ADD SC, FP, R0
    ADDI SC, SC, 90
    STORE T5, SB, SC
; Spill const_f8_op160_16 to slot 76
    ADD SC, FP, R0
    ADDI SC, SC, 91
    STORE S0, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T5, R0
; Arg 1 (scalar) to A1
    ADD A1, S0, R0
; Call function print_uint
    CALL print_uint
    BEQ R0, R0, L_printf_37
; Unconditional branch to L_printf_37
L_printf_36:
; Load instruction: t55 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op161_t55 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD T6, FP, R0
    ADDI T6, T6, 4
    LOAD T2, SB, T6
    ADDI T0, T6, 1
    LOAD T1, SB, T0
; Bank value in T1 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t56 = load FatPtr(FatPointer { addr: Temp(55), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(55), bank: Mixed })
; LOAD: Pointer t55 has bank info: Dynamic("load_f8_op164_t55_bank_val")
    LI S1, -1
    BEQ T1, S1, L_bc_8667c831_use_global
    LI T3, -2
    BEQ T1, T3, L_bc_8667c831_use_stack
    ADD S2, T1, R0
    BEQ R0, R0, L_bc_8667c831_done
L_bc_8667c831_use_global:
    ADD S2, GP, R0
    BEQ R0, R0, L_bc_8667c831_done
L_bc_8667c831_use_stack:
    ADD S2, SB, R0
L_bc_8667c831_done:
; LOAD: Using bank register S2 for load
    LOAD S3, S2, T2
    LI T4, 37
    XOR T7, S3, T4
    LI T5, 1
    SLTU S3, T7, T5
    BEQ S3, R0, L_printf_39
; Branch to L_printf_39 if condition is false
    BEQ R0, R0, L_printf_38
; Unconditional branch to L_printf_38 (condition was true)
; Invalidated 1 alloca bindings
L_printf_38:
    LI S0, 37
; Spill live registers before call
; Spill t55 to slot 77
    ADD SC, FP, R0
    ADDI SC, SC, 92
    STORE T2, SB, SC
; Spill load_f8_op164_t55_bank_val to slot 78
    ADD SC, FP, R0
    ADDI SC, SC, 93
    STORE T1, SB, SC
; Spill load_f8_op164_t55_bank_val to slot 79
    ADD SC, FP, R0
    ADDI SC, SC, 94
    STORE T1, SB, SC
; Spill load_f8_op165_t56_resolved_bank_8_f8_op166 to slot 80
    ADD SC, FP, R0
    ADDI SC, SC, 95
    STORE S2, SB, SC
; Spill const_f8_op171_37 to slot 81
    ADD SC, FP, R0
    ADDI SC, SC, 96
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function print_char
    CALL print_char
    BEQ R0, R0, L_printf_40
; Unconditional branch to L_printf_40
L_printf_39:
    LI T0, 37
; Spill live registers before call
; Spill const_f8_op172_37 to slot 82
    ADD SC, FP, R0
    ADDI SC, SC, 97
    STORE T0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T0, R0
; Call function print_char
    CALL print_char
; Load instruction: t58 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op173_t58 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD S1, FP, R0
    ADDI S1, S1, 4
    LOAD T3, SB, S1
    ADDI T7, S1, 1
    LOAD T5, SB, T7
; Bank value in T5 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t59 = load FatPtr(FatPointer { addr: Temp(58), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(58), bank: Mixed })
; LOAD: Pointer t58 has bank info: Dynamic("load_f8_op176_t58_bank_val")
    LI S3, -1
    BEQ T5, S3, L_bc_d4baef02_use_global
    LI T6, -2
    BEQ T5, T6, L_bc_d4baef02_use_stack
    ADD T4, T5, R0
    BEQ R0, R0, L_bc_d4baef02_done
L_bc_d4baef02_use_global:
    ADD T4, GP, R0
    BEQ R0, R0, L_bc_d4baef02_done
L_bc_d4baef02_use_stack:
    ADD T4, SB, R0
L_bc_d4baef02_done:
; LOAD: Using bank register T4 for load
    LOAD T2, T4, T3
; Spill live registers before call
; Spill t58 to slot 83
    ADD SC, FP, R0
    ADDI SC, SC, 98
    STORE T3, SB, SC
; Spill load_f8_op176_t58_bank_val to slot 84
    ADD SC, FP, R0
    ADDI SC, SC, 99
    STORE T5, SB, SC
; Spill load_f8_op176_t58_bank_val to slot 85
    ADD SC, FP, R0
    ADDI SC, SC, 100
    STORE T5, SB, SC
; Spill load_f8_op177_t59_resolved_bank_8_f8_op178 to slot 86
    ADD SC, FP, R0
    ADDI SC, SC, 101
    STORE T4, SB, SC
; Spill t59 to slot 87
    ADD SC, FP, R0
    ADDI SC, SC, 102
    STORE T2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Call function print_char
    CALL print_char
    BEQ R0, R0, L_printf_40
; Unconditional branch to L_printf_40
L_printf_40:
    BEQ R0, R0, L_printf_37
; Unconditional branch to L_printf_37
L_printf_37:
    BEQ R0, R0, L_printf_34
; Unconditional branch to L_printf_34
L_printf_34:
    BEQ R0, R0, L_printf_31
; Unconditional branch to L_printf_31
L_printf_31:
    BEQ R0, R0, L_printf_28
; Unconditional branch to L_printf_28
L_printf_28:
    BEQ R0, R0, L_printf_25
; Unconditional branch to L_printf_25
L_printf_24:
; Load instruction: t60 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op181_t60 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD T1, FP, R0
    ADDI T1, T1, 4
    LOAD S2, SB, T1
    ADDI S0, T1, 1
    LOAD T0, SB, S0
; Bank value in T0 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t61 = load FatPtr(FatPointer { addr: Temp(60), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(60), bank: Mixed })
; LOAD: Pointer t60 has bank info: Dynamic("load_f8_op184_t60_bank_val")
    LI S3, -1
    BEQ T0, S3, L_bc_a7cbe21b_use_global
    LI T6, -2
    BEQ T0, T6, L_bc_a7cbe21b_use_stack
    ADD T7, T0, R0
    BEQ R0, R0, L_bc_a7cbe21b_done
L_bc_a7cbe21b_use_global:
    ADD T7, GP, R0
    BEQ R0, R0, L_bc_a7cbe21b_done
L_bc_a7cbe21b_use_stack:
    ADD T7, SB, R0
L_bc_a7cbe21b_done:
; LOAD: Using bank register T7 for load
    LOAD S1, T7, S2
; Spill live registers before call
; Spill t60 to slot 88
    ADD SC, FP, R0
    ADDI SC, SC, 103
    STORE S2, SB, SC
; Spill load_f8_op184_t60_bank_val to slot 89
    ADD SC, FP, R0
    ADDI SC, SC, 104
    STORE T0, SB, SC
; Spill load_f8_op184_t60_bank_val to slot 90
    ADD SC, FP, R0
    ADDI SC, SC, 105
    STORE T0, SB, SC
; Spill load_f8_op185_t61_resolved_bank_8_f8_op186 to slot 91
    ADD SC, FP, R0
    ADDI SC, SC, 106
    STORE T7, SB, SC
; Spill t61 to slot 92
    ADD SC, FP, R0
    ADDI SC, SC, 107
    STORE S1, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Call function print_char
    CALL print_char
    BEQ R0, R0, L_printf_25
; Unconditional branch to L_printf_25
L_printf_25:
; Load instruction: t62 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op189_t62 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+4
    ADD T3, FP, R0
    ADDI T3, T3, 4
    LOAD T5, SB, T3
    ADDI T4, T3, 1
    LOAD T2, SB, T4
; Bank value in T2 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t63 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op193_t63 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T3
    ADDI S3, T3, 1
    LOAD T6, SB, S3
; Bank value in T6 - tags: -1 = Global, -2 = Stack, positive = dynamic
    ADDI T1, S0, 1
; GEP: Setting bank info for t64 to Stack
    LI S2, -2
    STORE T1, SB, T3
    ADDI T0, T3, 1
    STORE S2, SB, T0
    BEQ R0, R0, L_printf_20
; Unconditional branch to L_printf_20
; Invalidated 1 alloca bindings
L_printf_22:
; Jump to epilogue
    BEQ R0, R0, L_printf_99999
L_printf_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
