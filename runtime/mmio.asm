; Generated by Ripple C99 Compiler (rcc)

mmio_read:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
    ADD S2, FP, R0
    STORE S3, SB, S2
    ADD S1, FP, R0
    ADDI S1, S1, 1
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op1_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, S2
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t4 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S0, SB, SC
; Setup: Load inputs
; Reload t4 from slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    LOAD T6, SB, SC
; Inline assembly code
    LOAD T7, R0, T6
; Teardown: Bind outputs
; Output t3 now in T7
; === End inline assembly ===
; Recompute alloca t2 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE T7, SB, T5
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op2_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, T5
    MOVE RV0, T4
; Jump to epilogue
    BEQ R0, R0, L_mmio_read_99999
L_mmio_read_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
mmio_write:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_mmio_write_1:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op2_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S0
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op3_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S1
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S2, SB, SC
; Spill t4 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE T7, SB, SC
; Spill t5 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T6, SB, SC
; Setup: Load inputs
; Reload t4 from slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    LOAD T5, SB, SC
; Reload t5 from slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    LOAD T4, SB, SC
; Inline assembly code
    STORE T5, R0, T4
; Teardown: Bind outputs
; === End inline assembly ===
; Jump to epilogue
    BEQ R0, R0, L_mmio_write_99999
L_mmio_write_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
tty_putchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_tty_putchar_2:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op1_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 0
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f4_op2_0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_tty_putchar_99999
L_tty_putchar_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_get:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_rng_get_3:
    LI S3, 4
; Spill live registers before call
; Spill const_f6_op0_4 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_rng_get_99999
L_rng_get_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_get_seed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_rng_get_seed_4:
    LI S3, 5
; Spill live registers before call
; Spill const_f8_op0_5 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_rng_get_seed_99999
L_rng_get_seed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_set_seed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_rng_set_seed_5:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f10_op1_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 5
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f10_op2_5 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_rng_set_seed_99999
L_rng_set_seed_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_set_mode:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_display_set_mode_6:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f12_op1_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 6
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f12_op2_6 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_set_mode_99999
L_display_set_mode_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_enable:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_enable_7:
    LI S3, 1
    LI S2, 0
    SLL S3, S3, S2
    LI S1, 8
; Spill live registers before call
; Spill const_f14_op0_8 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S1, SB, SC
; Spill t0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Arg 1 (scalar) to A1
    ADD A1, S3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_enable_99999
L_display_enable_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_clear:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_clear_8:
    LI S3, 1
    LI S2, 0
    SLL S3, S3, S2
    LI S1, 1
    LI S1, 1
    SLL S0, S1, S1
    OR S3, S3, S0
    LI T7, 8
; Spill live registers before call
; Spill const_f16_op0_8 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE T7, SB, SC
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Arg 1 (scalar) to A1
    ADD A1, S3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_clear_99999
L_display_clear_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_flush:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_flush_9:
    LI S3, 9
    LI S2, 1
; Spill live registers before call
; Spill const_f18_op0_9 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Spill const_f18_op1_1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S2, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Arg 1 (scalar) to A1
    ADD A1, S2, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_flush_99999
L_display_flush_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 13 slots for locals
    ADDI SP, SP, 13
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
L_text40_putchar_10:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op3_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S0
    LI T4, 0
    SLT T3, T5, T4
    LI T2, 1
    SUB T5, T2, T3
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op6_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 40
    SLT T1, T1, T0
    AND T5, T5, T1
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op7_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 0
    SLT T4, T3, T2
    LI T0, 1
    SUB T3, T0, T4
    AND T5, T5, T3
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op10_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    LI T4, 25
    SLT T1, T1, T4
    AND T5, T5, T1
    BEQ T5, R0, L_text40_putchar_13
; Branch to L_text40_putchar_13 if condition is false
    BEQ R0, R0, L_text40_putchar_11
; Unconditional branch to L_text40_putchar_11 (condition was true)
; Invalidated 3 alloca bindings
L_text40_putchar_11:
    ADD T0, FP, R0
    ADDI T0, T0, 3
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op11_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD T3, SB, T2
    LI T4, 40
    MUL T3, T3, T4
    LI T1, 32
    ADD T1, T1, T3
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op12_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+0
    ADD T5, FP, R0
    LOAD T6, SB, T5
    ADD T1, T1, T6
    STORE T1, SB, T0
    ADD T7, FP, R0
    ADDI T7, T7, 4
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op13_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+2
    ADD S0, FP, R0
    ADDI S0, S0, 2
    LOAD T4, SB, S0
    LI T3, 255
    AND T4, T4, T3
    STORE T4, SB, T7
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op14_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, T0
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; LOAD: Pointer load_src_ptr_f20_op15_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S2, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T1, SB, SC
; Spill t25 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T4, SB, SC
; Spill t26 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T6, SB, SC
; Spill t27 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T6, R0
; Arg 1 (scalar) to A1
    ADD A1, T3, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_13
; Unconditional branch to L_text40_putchar_13
L_text40_putchar_13:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_99999
L_text40_putchar_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 15 slots for locals
    ADDI SP, SP, 15
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
L_text40_puts_14:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
    ADDI T5, T6, 1
    STORE A3, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 4
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op5_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S0
    STORE T3, SB, T4
    ADD T2, FP, R0
    ADDI T2, T2, 5
    LI T1, 0
    STORE T1, SB, T2
    ADD T0, FP, R0
    ADDI T0, T0, 6
    BEQ R0, R0, L_text40_puts_15
; Unconditional branch to L_text40_puts_15
; Invalidated 6 alloca bindings
L_text40_puts_15:
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op7_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+2
    ADD T5, FP, R0
    ADDI T5, T5, 2
    LOAD T1, SB, T5
    ADDI T0, T5, 1
    LOAD T2, SB, T0
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op10_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T4, FP, R0
    ADDI T4, T4, 5
    LOAD T6, SB, T4
    ADD S0, T6, R0
    ADD T7, T1, S0
; Runtime bank overflow calculation for dynamic GEP
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S3, SB, SC
    LI S3, 4096
    DIV T0, T7, S3
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S2, SB, SC
    MOD S2, T7, S3
; Base bank info: Dynamic("load_f22_op9_t10_bank_val")
; Clearing binding for 'gep_new_bank_f22_op15_t12'
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S1, SB, SC
; Computing new bank gep_new_bank_f22_op15_t12 = load_f22_op9_t10_bank_val + bank_delta
    ADD S1, T2, T0
; Result bank tracked as Dynamic(gep_new_bank_f22_op15_t12)
    ADD T7, S2, R0
; GEP: Setting bank info for t12 to Dynamic("gep_new_bank_f22_op15_t12")
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(12), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Mixed })
; LOAD: Pointer t12 has bank info: Dynamic("gep_new_bank_f22_op15_t12")
; LOAD: Using bank register S1 for load
    LOAD S0, S1, T7
; Recompute alloca t9 at FP+6
    ADD T0, FP, R0
    ADDI T0, T0, 6
    STORE S0, SB, T0
    LI S3, 0
    XOR S2, S0, S3
    LI T1, 0
    SLTU S0, T1, S2
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op18_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+4
    ADD S2, FP, R0
    ADDI S2, S2, 4
    LOAD T1, SB, S2
    LI S3, 40
    SLT T1, T1, S3
    AND S0, S0, T1
    BEQ S0, R0, L_text40_puts_17
; Branch to L_text40_puts_17 if condition is false
    BEQ R0, R0, L_text40_puts_16
; Unconditional branch to L_text40_puts_16 (condition was true)
; Invalidated 4 alloca bindings
; Invalidating GEP bank gep_new_bank_f22_op15_t12 in S1
; Invalidated 1 GEP bank bindings
L_text40_puts_16:
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op19_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+4
    ADD S3, FP, R0
    ADDI S3, S3, 4
    LOAD T1, SB, S3
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op20_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    LOAD T0, SB, S0
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op21_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t9 at FP+6
    ADD T4, FP, R0
    ADDI T4, T4, 6
    LOAD T5, SB, T4
    LI S2, 255
    AND T5, T5, S2
; Spill live registers before call
; Spill t7 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T3, SB, SC
; Spill t11 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T6, SB, SC
; Spill load_f22_op9_t10_bank_val to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T2, SB, SC
; Spill t12 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T7, SB, SC
; Spill t18 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T1, SB, SC
; Spill t19 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T0, SB, SC
; Spill t21 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T5, SB, SC
; Setting up 3 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Arg 2 (scalar) to A2
    ADD A2, T5, R0
; Call function text40_putchar
    CALL text40_putchar
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op22_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+4
    ADD S1, FP, R0
    ADDI S1, S1, 4
    LOAD S2, SB, S1
    LI T3, 1
    ADD S2, S2, T3
    STORE S2, SB, S1
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op23_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T6, FP, R0
    ADDI T6, T6, 5
    LOAD T2, SB, T6
    LI T7, 1
    ADD T2, T2, T7
    STORE T2, SB, T6
    BEQ R0, R0, L_text40_puts_15
; Unconditional branch to L_text40_puts_15
; Invalidated 2 alloca bindings
L_text40_puts_17:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_99999
L_text40_puts_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar_color:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 3 from A3
    ADD S0, A3, R0
; Load param 4 from FP-7
    ADDI SC, FP, -7
    LOAD T7, SB, SC
L_text40_putchar_color_18:
    ADD T6, FP, R0
    STORE S3, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE S2, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 2
    STORE S1, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 3
    STORE S0, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 4
    STORE T7, SB, T2
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op5_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T6
    LI T0, 0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S3, SB, SC
    SLT S3, T1, T0
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
    LI S2, 1
    SUB T1, S2, S3
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op8_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T6
    LI S2, 40
    SLT S3, S3, S2
    AND T1, T1, S3
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op9_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T5
    LI S2, 0
    SLT S3, T0, S2
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S1, SB, SC
    LI S1, 1
    SUB T0, S1, S3
    AND T1, T1, T0
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op12_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T5
    LI S1, 25
    SLT S3, S3, S1
    AND T1, T1, S3
    BEQ T1, R0, L_text40_putchar_color_21
; Branch to L_text40_putchar_color_21 if condition is false
    BEQ R0, R0, L_text40_putchar_color_19
; Unconditional branch to L_text40_putchar_color_19 (condition was true)
; Invalidated 5 alloca bindings
L_text40_putchar_color_19:
    ADD S2, FP, R0
    ADDI S2, S2, 5
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op13_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+1
    ADD T0, FP, R0
    ADDI T0, T0, 1
    LOAD S1, SB, T0
    LI S3, 40
    MUL S1, S1, S3
    LI T1, 32
    ADD T1, T1, S1
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op14_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+0
    ADD T2, FP, R0
    LOAD T3, SB, T2
    ADD T1, T1, T3
    STORE T1, SB, S2
    ADD T4, FP, R0
    ADDI T4, T4, 6
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op15_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t9 at FP+4
    ADD T5, FP, R0
    ADDI T5, T5, 4
    LOAD T6, SB, T5
    LI S3, 15
    AND T6, T6, S3
    LI S1, 4
    SLL T6, T6, S1
; Load instruction: t31 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op16_t31 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+3
    ADD T3, FP, R0
    ADDI T3, T3, 3
    LOAD S3, SB, T3
    LI S1, 15
    AND S3, S3, S1
    OR T6, T6, S3
    STORE T6, SB, T4
    ADD S1, FP, R0
    ADDI S1, S1, 7
; Load instruction: t35 = load FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op17_t35 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T4
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
    LI S0, 255
    AND S3, S3, S0
    LI S0, 8
    SLL S3, S3, S0
; Load instruction: t38 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op18_t38 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+2
    ADD S0, FP, R0
    ADDI S0, S0, 2
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T7, SB, SC
    LOAD T7, SB, S0
    LI T0, 255
    AND T7, T7, T0
    OR S3, S3, T7
    STORE S3, SB, S1
; Load instruction: t41 = load FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op19_t41 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S2
; Load instruction: t42 = load FatPtr(FatPointer { addr: Temp(34), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(34), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op20_t42 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S1
; Spill live registers before call
; Spill t26 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T1, SB, SC
; Spill t33 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T6, SB, SC
; Spill t40 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S3, SB, SC
; Spill t41 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T0, SB, SC
; Spill t42 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T7, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T0, R0
; Arg 1 (scalar) to A1
    ADD A1, T7, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_color_21
; Unconditional branch to L_text40_putchar_color_21
L_text40_putchar_color_21:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_color_99999
L_text40_putchar_color_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 3 from A3
    ADD S0, A3, R0
L_text40_putchar_attr_22:
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 1
    STORE S2, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S1, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 3
    STORE S0, SB, T4
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op4_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 0
    SLT T1, T3, T2
    LI T0, 1
    SUB T3, T0, T1
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op7_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    LI T0, 40
    SLT T1, T1, T0
    AND T3, T3, T1
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op8_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T6
    LI T0, 0
    SLT T1, T2, T0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
    LI S3, 1
    SUB T2, S3, T1
    AND T3, T3, T2
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op11_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T6
    LI S3, 25
    SLT T1, T1, S3
    AND T3, T3, T1
    BEQ T3, R0, L_text40_putchar_attr_25
; Branch to L_text40_putchar_attr_25 if condition is false
    BEQ R0, R0, L_text40_putchar_attr_23
; Unconditional branch to L_text40_putchar_attr_23 (condition was true)
; Invalidated 4 alloca bindings
L_text40_putchar_attr_23:
    ADD T0, FP, R0
    ADDI T0, T0, 4
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op12_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD S3, SB, T2
    LI T1, 40
    MUL S3, S3, T1
    LI T3, 32
    ADD T3, T3, S3
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op13_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+0
    ADD T4, FP, R0
    LOAD T5, SB, T4
    ADD T3, T3, T5
    STORE T3, SB, T0
    ADD T6, FP, R0
    ADDI T6, T6, 5
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op14_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+3
    ADD T7, FP, R0
    ADDI T7, T7, 3
    LOAD T1, SB, T7
    LI S3, 255
    AND T1, T1, S3
    LI T5, 8
    SLL T1, T1, T5
; Load instruction: t29 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op15_t29 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+2
    ADD S3, FP, R0
    ADDI S3, S3, 2
    LOAD T5, SB, S3
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
    LI S2, 255
    AND T5, T5, S2
    OR T1, T1, T5
    STORE T1, SB, T6
; Load instruction: t32 = load FatPtr(FatPointer { addr: Temp(19), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(19), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op16_t32 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S2, SB, T0
; Load instruction: t33 = load FatPtr(FatPointer { addr: Temp(25), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(25), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op17_t33 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, T6
; Spill live registers before call
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S0, SB, SC
; Spill t24 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T3, SB, SC
; Spill t31 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T1, SB, SC
; Spill t32 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S2, SB, SC
; Spill t33 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T5, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Arg 1 (scalar) to A1
    ADD A1, T5, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_attr_25
; Unconditional branch to L_text40_putchar_attr_25
L_text40_putchar_attr_25:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_attr_99999
L_text40_putchar_attr_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts_color:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 17 slots for locals
    ADDI SP, SP, 17
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
; Load param 3 from FP-7
    ADDI SC, FP, -7
    LOAD S0, SB, SC
; Load param 4 from FP-8
    ADDI SC, FP, -8
    LOAD T7, SB, SC
L_text40_puts_color_26:
    ADD T6, FP, R0
    STORE S3, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE S2, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 2
    STORE S1, SB, T4
    ADDI T3, T4, 1
    STORE A3, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 4
    STORE S0, SB, T2
    ADD T1, FP, R0
    ADDI T1, T1, 5
    STORE T7, SB, T1
    ADD T0, FP, R0
    ADDI T0, T0, 6
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op7_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T6
    STORE T3, SB, T0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S3, SB, SC
    ADD S3, FP, R0
    ADDI S3, S3, 7
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S2, SB, SC
    LI S2, 0
    STORE S2, SB, S3
    ADD S2, FP, R0
    ADDI S2, S2, 8
    BEQ R0, R0, L_text40_puts_color_27
; Unconditional branch to L_text40_puts_color_27
; Invalidated 8 alloca bindings
L_text40_puts_color_27:
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op9_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+2
    ADD T0, FP, R0
    ADDI T0, T0, 2
    LOAD T1, SB, T0
    ADDI T2, T0, 1
    LOAD T4, SB, T2
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op12_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+7
    ADD T5, FP, R0
    ADDI T5, T5, 7
    LOAD T6, SB, T5
    ADD S3, T6, R0
    ADD S2, T1, S3
; Runtime bank overflow calculation for dynamic GEP
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S1, SB, SC
    LI S1, 4096
    DIV T2, S2, S1
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S0, SB, SC
    MOD S0, S2, S1
; Base bank info: Dynamic("load_f28_op11_t14_bank_val")
; Clearing binding for 'gep_new_bank_f28_op17_t16'
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T7, SB, SC
; Computing new bank gep_new_bank_f28_op17_t16 = load_f28_op11_t14_bank_val + bank_delta
    ADD T7, T4, T2
; Result bank tracked as Dynamic(gep_new_bank_f28_op17_t16)
    ADD S2, S0, R0
; GEP: Setting bank info for t16 to Dynamic("gep_new_bank_f28_op17_t16")
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(16), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Mixed })
; LOAD: Pointer t16 has bank info: Dynamic("gep_new_bank_f28_op17_t16")
; LOAD: Using bank register T7 for load
    LOAD S3, T7, S2
; Recompute alloca t13 at FP+8
    ADD T2, FP, R0
    ADDI T2, T2, 8
    STORE S3, SB, T2
    LI S1, 0
    XOR S0, S3, S1
    LI T1, 0
    SLTU S3, T1, S0
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op20_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD S0, FP, R0
    ADDI S0, S0, 6
    LOAD T1, SB, S0
    LI S1, 40
    SLT T1, T1, S1
    AND S3, S3, T1
    BEQ S3, R0, L_text40_puts_color_29
; Branch to L_text40_puts_color_29 if condition is false
    BEQ R0, R0, L_text40_puts_color_28
; Unconditional branch to L_text40_puts_color_28 (condition was true)
; Invalidated 4 alloca bindings
; Invalidating GEP bank gep_new_bank_f28_op17_t16 in T7
; Invalidated 1 GEP bank bindings
L_text40_puts_color_28:
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op21_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD S1, FP, R0
    ADDI S1, S1, 6
    LOAD T1, SB, S1
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op22_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+1
    ADD S3, FP, R0
    ADDI S3, S3, 1
    LOAD T0, SB, S3
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(13), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(13), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op23_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t13 at FP+8
    ADD T2, FP, R0
    ADDI T2, T2, 8
    LOAD T5, SB, T2
    LI S0, 255
    AND T5, T5, S0
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op24_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+4
    ADD T7, FP, R0
    ADDI T7, T7, 4
    LOAD S0, SB, T7
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op25_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Spill t11 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T3, SB, SC
; Recompute alloca t9 at FP+5
    ADD T3, FP, R0
    ADDI T3, T3, 5
; Spill t15 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T6, SB, SC
    LOAD T6, SB, T3
; Spill live registers before call
; Spill load_f28_op11_t14_bank_val to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T4, SB, SC
; Spill t16 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE S2, SB, SC
; Spill t22 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T1, SB, SC
; Spill t23 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T0, SB, SC
; Spill t25 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T5, SB, SC
; Spill t26 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE S0, SB, SC
; Spill t27 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE T6, SB, SC
; Pushing 1 arguments to stack
; Push arg 4 (scalar) to stack
    STORE T6, SB, SP
    ADDI SP, SP, 1
; Setting up 4 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Arg 2 (scalar) to A2
    ADD A2, T5, R0
; Arg 3 (scalar) to A3
    ADD A3, S0, R0
; Pushed 1 words to stack
; Call function text40_putchar_color
    CALL text40_putchar_color
; Clean up 1 words from stack
    ADDI SP, SP, -1
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op26_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD T4, FP, R0
    ADDI T4, T4, 6
    LOAD S2, SB, T4
    LI S1, 1
    ADD S2, S2, S1
    STORE S2, SB, T4
; Load instruction: t30 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op27_t30 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+7
    ADD S3, FP, R0
    ADDI S3, S3, 7
    LOAD T2, SB, S3
    LI T7, 1
    ADD T2, T2, T7
    STORE T2, SB, S3
    BEQ R0, R0, L_text40_puts_color_27
; Unconditional branch to L_text40_puts_color_27
; Invalidated 2 alloca bindings
L_text40_puts_color_29:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_color_99999
L_text40_puts_color_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
; Load param 3 from FP-7
    ADDI SC, FP, -7
    LOAD S0, SB, SC
L_text40_puts_attr_30:
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 1
    STORE S2, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S1, SB, T5
    ADDI T4, T5, 1
    STORE A3, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 4
    STORE S0, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 5
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op6_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    STORE T1, SB, T2
    ADD T0, FP, R0
    ADDI T0, T0, 6
    LI T4, 0
    STORE T4, SB, T0
    ADD T4, FP, R0
    ADDI T4, T4, 7
    BEQ R0, R0, L_text40_puts_attr_31
; Unconditional branch to L_text40_puts_attr_31
; Invalidated 7 alloca bindings
L_text40_puts_attr_31:
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op8_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+2
    ADD T0, FP, R0
    ADDI T0, T0, 2
    LOAD T2, SB, T0
    ADDI T3, T0, 1
    LOAD T4, SB, T3
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op11_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD T5, FP, R0
    ADDI T5, T5, 6
    LOAD T6, SB, T5
    ADD T3, T6, R0
    ADD T7, T2, T3
; Runtime bank overflow calculation for dynamic GEP
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
    LI S2, 4096
    DIV S3, T7, S2
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S1, SB, SC
    MOD S1, T7, S2
; Base bank info: Dynamic("load_f30_op10_t12_bank_val")
; Clearing binding for 'gep_new_bank_f30_op16_t14'
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
; Computing new bank gep_new_bank_f30_op16_t14 = load_f30_op10_t12_bank_val + bank_delta
    ADD S0, T4, S3
; Result bank tracked as Dynamic(gep_new_bank_f30_op16_t14)
    ADD T7, S1, R0
; GEP: Setting bank info for t14 to Dynamic("gep_new_bank_f30_op16_t14")
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(14), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(14), bank: Mixed })
; LOAD: Pointer t14 has bank info: Dynamic("gep_new_bank_f30_op16_t14")
; LOAD: Using bank register S0 for load
    LOAD T3, S0, T7
; Recompute alloca t11 at FP+7
    ADD S3, FP, R0
    ADDI S3, S3, 7
    STORE T3, SB, S3
    LI S2, 0
    XOR S1, T3, S2
    LI T2, 0
    SLTU T3, T2, S1
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op19_t17 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD S1, FP, R0
    ADDI S1, S1, 5
    LOAD T2, SB, S1
    LI S2, 40
    SLT T2, T2, S2
    AND T3, T3, T2
    BEQ T3, R0, L_text40_puts_attr_33
; Branch to L_text40_puts_attr_33 if condition is false
    BEQ R0, R0, L_text40_puts_attr_32
; Unconditional branch to L_text40_puts_attr_32 (condition was true)
; Invalidated 4 alloca bindings
; Invalidating GEP bank gep_new_bank_f30_op16_t14 in S0
; Invalidated 1 GEP bank bindings
L_text40_puts_attr_32:
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op20_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD S2, FP, R0
    ADDI S2, S2, 5
    LOAD T2, SB, S2
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op21_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+1
    ADD T3, FP, R0
    ADDI T3, T3, 1
    LOAD T0, SB, T3
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(11), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(11), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op22_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t11 at FP+7
    ADD T5, FP, R0
    ADDI T5, T5, 7
    LOAD S1, SB, T5
    LI S3, 255
    AND S1, S1, S3
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op23_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+4
    ADD S0, FP, R0
    ADDI S0, S0, 4
    LOAD S3, SB, S0
; Spill live registers before call
; Spill t9 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T1, SB, SC
; Spill t13 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T6, SB, SC
; Spill load_f30_op10_t12_bank_val to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T4, SB, SC
; Spill t14 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T7, SB, SC
; Spill t20 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T2, SB, SC
; Spill t21 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T0, SB, SC
; Spill t23 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE S1, SB, SC
; Spill t24 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE S3, SB, SC
; Setting up 4 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Arg 2 (scalar) to A2
    ADD A2, S1, R0
; Arg 3 (scalar) to A3
    ADD A3, S3, R0
; Call function text40_putchar_attr
    CALL text40_putchar_attr
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op24_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T1, FP, R0
    ADDI T1, T1, 5
    LOAD T6, SB, T1
    LI T4, 1
    ADD T6, T6, T4
    STORE T6, SB, T1
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op25_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD T7, FP, R0
    ADDI T7, T7, 6
    LOAD S2, SB, T7
    LI T3, 1
    ADD S2, S2, T3
    STORE S2, SB, T7
    BEQ R0, R0, L_text40_puts_attr_31
; Unconditional branch to L_text40_puts_attr_31
; Invalidated 2 alloca bindings
L_text40_puts_attr_33:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_attr_99999
L_text40_puts_attr_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_set_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
L_text40_set_attr_34:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op3_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S0
    LI T4, 0
    SLT T3, T5, T4
    LI T2, 1
    SUB T5, T2, T3
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op6_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 40
    SLT T1, T1, T0
    AND T5, T5, T1
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op7_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 0
    SLT T4, T3, T2
    LI T0, 1
    SUB T3, T0, T4
    AND T5, T5, T3
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op10_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    LI T4, 25
    SLT T1, T1, T4
    AND T5, T5, T1
    BEQ T5, R0, L_text40_set_attr_37
; Branch to L_text40_set_attr_37 if condition is false
    BEQ R0, R0, L_text40_set_attr_35
; Unconditional branch to L_text40_set_attr_35 (condition was true)
; Invalidated 3 alloca bindings
L_text40_set_attr_35:
    ADD T0, FP, R0
    ADDI T0, T0, 3
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op11_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD T3, SB, T2
    LI T4, 40
    MUL T3, T3, T4
    LI T1, 32
    ADD T1, T1, T3
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op12_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+0
    ADD T5, FP, R0
    LOAD T6, SB, T5
    ADD T1, T1, T6
    STORE T1, SB, T0
    ADD T7, FP, R0
    ADDI T7, T7, 4
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op13_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T0
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T1, SB, SC
; Spill t24 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t25
; Recompute alloca t23 at FP+4
    ADD T4, FP, R0
    ADDI T4, T4, 4
    STORE RV0, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 5
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op14_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+2
    ADD T6, FP, R0
    ADDI T6, T6, 2
    LOAD S3, SB, T6
    LI S2, 255
    AND S3, S3, S2
    LI S1, 8
    SLL S3, S3, S1
; Load instruction: t30 = load FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op15_t30 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T4
    LI T5, 255
    AND T2, T2, T5
    OR S3, S3, T2
    STORE S3, SB, T3
; Load instruction: t33 = load FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op16_t33 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t17 at FP+3
    ADD T1, FP, R0
    ADDI T1, T1, 3
    LOAD T7, SB, T1
; Load instruction: t34 = load FatPtr(FatPointer { addr: Temp(26), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(26), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op17_t34 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T3
; Spill live registers before call
; Spill t25 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE RV0, SB, SC
; Spill t32 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S3, SB, SC
; Spill t33 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T7, SB, SC
; Spill t34 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T0, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_set_attr_37
; Unconditional branch to L_text40_set_attr_37
L_text40_set_attr_37:
; Jump to epilogue
    BEQ R0, R0, L_text40_set_attr_99999
L_text40_set_attr_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_get_char:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 12 slots for locals
    ADDI SP, SP, 12
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_text40_get_char_38:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op2_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S1
    LI T6, 0
    SLT T5, T7, T6
    LI T4, 1
    SUB T7, T4, T5
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op5_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S1
    LI T2, 40
    SLT T3, T3, T2
    AND T7, T7, T3
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op6_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 0
    SLT T5, T1, T0
    LI T4, 1
    SUB T1, T4, T5
    AND T7, T7, T1
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op9_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S0
    LI T2, 25
    SLT T6, T6, T2
    AND T7, T7, T6
    BEQ T7, R0, L_text40_get_char_41
; Branch to L_text40_get_char_41 if condition is false
    BEQ R0, R0, L_text40_get_char_39
; Unconditional branch to L_text40_get_char_39 (condition was true)
; Invalidated 2 alloca bindings
L_text40_get_char_39:
    ADD T3, FP, R0
    ADDI T3, T3, 2
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op10_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    LOAD T4, SB, T5
    LI T0, 40
    MUL T4, T4, T0
    LI T1, 32
    ADD T1, T1, T4
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op11_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T2, FP, R0
    LOAD T6, SB, T2
    ADD T1, T1, T6
    STORE T1, SB, T3
    ADD T7, FP, R0
    ADDI T7, T7, 3
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op12_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T3
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S2, SB, SC
; Spill t20 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t23
; Recompute alloca t21 at FP+3
    ADD S1, FP, R0
    ADDI S1, S1, 3
    STORE RV0, SB, S1
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op13_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S1
    LI T4, 255
    AND T0, T0, T4
    MOVE RV0, T0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_char_99999
    BEQ R0, R0, L_text40_get_char_41
; Unconditional branch to L_text40_get_char_41
; Invalidated 1 alloca bindings
L_text40_get_char_41:
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_char_99999
L_text40_get_char_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_get_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 12 slots for locals
    ADDI SP, SP, 12
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_text40_get_attr_42:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op2_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S1
    LI T6, 0
    SLT T5, T7, T6
    LI T4, 1
    SUB T7, T4, T5
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op5_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S1
    LI T2, 40
    SLT T3, T3, T2
    AND T7, T7, T3
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op6_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 0
    SLT T5, T1, T0
    LI T4, 1
    SUB T1, T4, T5
    AND T7, T7, T1
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op9_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S0
    LI T2, 25
    SLT T6, T6, T2
    AND T7, T7, T6
    BEQ T7, R0, L_text40_get_attr_45
; Branch to L_text40_get_attr_45 if condition is false
    BEQ R0, R0, L_text40_get_attr_43
; Unconditional branch to L_text40_get_attr_43 (condition was true)
; Invalidated 2 alloca bindings
L_text40_get_attr_43:
    ADD T3, FP, R0
    ADDI T3, T3, 2
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op10_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    LOAD T4, SB, T5
    LI T0, 40
    MUL T4, T4, T0
    LI T1, 32
    ADD T1, T1, T4
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op11_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T2, FP, R0
    LOAD T6, SB, T2
    ADD T1, T1, T6
    STORE T1, SB, T3
    ADD T7, FP, R0
    ADDI T7, T7, 3
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op12_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T3
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S2, SB, SC
; Spill t20 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t23
; Recompute alloca t21 at FP+3
    ADD S1, FP, R0
    ADDI S1, S1, 3
    STORE RV0, SB, S1
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op13_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S1
    LI T4, 8
    SRL T0, T0, T4
    LI T6, 255
    AND T0, T0, T6
    MOVE RV0, T0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_attr_99999
    BEQ R0, R0, L_text40_get_attr_45
; Unconditional branch to L_text40_get_attr_45
; Invalidated 1 alloca bindings
L_text40_get_attr_45:
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_attr_99999
L_text40_get_attr_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
