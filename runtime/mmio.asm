; Generated by Ripple C99 Compiler (rcc)

mmio_read:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
    ADD S2, FP, R0
    STORE S3, SB, S2
    ADD S1, FP, R0
    ADDI S1, S1, 1
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op2_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, S2
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t4 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S0, SB, SC
; Setup: Load inputs
; Reload t4 from slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    LOAD T6, SB, SC
; Inline assembly code
    LOAD T7, R0, T6
; Teardown: Bind outputs
; Output t3 now in T7
; === End inline assembly ===
; Recompute alloca t2 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE T7, SB, T5
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op5_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, T5
    MOVE RV0, T4
; Jump to epilogue
    BEQ R0, R0, L_mmio_read_99999
L_mmio_read_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
mmio_write:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_mmio_write_1:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op4_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S0
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op6_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S1
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S2, SB, SC
; Spill t4 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE T7, SB, SC
; Spill t5 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T6, SB, SC
; Setup: Load inputs
; Reload t4 from slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    LOAD T5, SB, SC
; Reload t5 from slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    LOAD T4, SB, SC
; Inline assembly code
    STORE T5, R0, T4
; Teardown: Bind outputs
; === End inline assembly ===
; Jump to epilogue
    BEQ R0, R0, L_mmio_write_99999
L_mmio_write_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
tty_putchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_tty_putchar_2:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 0
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f4_op4_0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_tty_putchar_99999
L_tty_putchar_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_get:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_rng_get_3:
    LI S3, 4
; Spill live registers before call
; Spill const_f6_op0_4 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_rng_get_99999
L_rng_get_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_get_seed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_rng_get_seed_4:
    LI S3, 5
; Spill live registers before call
; Spill const_f8_op0_5 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_rng_get_seed_99999
L_rng_get_seed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_set_seed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_rng_set_seed_5:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f10_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 5
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f10_op4_5 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_rng_set_seed_99999
L_rng_set_seed_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_set_mode:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_display_set_mode_6:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f12_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
    LI S0, 6
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f12_op4_6 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_set_mode_99999
L_display_set_mode_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_set_resolution:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 11 slots for locals
    ADDI SP, SP, 11
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_display_set_resolution_7:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f14_op4_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S1
    LI T5, 8
    SLL T6, T6, T5
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f14_op6_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, S0
    OR T6, T6, T4
    STORE T6, SB, T7
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f14_op9_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 16
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S2, SB, SC
; Spill t8 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T6, SB, SC
; Spill const_f14_op11_16 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T2, SB, SC
; Spill t9 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE T3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Arg 1 (scalar) to A1
    ADD A1, T3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_set_resolution_99999
L_display_set_resolution_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_enable:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_enable_8:
    LI S3, 1
    LI S2, 0
    SLL S3, S3, S2
    LI S1, 8
; Spill live registers before call
; Spill const_f16_op0_8 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S1, SB, SC
; Spill t0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Arg 1 (scalar) to A1
    ADD A1, S3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_enable_99999
L_display_enable_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_clear:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_clear_9:
    LI S3, 1
    LI S2, 0
    SLL S3, S3, S2
    LI S1, 1
    LI S1, 1
    SLL S0, S1, S1
    OR S3, S3, S0
    LI T7, 8
; Spill live registers before call
; Spill const_f18_op0_8 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE T7, SB, SC
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Arg 1 (scalar) to A1
    ADD A1, S3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_clear_99999
L_display_clear_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_flush:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_flush_10:
    LI S3, 9
    LI S2, 1
; Spill live registers before call
; Spill const_f20_op0_9 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Spill const_f20_op1_1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S2, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Arg 1 (scalar) to A1
    ADD A1, S2, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_flush_99999
L_display_flush_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 13 slots for locals
    ADDI SP, SP, 13
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
L_text40_putchar_11:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op6_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S0
    LI T4, 0
    SLT T3, T5, T4
    LI T2, 1
    SUB T5, T2, T3
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op10_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 40
    SLT T1, T1, T0
    AND T5, T5, T1
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op12_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 0
    SLT T4, T3, T2
    LI T0, 1
    SUB T3, T0, T4
    AND T5, T5, T3
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op16_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    LI T4, 25
    SLT T1, T1, T4
    AND T5, T5, T1
    BEQ T5, R0, L_text40_putchar_14
; Branch to L_text40_putchar_14 if condition is false
    BEQ R0, R0, L_text40_putchar_12
; Unconditional branch to L_text40_putchar_12 (condition was true)
; Invalidated 3 alloca bindings
L_text40_putchar_12:
    ADD T0, FP, R0
    ADDI T0, T0, 3
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op18_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD T3, SB, T2
    LI T4, 40
    MUL T3, T3, T4
    LI T1, 32
    ADD T1, T1, T3
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op20_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+0
    ADD T5, FP, R0
    LOAD T6, SB, T5
    ADD T1, T1, T6
    STORE T1, SB, T0
    ADD T7, FP, R0
    ADDI T7, T7, 4
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op23_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+2
    ADD S0, FP, R0
    ADDI S0, S0, 2
    LOAD T4, SB, S0
    LI T3, 255
    AND T4, T4, T3
    STORE T4, SB, T7
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op26_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, T0
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; LOAD: Pointer load_src_ptr_f22_op28_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S2, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T1, SB, SC
; Spill t25 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T4, SB, SC
; Spill t26 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T6, SB, SC
; Spill t27 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T6, R0
; Arg 1 (scalar) to A1
    ADD A1, T3, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_14
; Unconditional branch to L_text40_putchar_14
L_text40_putchar_14:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_99999
L_text40_putchar_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 15 slots for locals
    ADDI SP, SP, 15
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
L_text40_puts_15:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
    ADDI T5, T6, 1
    STORE A3, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 4
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op9_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S0
    STORE T3, SB, T4
    ADD T2, FP, R0
    ADDI T2, T2, 5
    LI T1, 0
    STORE T1, SB, T2
    ADD T0, FP, R0
    ADDI T0, T0, 6
    BEQ R0, R0, L_text40_puts_16
; Unconditional branch to L_text40_puts_16
; Invalidated 6 alloca bindings
L_text40_puts_16:
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op14_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+2
    ADD T5, FP, R0
    ADDI T5, T5, 2
    LOAD T1, SB, T5
    ADDI T0, T5, 1
    LOAD T2, SB, T0
; Bank value in T2 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op18_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T4, FP, R0
    ADDI T4, T4, 5
    LOAD T6, SB, T4
    ADD S0, T6, R0
    ADD T7, T1, S0
; Runtime bank overflow calculation for dynamic GEP
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S3, SB, SC
    LI S3, 4096
    DIV T0, T7, S3
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S2, SB, SC
    MOD S2, T7, S3
; Base bank info: Dynamic("load_f24_op17_t10_bank_val")
; Clearing binding for 'gep_new_bank_f24_op24_t12'
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S1, SB, SC
; Computing new bank gep_new_bank_f24_op24_t12 = load_f24_op17_t10_bank_val + bank_delta
    ADD S1, T2, T0
; Result bank tracked as Dynamic(gep_new_bank_f24_op24_t12)
    ADD T7, S2, R0
; GEP: Setting bank info for t12 to Dynamic("gep_new_bank_f24_op24_t12")
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(12), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Mixed })
; LOAD: Pointer t12 has bank info: Dynamic("gep_new_bank_f24_op24_t12")
    LI T0, -1
    BEQ S1, T0, L_bc_1650dea2_use_global
    LI S3, -2
    BEQ S1, S3, L_bc_1650dea2_use_stack
    ADD S0, S1, R0
    BEQ R0, R0, L_bc_1650dea2_done
L_bc_1650dea2_use_global:
    ADD S0, GP, R0
    BEQ R0, R0, L_bc_1650dea2_done
L_bc_1650dea2_use_stack:
    ADD S0, SB, R0
L_bc_1650dea2_done:
; LOAD: Using bank register S0 for load
    LOAD S2, S0, T7
; Recompute alloca t9 at FP+6
    ADD T0, FP, R0
    ADDI T0, T0, 6
    STORE S2, SB, T0
    LI S3, 0
; Spill t7 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T3, SB, SC
    XOR T3, S2, S3
    LI T5, 0
    SLTU S2, T5, T3
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op32_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+4
    ADD T3, FP, R0
    ADDI T3, T3, 4
    LOAD T5, SB, T3
    LI S3, 40
    SLT T5, T5, S3
    AND S2, S2, T5
    BEQ S2, R0, L_text40_puts_18
; Branch to L_text40_puts_18 if condition is false
    BEQ R0, R0, L_text40_puts_17
; Unconditional branch to L_text40_puts_17 (condition was true)
; Invalidated 3 alloca bindings
; Invalidating GEP bank gep_new_bank_f24_op24_t12 in S1
; Invalidated 1 GEP bank bindings
L_text40_puts_17:
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op34_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+4
    ADD S3, FP, R0
    ADDI S3, S3, 4
    LOAD T5, SB, S3
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op36_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+1
    ADD S2, FP, R0
    ADDI S2, S2, 1
    LOAD T0, SB, S2
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op38_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t9 at FP+6
    ADD T3, FP, R0
    ADDI T3, T3, 6
    LOAD T4, SB, T3
    LI S1, 255
    AND T4, T4, S1
; Spill live registers before call
; Spill t10 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T1, SB, SC
; Spill t11 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T6, SB, SC
; Spill load_f24_op17_t10_bank_val to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T2, SB, SC
; Spill t12 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T7, SB, SC
; Spill load_f24_op25_t13_resolved_bank_24_f24_op26 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S0, SB, SC
; Spill t18 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T5, SB, SC
; Spill t19 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T0, SB, SC
; Spill t21 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T4, SB, SC
; Setting up 3 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T5, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Arg 2 (scalar) to A2
    ADD A2, T4, R0
; Call function text40_putchar
    CALL text40_putchar
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op40_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+4
    ADD S1, FP, R0
    ADDI S1, S1, 4
    LOAD T1, SB, S1
    LI T6, 1
    ADD T1, T1, T6
    STORE T1, SB, S1
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f24_op43_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T2, FP, R0
    ADDI T2, T2, 5
    LOAD T7, SB, T2
    LI S0, 1
    ADD T7, T7, S0
    STORE T7, SB, T2
    BEQ R0, R0, L_text40_puts_16
; Unconditional branch to L_text40_puts_16
; Invalidated 2 alloca bindings
L_text40_puts_18:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_99999
L_text40_puts_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar_color:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 3 from A3
    ADD S0, A3, R0
; Load param 4 from FP-7
    ADDI SC, FP, -7
    LOAD T7, SB, SC
L_text40_putchar_color_19:
    ADD T6, FP, R0
    STORE S3, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE S2, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 2
    STORE S1, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 3
    STORE S0, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 4
    STORE T7, SB, T2
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op10_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T6
    LI T0, 0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S3, SB, SC
    SLT S3, T1, T0
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
    LI S2, 1
    SUB T1, S2, S3
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op14_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T6
    LI S2, 40
    SLT S3, S3, S2
    AND T1, T1, S3
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op16_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T5
    LI S2, 0
    SLT S3, T0, S2
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S1, SB, SC
    LI S1, 1
    SUB T0, S1, S3
    AND T1, T1, T0
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op20_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T5
    LI S1, 25
    SLT S3, S3, S1
    AND T1, T1, S3
    BEQ T1, R0, L_text40_putchar_color_22
; Branch to L_text40_putchar_color_22 if condition is false
    BEQ R0, R0, L_text40_putchar_color_20
; Unconditional branch to L_text40_putchar_color_20 (condition was true)
; Invalidated 5 alloca bindings
L_text40_putchar_color_20:
    ADD S2, FP, R0
    ADDI S2, S2, 5
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op22_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+1
    ADD T0, FP, R0
    ADDI T0, T0, 1
    LOAD S1, SB, T0
    LI S3, 40
    MUL S1, S1, S3
    LI T1, 32
    ADD T1, T1, S1
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op24_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+0
    ADD T2, FP, R0
    LOAD T3, SB, T2
    ADD T1, T1, T3
    STORE T1, SB, S2
    ADD T4, FP, R0
    ADDI T4, T4, 6
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op27_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t9 at FP+4
    ADD T5, FP, R0
    ADDI T5, T5, 4
    LOAD T6, SB, T5
    LI S3, 15
    AND T6, T6, S3
    LI S1, 4
    SLL T6, T6, S1
; Load instruction: t31 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op29_t31 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+3
    ADD T3, FP, R0
    ADDI T3, T3, 3
    LOAD S3, SB, T3
    LI S1, 15
    AND S3, S3, S1
    OR T6, T6, S3
    STORE T6, SB, T4
    ADD S1, FP, R0
    ADDI S1, S1, 7
; Load instruction: t35 = load FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op32_t35 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T4
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
    LI S0, 255
    AND S3, S3, S0
    LI S0, 8
    SLL S3, S3, S0
; Load instruction: t38 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op34_t38 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+2
    ADD S0, FP, R0
    ADDI S0, S0, 2
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T7, SB, SC
    LOAD T7, SB, S0
    LI T0, 255
    AND T7, T7, T0
    OR S3, S3, T7
    STORE S3, SB, S1
; Load instruction: t41 = load FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op37_t41 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S2
; Load instruction: t42 = load FatPtr(FatPointer { addr: Temp(34), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(34), bank: Stack })
; LOAD: Pointer load_src_ptr_f26_op39_t42 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S1
; Spill live registers before call
; Spill t26 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T1, SB, SC
; Spill t33 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T6, SB, SC
; Spill t40 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S3, SB, SC
; Spill t41 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T0, SB, SC
; Spill t42 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T7, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T0, R0
; Arg 1 (scalar) to A1
    ADD A1, T7, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_color_22
; Unconditional branch to L_text40_putchar_color_22
L_text40_putchar_color_22:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_color_99999
L_text40_putchar_color_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 3 from A3
    ADD S0, A3, R0
L_text40_putchar_attr_23:
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 1
    STORE S2, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S1, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 3
    STORE S0, SB, T4
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op8_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 0
    SLT T1, T3, T2
    LI T0, 1
    SUB T3, T0, T1
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op12_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    LI T0, 40
    SLT T1, T1, T0
    AND T3, T3, T1
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op14_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T6
    LI T0, 0
    SLT T1, T2, T0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
    LI S3, 1
    SUB T2, S3, T1
    AND T3, T3, T2
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op18_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T6
    LI S3, 25
    SLT T1, T1, S3
    AND T3, T3, T1
    BEQ T3, R0, L_text40_putchar_attr_26
; Branch to L_text40_putchar_attr_26 if condition is false
    BEQ R0, R0, L_text40_putchar_attr_24
; Unconditional branch to L_text40_putchar_attr_24 (condition was true)
; Invalidated 4 alloca bindings
L_text40_putchar_attr_24:
    ADD T0, FP, R0
    ADDI T0, T0, 4
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op20_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD S3, SB, T2
    LI T1, 40
    MUL S3, S3, T1
    LI T3, 32
    ADD T3, T3, S3
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op22_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+0
    ADD T4, FP, R0
    LOAD T5, SB, T4
    ADD T3, T3, T5
    STORE T3, SB, T0
    ADD T6, FP, R0
    ADDI T6, T6, 5
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op25_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+3
    ADD T7, FP, R0
    ADDI T7, T7, 3
    LOAD T1, SB, T7
    LI S3, 255
    AND T1, T1, S3
    LI T5, 8
    SLL T1, T1, T5
; Load instruction: t29 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op27_t29 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+2
    ADD S3, FP, R0
    ADDI S3, S3, 2
    LOAD T5, SB, S3
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
    LI S2, 255
    AND T5, T5, S2
    OR T1, T1, T5
    STORE T1, SB, T6
; Load instruction: t32 = load FatPtr(FatPointer { addr: Temp(19), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(19), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op30_t32 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S2, SB, T0
; Load instruction: t33 = load FatPtr(FatPointer { addr: Temp(25), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(25), bank: Stack })
; LOAD: Pointer load_src_ptr_f28_op32_t33 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, T6
; Spill live registers before call
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S0, SB, SC
; Spill t24 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T3, SB, SC
; Spill t31 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T1, SB, SC
; Spill t32 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S2, SB, SC
; Spill t33 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T5, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Arg 1 (scalar) to A1
    ADD A1, T5, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_attr_26
; Unconditional branch to L_text40_putchar_attr_26
L_text40_putchar_attr_26:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_attr_99999
L_text40_putchar_attr_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts_color:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 17 slots for locals
    ADDI SP, SP, 17
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
; Load param 3 from FP-7
    ADDI SC, FP, -7
    LOAD S0, SB, SC
; Load param 4 from FP-8
    ADDI SC, FP, -8
    LOAD T7, SB, SC
L_text40_puts_color_27:
    ADD T6, FP, R0
    STORE S3, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE S2, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 2
    STORE S1, SB, T4
    ADDI T3, T4, 1
    STORE A3, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 4
    STORE S0, SB, T2
    ADD T1, FP, R0
    ADDI T1, T1, 5
    STORE T7, SB, T1
    ADD T0, FP, R0
    ADDI T0, T0, 6
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op13_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T6
    STORE T3, SB, T0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S3, SB, SC
    ADD S3, FP, R0
    ADDI S3, S3, 7
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S2, SB, SC
    LI S2, 0
    STORE S2, SB, S3
    ADD S2, FP, R0
    ADDI S2, S2, 8
    BEQ R0, R0, L_text40_puts_color_28
; Unconditional branch to L_text40_puts_color_28
; Invalidated 8 alloca bindings
L_text40_puts_color_28:
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op18_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+2
    ADD T0, FP, R0
    ADDI T0, T0, 2
    LOAD T1, SB, T0
    ADDI T2, T0, 1
    LOAD T4, SB, T2
; Bank value in T4 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op22_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+7
    ADD T5, FP, R0
    ADDI T5, T5, 7
    LOAD T6, SB, T5
    ADD S3, T6, R0
    ADD S2, T1, S3
; Runtime bank overflow calculation for dynamic GEP
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S1, SB, SC
    LI S1, 4096
    DIV T2, S2, S1
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S0, SB, SC
    MOD S0, S2, S1
; Base bank info: Dynamic("load_f30_op21_t14_bank_val")
; Clearing binding for 'gep_new_bank_f30_op28_t16'
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T7, SB, SC
; Computing new bank gep_new_bank_f30_op28_t16 = load_f30_op21_t14_bank_val + bank_delta
    ADD T7, T4, T2
; Result bank tracked as Dynamic(gep_new_bank_f30_op28_t16)
    ADD S2, S0, R0
; GEP: Setting bank info for t16 to Dynamic("gep_new_bank_f30_op28_t16")
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(16), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Mixed })
; LOAD: Pointer t16 has bank info: Dynamic("gep_new_bank_f30_op28_t16")
    LI T2, -1
    BEQ T7, T2, L_bc_ca399e06_use_global
    LI S1, -2
    BEQ T7, S1, L_bc_ca399e06_use_stack
    ADD S3, T7, R0
    BEQ R0, R0, L_bc_ca399e06_done
L_bc_ca399e06_use_global:
    ADD S3, GP, R0
    BEQ R0, R0, L_bc_ca399e06_done
L_bc_ca399e06_use_stack:
    ADD S3, SB, R0
L_bc_ca399e06_done:
; LOAD: Using bank register S3 for load
    LOAD S0, S3, S2
; Recompute alloca t13 at FP+8
    ADD T2, FP, R0
    ADDI T2, T2, 8
    STORE S0, SB, T2
    LI S1, 0
; Spill t11 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T3, SB, SC
    XOR T3, S0, S1
    LI T0, 0
    SLTU S0, T0, T3
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op36_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD T3, FP, R0
    ADDI T3, T3, 6
    LOAD T0, SB, T3
    LI S1, 40
    SLT T0, T0, S1
    AND S0, S0, T0
    BEQ S0, R0, L_text40_puts_color_30
; Branch to L_text40_puts_color_30 if condition is false
    BEQ R0, R0, L_text40_puts_color_29
; Unconditional branch to L_text40_puts_color_29 (condition was true)
; Invalidated 3 alloca bindings
; Invalidating GEP bank gep_new_bank_f30_op28_t16 in T7
; Invalidated 1 GEP bank bindings
L_text40_puts_color_29:
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op38_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD S1, FP, R0
    ADDI S1, S1, 6
    LOAD T0, SB, S1
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op40_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    LOAD T2, SB, S0
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(13), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(13), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op42_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t13 at FP+8
    ADD T3, FP, R0
    ADDI T3, T3, 8
    LOAD T5, SB, T3
    LI T7, 255
    AND T5, T5, T7
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op44_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+4
    ADD T7, FP, R0
    ADDI T7, T7, 4
; Spill t14 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T1, SB, SC
    LOAD T1, SB, T7
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op46_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Spill t15 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T6, SB, SC
; Recompute alloca t9 at FP+5
    ADD T6, FP, R0
    ADDI T6, T6, 5
; Spill load_f30_op21_t14_bank_val to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T4, SB, SC
    LOAD T4, SB, T6
; Spill live registers before call
; Spill t16 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE S2, SB, SC
; Spill load_f30_op29_t17_resolved_bank_30_f30_op30 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE S3, SB, SC
; Spill t22 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T0, SB, SC
; Spill t23 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE T2, SB, SC
; Spill t25 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE T5, SB, SC
; Spill t26 to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 31
    STORE T1, SB, SC
; Spill t27 to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 32
    STORE T4, SB, SC
; Pushing 1 arguments to stack
; Push arg 4 (scalar) to stack
    STORE T4, SB, SP
    ADDI SP, SP, 1
; Setting up 4 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T0, R0
; Arg 1 (scalar) to A1
    ADD A1, T2, R0
; Arg 2 (scalar) to A2
    ADD A2, T5, R0
; Arg 3 (scalar) to A3
    ADD A3, T1, R0
; Pushed 1 words to stack
; Call function text40_putchar_color
    CALL text40_putchar_color
; Clean up 1 words from stack
    ADDI SP, SP, -1
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op48_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD S2, FP, R0
    ADDI S2, S2, 6
    LOAD S3, SB, S2
    LI S1, 1
    ADD S3, S3, S1
    STORE S3, SB, S2
; Load instruction: t30 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f30_op51_t30 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+7
    ADD S0, FP, R0
    ADDI S0, S0, 7
    LOAD T3, SB, S0
    LI T7, 1
    ADD T3, T3, T7
    STORE T3, SB, S0
    BEQ R0, R0, L_text40_puts_color_28
; Unconditional branch to L_text40_puts_color_28
; Invalidated 2 alloca bindings
L_text40_puts_color_30:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_color_99999
L_text40_puts_color_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
; Load param 3 from FP-7
    ADDI SC, FP, -7
    LOAD S0, SB, SC
L_text40_puts_attr_31:
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 1
    STORE S2, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S1, SB, T5
    ADDI T4, T5, 1
    STORE A3, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 4
    STORE S0, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 5
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op11_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    STORE T1, SB, T2
    ADD T0, FP, R0
    ADDI T0, T0, 6
    LI T4, 0
    STORE T4, SB, T0
    ADD T4, FP, R0
    ADDI T4, T4, 7
    BEQ R0, R0, L_text40_puts_attr_32
; Unconditional branch to L_text40_puts_attr_32
; Invalidated 7 alloca bindings
L_text40_puts_attr_32:
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op16_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+2
    ADD T0, FP, R0
    ADDI T0, T0, 2
    LOAD T2, SB, T0
    ADDI T3, T0, 1
    LOAD T4, SB, T3
; Bank value in T4 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op20_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD T5, FP, R0
    ADDI T5, T5, 6
    LOAD T6, SB, T5
    ADD T3, T6, R0
    ADD T7, T2, T3
; Runtime bank overflow calculation for dynamic GEP
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
    LI S2, 4096
    DIV S3, T7, S2
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S1, SB, SC
    MOD S1, T7, S2
; Base bank info: Dynamic("load_f32_op19_t12_bank_val")
; Clearing binding for 'gep_new_bank_f32_op26_t14'
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
; Computing new bank gep_new_bank_f32_op26_t14 = load_f32_op19_t12_bank_val + bank_delta
    ADD S0, T4, S3
; Result bank tracked as Dynamic(gep_new_bank_f32_op26_t14)
    ADD T7, S1, R0
; GEP: Setting bank info for t14 to Dynamic("gep_new_bank_f32_op26_t14")
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(14), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(14), bank: Mixed })
; LOAD: Pointer t14 has bank info: Dynamic("gep_new_bank_f32_op26_t14")
    LI S3, -1
    BEQ S0, S3, L_bc_87aec18e_use_global
    LI S2, -2
    BEQ S0, S2, L_bc_87aec18e_use_stack
    ADD T3, S0, R0
    BEQ R0, R0, L_bc_87aec18e_done
L_bc_87aec18e_use_global:
    ADD T3, GP, R0
    BEQ R0, R0, L_bc_87aec18e_done
L_bc_87aec18e_use_stack:
    ADD T3, SB, R0
L_bc_87aec18e_done:
; LOAD: Using bank register T3 for load
    LOAD S1, T3, T7
; Recompute alloca t11 at FP+7
    ADD S3, FP, R0
    ADDI S3, S3, 7
    STORE S1, SB, S3
    LI S2, 0
; Spill t9 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T1, SB, SC
    XOR T1, S1, S2
    LI T0, 0
    SLTU S1, T0, T1
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op34_t17 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T1, FP, R0
    ADDI T1, T1, 5
    LOAD T0, SB, T1
    LI S2, 40
    SLT T0, T0, S2
    AND S1, S1, T0
    BEQ S1, R0, L_text40_puts_attr_34
; Branch to L_text40_puts_attr_34 if condition is false
    BEQ R0, R0, L_text40_puts_attr_33
; Unconditional branch to L_text40_puts_attr_33 (condition was true)
; Invalidated 3 alloca bindings
; Invalidating GEP bank gep_new_bank_f32_op26_t14 in S0
; Invalidated 1 GEP bank bindings
L_text40_puts_attr_33:
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op36_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD S2, FP, R0
    ADDI S2, S2, 5
    LOAD T0, SB, S2
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op38_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+1
    ADD S1, FP, R0
    ADDI S1, S1, 1
    LOAD T1, SB, S1
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(11), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(11), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op40_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t11 at FP+7
    ADD T5, FP, R0
    ADDI T5, T5, 7
    LOAD S3, SB, T5
    LI S0, 255
    AND S3, S3, S0
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op42_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+4
    ADD S0, FP, R0
    ADDI S0, S0, 4
; Spill t12 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T2, SB, SC
    LOAD T2, SB, S0
; Spill live registers before call
; Spill t13 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T6, SB, SC
; Spill load_f32_op19_t12_bank_val to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T4, SB, SC
; Spill t14 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T7, SB, SC
; Spill load_f32_op27_t15_resolved_bank_32_f32_op28 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T3, SB, SC
; Spill t20 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T0, SB, SC
; Spill t21 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T1, SB, SC
; Spill t23 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE S3, SB, SC
; Spill t24 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE T2, SB, SC
; Setting up 4 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T0, R0
; Arg 1 (scalar) to A1
    ADD A1, T1, R0
; Arg 2 (scalar) to A2
    ADD A2, S3, R0
; Arg 3 (scalar) to A3
    ADD A3, T2, R0
; Call function text40_putchar_attr
    CALL text40_putchar_attr
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op44_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+5
    ADD T6, FP, R0
    ADDI T6, T6, 5
    LOAD T4, SB, T6
    LI T7, 1
    ADD T4, T4, T7
    STORE T4, SB, T6
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f32_op47_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+6
    ADD T3, FP, R0
    ADDI T3, T3, 6
    LOAD S2, SB, T3
    LI S1, 1
    ADD S2, S2, S1
    STORE S2, SB, T3
    BEQ R0, R0, L_text40_puts_attr_32
; Unconditional branch to L_text40_puts_attr_32
; Invalidated 2 alloca bindings
L_text40_puts_attr_34:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_attr_99999
L_text40_puts_attr_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_set_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
L_text40_set_attr_35:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op6_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S0
    LI T4, 0
    SLT T3, T5, T4
    LI T2, 1
    SUB T5, T2, T3
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op10_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 40
    SLT T1, T1, T0
    AND T5, T5, T1
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op12_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 0
    SLT T4, T3, T2
    LI T0, 1
    SUB T3, T0, T4
    AND T5, T5, T3
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op16_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T7
    LI T4, 25
    SLT T1, T1, T4
    AND T5, T5, T1
    BEQ T5, R0, L_text40_set_attr_38
; Branch to L_text40_set_attr_38 if condition is false
    BEQ R0, R0, L_text40_set_attr_36
; Unconditional branch to L_text40_set_attr_36 (condition was true)
; Invalidated 3 alloca bindings
L_text40_set_attr_36:
    ADD T0, FP, R0
    ADDI T0, T0, 3
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op18_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD T3, SB, T2
    LI T4, 40
    MUL T3, T3, T4
    LI T1, 32
    ADD T1, T1, T3
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op20_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+0
    ADD T5, FP, R0
    LOAD T6, SB, T5
    ADD T1, T1, T6
    STORE T1, SB, T0
    ADD T7, FP, R0
    ADDI T7, T7, 4
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op23_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T0
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T1, SB, SC
; Spill t24 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t25
; Recompute alloca t23 at FP+4
    ADD T4, FP, R0
    ADDI T4, T4, 4
    STORE RV0, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 5
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op26_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+2
    ADD T6, FP, R0
    ADDI T6, T6, 2
    LOAD S3, SB, T6
    LI S2, 255
    AND S3, S3, S2
    LI S1, 8
    SLL S3, S3, S1
; Load instruction: t30 = load FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(23), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op28_t30 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T4
    LI T5, 255
    AND T2, T2, T5
    OR S3, S3, T2
    STORE S3, SB, T3
; Load instruction: t33 = load FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(17), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op31_t33 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t17 at FP+3
    ADD T1, FP, R0
    ADDI T1, T1, 3
    LOAD T7, SB, T1
; Load instruction: t34 = load FatPtr(FatPointer { addr: Temp(26), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(26), bank: Stack })
; LOAD: Pointer load_src_ptr_f34_op33_t34 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T3
; Spill live registers before call
; Spill t25 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE RV0, SB, SC
; Spill t32 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S3, SB, SC
; Spill t33 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T7, SB, SC
; Spill t34 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T0, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_set_attr_38
; Unconditional branch to L_text40_set_attr_38
L_text40_set_attr_38:
; Jump to epilogue
    BEQ R0, R0, L_text40_set_attr_99999
L_text40_set_attr_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_get_char:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 12 slots for locals
    ADDI SP, SP, 12
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_text40_get_char_39:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op4_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S1
    LI T6, 0
    SLT T5, T7, T6
    LI T4, 1
    SUB T7, T4, T5
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op8_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S1
    LI T2, 40
    SLT T3, T3, T2
    AND T7, T7, T3
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op10_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 0
    SLT T5, T1, T0
    LI T4, 1
    SUB T1, T4, T5
    AND T7, T7, T1
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op14_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S0
    LI T2, 25
    SLT T6, T6, T2
    AND T7, T7, T6
    BEQ T7, R0, L_text40_get_char_42
; Branch to L_text40_get_char_42 if condition is false
    BEQ R0, R0, L_text40_get_char_40
; Unconditional branch to L_text40_get_char_40 (condition was true)
; Invalidated 2 alloca bindings
L_text40_get_char_40:
    ADD T3, FP, R0
    ADDI T3, T3, 2
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op16_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    LOAD T4, SB, T5
    LI T0, 40
    MUL T4, T4, T0
    LI T1, 32
    ADD T1, T1, T4
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op18_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T2, FP, R0
    LOAD T6, SB, T2
    ADD T1, T1, T6
    STORE T1, SB, T3
    ADD T7, FP, R0
    ADDI T7, T7, 3
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op21_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T3
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S2, SB, SC
; Spill t20 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t23
; Recompute alloca t21 at FP+3
    ADD S1, FP, R0
    ADDI S1, S1, 3
    STORE RV0, SB, S1
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; LOAD: Pointer load_src_ptr_f36_op24_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S1
    LI T4, 255
    AND T0, T0, T4
    MOVE RV0, T0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_char_99999
    BEQ R0, R0, L_text40_get_char_42
; Unconditional branch to L_text40_get_char_42
; Invalidated 1 alloca bindings
L_text40_get_char_42:
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_char_99999
L_text40_get_char_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_get_attr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 12 slots for locals
    ADDI SP, SP, 12
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_text40_get_attr_43:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op4_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, S1
    LI T6, 0
    SLT T5, T7, T6
    LI T4, 1
    SUB T7, T4, T5
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op8_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S1
    LI T2, 40
    SLT T3, T3, T2
    AND T7, T7, T3
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op10_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, S0
    LI T0, 0
    SLT T5, T1, T0
    LI T4, 1
    SUB T1, T4, T5
    AND T7, T7, T1
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op14_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S0
    LI T2, 25
    SLT T6, T6, T2
    AND T7, T7, T6
    BEQ T7, R0, L_text40_get_attr_46
; Branch to L_text40_get_attr_46 if condition is false
    BEQ R0, R0, L_text40_get_attr_44
; Unconditional branch to L_text40_get_attr_44 (condition was true)
; Invalidated 2 alloca bindings
L_text40_get_attr_44:
    ADD T3, FP, R0
    ADDI T3, T3, 2
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op16_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    LOAD T4, SB, T5
    LI T0, 40
    MUL T4, T4, T0
    LI T1, 32
    ADD T1, T1, T4
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op18_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t2 at FP+0
    ADD T2, FP, R0
    LOAD T6, SB, T2
    ADD T1, T1, T6
    STORE T1, SB, T3
    ADD T7, FP, R0
    ADDI T7, T7, 3
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(15), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op21_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, T3
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S2, SB, SC
; Spill t20 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t23
; Recompute alloca t21 at FP+3
    ADD S1, FP, R0
    ADDI S1, S1, 3
    STORE RV0, SB, S1
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(21), bank: Stack })
; LOAD: Pointer load_src_ptr_f38_op24_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S1
    LI T4, 8
    SRL T0, T0, T4
    LI T6, 255
    AND T0, T0, T6
    MOVE RV0, T0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_attr_99999
    BEQ R0, R0, L_text40_get_attr_46
; Unconditional branch to L_text40_get_attr_46
; Invalidated 1 alloca bindings
L_text40_get_attr_46:
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_text40_get_attr_99999
L_text40_get_attr_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_key_pressed_47:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f40_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, S2
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S1, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t3
    LI S0, 1
    LI T7, 0
    SLL S0, S0, T7
    AND RV0, RV0, S0
    LI T6, 0
    XOR T5, RV0, T6
    LI T4, 0
    SLTU RV0, T4, T5
; Jump to epilogue
    BEQ R0, R0, L_key_pressed_99999
L_key_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_up_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_key_up_pressed_48:
    LI S3, 10
; Spill live registers before call
; Spill const_f42_op0_10 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function key_pressed
    CALL key_pressed
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_key_up_pressed_99999
L_key_up_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_down_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_key_down_pressed_49:
    LI S3, 11
; Spill live registers before call
; Spill const_f44_op0_11 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function key_pressed
    CALL key_pressed
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_key_down_pressed_99999
L_key_down_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_left_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_key_left_pressed_50:
    LI S3, 12
; Spill live registers before call
; Spill const_f46_op0_12 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function key_pressed
    CALL key_pressed
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_key_left_pressed_99999
L_key_left_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_right_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_key_right_pressed_51:
    LI S3, 13
; Spill live registers before call
; Spill const_f48_op0_13 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function key_pressed
    CALL key_pressed
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_key_right_pressed_99999
L_key_right_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_z_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_key_z_pressed_52:
    LI S3, 14
; Spill live registers before call
; Spill const_f50_op0_14 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function key_pressed
    CALL key_pressed
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_key_z_pressed_99999
L_key_z_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
key_x_pressed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_key_x_pressed_53:
    LI S3, 15
; Spill live registers before call
; Spill const_f52_op0_15 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function key_pressed
    CALL key_pressed
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_key_x_pressed_99999
L_key_x_pressed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rgb565_from_rgb:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
L_rgb565_from_rgb_54:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 3
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f54_op6_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, S0
    LI T3, 3
    SRL T4, T4, T3
    LI T2, 31
    AND T4, T4, T2
    STORE T4, SB, T5
    ADD T1, FP, R0
    ADDI T1, T1, 4
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f54_op9_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T7
    LI T3, 2
    SRL T0, T0, T3
    LI T2, 63
    AND T0, T0, T2
    STORE T0, SB, T1
    ADD T3, FP, R0
    ADDI T3, T3, 5
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f54_op12_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T6
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
    LI S3, 3
    SRL T2, T2, S3
    LI S3, 31
    AND T2, T2, S3
    STORE T2, SB, T3
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f54_op15_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S3, SB, T5
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
    LI S2, 11
    SLL S3, S3, S2
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f54_op17_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S2, SB, T1
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
    LI S1, 5
    SLL S2, S2, S1
    OR S3, S3, S2
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(14), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(14), bank: Stack })
; LOAD: Pointer load_src_ptr_f54_op19_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S1, SB, T3
    OR S3, S3, S1
    MOVE RV0, S3
; Jump to epilogue
    BEQ R0, R0, L_rgb565_from_rgb_99999
L_rgb565_from_rgb_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rgb565_set_pixel:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 3 from A3
    ADD S0, A3, R0
L_rgb565_set_pixel_55:
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 1
    STORE S2, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S1, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 3
    STORE S0, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 4
; Load instruction: t9 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op8_t9 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, T4
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op10_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T4
    MUL T2, T2, T1
    STORE T2, SB, T3
    ADD T0, FP, R0
    ADDI T0, T0, 5
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op13_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T3
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
    LI S3, 32
    ADD S3, S3, T1
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op15_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T6
; Load instruction: t16 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op17_t16 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, T4
    MUL T1, T1, T7
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op19_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+0
    ADD T7, FP, R0
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
    LOAD S2, SB, T7
    ADD T1, T1, S2
    ADD S3, S3, T1
    STORE S3, SB, T0
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op22_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S2, SB, T0
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f56_op24_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T1, SB, T5
; Spill live registers before call
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S0, SB, SC
; Spill t11 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T2, SB, SC
; Spill t20 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S3, SB, SC
; Spill t21 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S2, SB, SC
; Spill t22 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Arg 1 (scalar) to A1
    ADD A1, T1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_rgb565_set_pixel_99999
L_rgb565_set_pixel_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rgb565_fill_rect:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 3 from A3
    ADD S0, A3, R0
; Load param 4 from FP-7
    ADDI SC, FP, -7
    LOAD T7, SB, SC
; Load param 5 from FP-8
    ADDI SC, FP, -8
    LOAD T6, SB, SC
L_rgb565_fill_rect_56:
    ADD T5, FP, R0
    STORE S3, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 1
    STORE S2, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 2
    STORE S1, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 3
    STORE S0, SB, T2
    ADD T1, FP, R0
    ADDI T1, T1, 4
    STORE T7, SB, T1
    ADD T0, FP, R0
    ADDI T0, T0, 5
    STORE T6, SB, T0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S3, SB, SC
    ADD S3, FP, R0
    ADDI S3, S3, 6
    LI T5, 0
    STORE T5, SB, S3
    BEQ R0, R0, L_rgb565_fill_rect_57
; Unconditional branch to L_rgb565_fill_rect_57
; Invalidated 6 alloca bindings
L_rgb565_fill_rect_57:
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op14_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+6
    ADD T5, FP, R0
    ADDI T5, T5, 6
    LOAD T0, SB, T5
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op16_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t9 at FP+3
    ADD T1, FP, R0
    ADDI T1, T1, 3
    LOAD T2, SB, T1
    SLT T0, T0, T2
    BEQ T0, R0, L_rgb565_fill_rect_60
; Branch to L_rgb565_fill_rect_60 if condition is false
    BEQ R0, R0, L_rgb565_fill_rect_58
; Unconditional branch to L_rgb565_fill_rect_58 (condition was true)
; Invalidated 2 alloca bindings
L_rgb565_fill_rect_58:
    ADD T3, FP, R0
    ADDI T3, T3, 7
    LI T4, 0
    STORE T4, SB, T3
    BEQ R0, R0, L_rgb565_fill_rect_61
; Unconditional branch to L_rgb565_fill_rect_61
; Invalidated 1 alloca bindings
L_rgb565_fill_rect_61:
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op20_t17 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t16 at FP+7
    ADD S3, FP, R0
    ADDI S3, S3, 7
    LOAD T2, SB, S3
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(8), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op22_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t8 at FP+2
    ADD T0, FP, R0
    ADDI T0, T0, 2
    LOAD T1, SB, T0
    SLT T2, T2, T1
    BEQ T2, R0, L_rgb565_fill_rect_64
; Branch to L_rgb565_fill_rect_64 if condition is false
    BEQ R0, R0, L_rgb565_fill_rect_62
; Unconditional branch to L_rgb565_fill_rect_62 (condition was true)
; Invalidated 2 alloca bindings
L_rgb565_fill_rect_62:
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(6), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op24_t20 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t6 at FP+0
    ADD T5, FP, R0
    LOAD T4, SB, T5
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op26_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t16 at FP+7
    ADD T3, FP, R0
    ADDI T3, T3, 7
    LOAD T1, SB, T3
    ADD T4, T4, T1
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op28_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD T0, SB, T2
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op30_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+6
    ADD S3, FP, R0
    ADDI S3, S3, 6
    LOAD T1, SB, S3
    ADD T0, T0, T1
; Load instruction: t26 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op32_t26 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+4
    ADD T1, FP, R0
    ADDI T1, T1, 4
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
    LOAD S2, SB, T1
; Load instruction: t27 = load FatPtr(FatPointer { addr: Temp(11), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(11), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op34_t27 has bank info: Stack
; LOAD: Using bank register Sb for load
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S1, SB, SC
; Recompute alloca t11 at FP+5
    ADD S1, FP, R0
    ADDI S1, S1, 5
; Spill t3 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
    LOAD S0, SB, S1
; Spill live registers before call
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T7, SB, SC
; Spill t5 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T6, SB, SC
; Spill t22 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T4, SB, SC
; Spill t25 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T0, SB, SC
; Spill t26 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE S2, SB, SC
; Spill t27 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE S0, SB, SC
; Setting up 4 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T4, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Arg 2 (scalar) to A2
    ADD A2, S2, R0
; Arg 3 (scalar) to A3
    ADD A3, S0, R0
; Call function rgb565_set_pixel
    CALL rgb565_set_pixel
    BEQ R0, R0, L_rgb565_fill_rect_63
; Unconditional branch to L_rgb565_fill_rect_63
L_rgb565_fill_rect_63:
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op36_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t16 at FP+7
    ADD T7, FP, R0
    ADDI T7, T7, 7
    LOAD T6, SB, T7
    LI T5, 0
    ADD T6, T6, T5
; Load instruction: t30 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op38_t30 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, T7
    LI T2, 1
    ADD T3, T3, T2
    STORE T3, SB, T7
    BEQ R0, R0, L_rgb565_fill_rect_61
; Unconditional branch to L_rgb565_fill_rect_61
; Invalidated 1 alloca bindings
L_rgb565_fill_rect_64:
    BEQ R0, R0, L_rgb565_fill_rect_59
; Unconditional branch to L_rgb565_fill_rect_59
L_rgb565_fill_rect_59:
; Load instruction: t32 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op41_t32 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t12 at FP+6
    ADD S3, FP, R0
    ADDI S3, S3, 6
    LOAD T1, SB, S3
    LI S1, 0
    ADD T1, T1, S1
; Load instruction: t34 = load FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(12), bank: Stack })
; LOAD: Pointer load_src_ptr_f58_op43_t34 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, S3
    LI T0, 1
    ADD T4, T4, T0
    STORE T4, SB, S3
    BEQ R0, R0, L_rgb565_fill_rect_57
; Unconditional branch to L_rgb565_fill_rect_57
; Invalidated 1 alloca bindings
L_rgb565_fill_rect_60:
; Jump to epilogue
    BEQ R0, R0, L_rgb565_fill_rect_99999
L_rgb565_fill_rect_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
