; Generated by Ripple C99 Compiler (rcc)

mmio_read:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
    ADD S2, FP, R0
    STORE S3, SB, S2
    ADD S1, FP, R0
    ADDI S1, S1, 1
    LOAD S0, SB, S2
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t4 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S0, SB, SC
; Setup: Load inputs
; Reload t4 from slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    LOAD T6, SB, SC
; Inline assembly code
    LOAD T7, R0, T6
; Teardown: Bind outputs
; Output t3 now in T7
; === End inline assembly ===
; Recompute alloca t2 at FP+1
    ADD T5, FP, R0
    ADDI T5, T5, 1
    STORE T7, SB, T5
    LOAD T4, SB, T5
    MOVE RV0, T4
; Jump to epilogue
    BEQ R0, R0, L_mmio_read_99999
L_mmio_read_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
mmio_write:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_mmio_write_1:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
    LOAD T7, SB, S0
    LOAD T6, SB, S1
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S2, SB, SC
; Spill t4 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE T7, SB, SC
; Spill t5 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T6, SB, SC
; Setup: Load inputs
; Reload t4 from slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 12
    LOAD T5, SB, SC
; Reload t5 from slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 13
    LOAD T4, SB, SC
; Inline assembly code
    STORE T5, R0, T4
; Teardown: Bind outputs
; === End inline assembly ===
; Jump to epilogue
    BEQ R0, R0, L_mmio_write_99999
L_mmio_write_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
tty_putchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_tty_putchar_2:
    ADD S2, FP, R0
    STORE S3, SB, S2
    LOAD S1, SB, S2
    LI S0, 0
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f4_op2_0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_tty_putchar_99999
L_tty_putchar_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_get:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_rng_get_3:
    LI S3, 4
; Spill live registers before call
; Spill const_f6_op0_4 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_rng_get_99999
L_rng_get_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_get_seed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_rng_get_seed_4:
    LI S3, 5
; Spill live registers before call
; Spill const_f8_op0_5 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t0
; Jump to epilogue
    BEQ R0, R0, L_rng_get_seed_99999
L_rng_get_seed_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
rng_set_seed:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_rng_set_seed_5:
    ADD S2, FP, R0
    STORE S3, SB, S2
    LOAD S1, SB, S2
    LI S0, 5
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f10_op2_5 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_rng_set_seed_99999
L_rng_set_seed_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_set_mode:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_display_set_mode_6:
    ADD S2, FP, R0
    STORE S3, SB, S2
    LOAD S1, SB, S2
    LI S0, 6
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Spill const_f12_op2_6 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE S0, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Arg 1 (scalar) to A1
    ADD A1, S1, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_set_mode_99999
L_display_set_mode_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_enable:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_enable_7:
    LI S3, 1
    LI S2, 0
    SLL S3, S3, S2
    LI S1, 8
; Spill live registers before call
; Spill const_f14_op0_8 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S1, SB, SC
; Spill t0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Arg 1 (scalar) to A1
    ADD A1, S3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_enable_99999
L_display_enable_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_clear:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_clear_8:
    LI S3, 1
    LI S2, 0
    SLL S3, S3, S2
    LI S1, 1
    LI S1, 1
    SLL S0, S1, S1
    OR S3, S3, S0
    LI T7, 8
; Spill live registers before call
; Spill const_f16_op0_8 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE T7, SB, SC
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Arg 1 (scalar) to A1
    ADD A1, S3, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_clear_99999
L_display_clear_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
display_flush:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_display_flush_9:
    LI S3, 9
    LI S2, 1
; Spill live registers before call
; Spill const_f18_op0_9 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 8
    STORE S3, SB, SC
; Spill const_f18_op1_1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S2, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Arg 1 (scalar) to A1
    ADD A1, S2, R0
; Call function mmio_write
    CALL mmio_write
; Jump to epilogue
    BEQ R0, R0, L_display_flush_99999
L_display_flush_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_putchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 13 slots for locals
    ADDI SP, SP, 13
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
L_text40_putchar_10:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
    LOAD T5, SB, S0
    LI T4, 0
    SLT T3, T5, T4
    LI T2, 1
    SUB T5, T2, T3
    LOAD T1, SB, S0
    LI T0, 40
    SLT T1, T1, T0
    AND T5, T5, T1
    LOAD T3, SB, T7
    LI T2, 0
    SLT T4, T3, T2
    LI T0, 1
    SUB T3, T0, T4
    AND T5, T5, T3
    LOAD T1, SB, T7
    LI T4, 25
    SLT T1, T1, T4
    AND T5, T5, T1
    BEQ T5, R0, L_text40_putchar_13
; Branch to L_text40_putchar_13 if condition is false
    BEQ R0, R0, L_text40_putchar_11
; Unconditional branch to L_text40_putchar_11 (condition was true)
L_text40_putchar_11:
    ADD T0, FP, R0
    ADDI T0, T0, 3
; Recompute alloca t4 at FP+1
    ADD T2, FP, R0
    ADDI T2, T2, 1
    LOAD T3, SB, T2
    LI T4, 40
    MUL T3, T3, T4
    LI T1, 32
    ADD T1, T1, T3
; Recompute alloca t3 at FP+0
    ADD T5, FP, R0
    LOAD T6, SB, T5
    ADD T1, T1, T6
    STORE T1, SB, T0
    ADD T7, FP, R0
    ADDI T7, T7, 4
; Recompute alloca t5 at FP+2
    ADD S0, FP, R0
    ADDI S0, S0, 2
    LOAD T4, SB, S0
    LI T3, 255
    AND T4, T4, T3
    STORE T4, SB, T7
    LOAD T6, SB, T0
    LOAD T3, SB, T7
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S2, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S1, SB, SC
; Spill t22 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T1, SB, SC
; Spill t25 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T4, SB, SC
; Spill t26 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T6, SB, SC
; Spill t27 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T3, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T6, R0
; Arg 1 (scalar) to A1
    ADD A1, T3, R0
; Call function mmio_write
    CALL mmio_write
    BEQ R0, R0, L_text40_putchar_13
; Unconditional branch to L_text40_putchar_13
L_text40_putchar_13:
; Jump to epilogue
    BEQ R0, R0, L_text40_putchar_99999
L_text40_putchar_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
text40_puts:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 15 slots for locals
    ADDI SP, SP, 15
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
; Load param 2 from A2
    ADD S1, A2, R0
; Load param 2 bank from A3
L_text40_puts_14:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 1
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S1, SB, T6
    ADDI T5, T6, 1
    STORE A3, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 4
    LOAD T3, SB, S0
    STORE T3, SB, T4
    ADD T2, FP, R0
    ADDI T2, T2, 5
    LI T1, 0
    STORE T1, SB, T2
    ADD T0, FP, R0
    ADDI T0, T0, 6
    BEQ R0, R0, L_text40_puts_15
; Unconditional branch to L_text40_puts_15
L_text40_puts_15:
; Recompute alloca t5 at FP+2
    ADD T5, FP, R0
    ADDI T5, T5, 2
    LOAD T1, SB, T5
    ADDI T0, T5, 1
    LOAD T2, SB, T0
; Recompute alloca t8 at FP+5
    ADD T4, FP, R0
    ADDI T4, T4, 5
    LOAD T6, SB, T4
    ADD S0, T6, R0
    ADD T7, T1, S0
; Runtime bank overflow calculation for dynamic GEP
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S3, SB, SC
    LI S3, 4096
    DIV T0, T7, S3
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S2, SB, SC
    MOD S2, T7, S3
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S1, SB, SC
    ADD S1, T2, T0
    ADD T7, S2, R0
    LOAD S0, S1, T7
; Recompute alloca t9 at FP+6
    ADD T0, FP, R0
    ADDI T0, T0, 6
    STORE S0, SB, T0
    LI S3, 0
    XOR S2, S0, S3
    LI T1, 0
    SLTU S0, T1, S2
; Recompute alloca t6 at FP+4
    ADD S2, FP, R0
    ADDI S2, S2, 4
    LOAD T1, SB, S2
    LI S3, 40
    SLT T1, T1, S3
    AND S0, S0, T1
    BEQ S0, R0, L_text40_puts_17
; Branch to L_text40_puts_17 if condition is false
    BEQ R0, R0, L_text40_puts_16
; Unconditional branch to L_text40_puts_16 (condition was true)
L_text40_puts_16:
; Recompute alloca t6 at FP+4
    ADD S3, FP, R0
    ADDI S3, S3, 4
    LOAD T1, SB, S3
; Recompute alloca t4 at FP+1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    LOAD T0, SB, S0
; Recompute alloca t9 at FP+6
    ADD T4, FP, R0
    ADDI T4, T4, 6
    LOAD T5, SB, T4
    LI S2, 255
    AND T5, T5, S2
; Spill live registers before call
; Spill t7 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T3, SB, SC
; Spill t11 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T6, SB, SC
; Spill load_f22_op9_t10_bank_val to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T2, SB, SC
; Spill gep_new_bank_f22_op15_t12 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE S1, SB, SC
; Spill t12 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T7, SB, SC
; Spill t18 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T1, SB, SC
; Spill t19 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T0, SB, SC
; Spill t21 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T5, SB, SC
; Setting up 3 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Arg 1 (scalar) to A1
    ADD A1, T0, R0
; Arg 2 (scalar) to A2
    ADD A2, T5, R0
; Call function text40_putchar
    CALL text40_putchar
; Recompute alloca t6 at FP+4
    ADD S2, FP, R0
    ADDI S2, S2, 4
    LOAD T3, SB, S2
    LI T6, 1
    ADD T3, T3, T6
    STORE T3, SB, S2
; Recompute alloca t8 at FP+5
    ADD T2, FP, R0
    ADDI T2, T2, 5
    LOAD S1, SB, T2
    LI T7, 1
    ADD S1, S1, T7
    STORE S1, SB, T2
    BEQ R0, R0, L_text40_puts_15
; Unconditional branch to L_text40_puts_15
L_text40_puts_17:
; Jump to epilogue
    BEQ R0, R0, L_text40_puts_99999
L_text40_puts_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
