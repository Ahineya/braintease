; Generated by Ripple C99 Compiler (rcc)

; Global 'current_heap_bank' at address 0
; Global 'current_heap_offset' at address 1
; Global 'heap_initialized' at address 2
init_heap:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 8 slots for locals
    ADDI SP, SP, 8
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load instruction: t0 = load Global("heap_initialized")
; Canonicalizing global variable: heap_initialized
    LI S3, 2
; LOAD: Pointer load_src_ptr_f0_op1_t0 has bank info: Global
; LOAD: Using bank register Gp for load
    LOAD S2, GP, S3
    LI S1, 0
    XOR S0, S2, S1
    LI T7, 1
    SLTU S2, S0, T7
    BEQ S2, R0, L_init_heap_3
; Branch to L_init_heap_3 if condition is false
    BEQ R0, R0, L_init_heap_1
; Unconditional branch to L_init_heap_1 (condition was true)
L_init_heap_1:
    LI T6, 5
    LI T5, 0
    STORE T6, GP, T5
    LI T4, 0
    LI T3, 1
    STORE T4, GP, T3
    LI T2, 1
    LI T1, 2
    STORE T2, GP, T1
    BEQ R0, R0, L_init_heap_3
; Unconditional branch to L_init_heap_3
L_init_heap_3:
; Jump to epilogue
    BEQ R0, R0, L_init_heap_99999
L_init_heap_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
make_fat_ptr:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 12 slots for locals
    ADDI SP, SP, 12
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_make_fat_ptr_4:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op4_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S1
; Load instruction: t7 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op6_t7 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S0
; === Begin inline assembly ===
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S2, SB, SC
; Spill t6 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T6, SB, SC
; Spill t7 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE T5, SB, SC
; Setup: Load inputs
; Reload t6 from slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    LOAD T3, SB, SC
; Reload t7 from slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    LOAD T2, SB, SC
; Inline assembly code
    move rv0, T3
    move rv1, T2
; Teardown: Bind outputs
; Output t5 now in T4
; === End inline assembly ===
; Recompute alloca t4 at FP+2
    ADD T1, FP, R0
    ADDI T1, T1, 2
    STORE T4, SB, T1
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f2_op9_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T1
    ADDI S3, T1, 1
    LOAD S2, SB, S3
; Bank value in S2 - tags: -1 = Global, -2 = Stack, positive = dynamic
    LI S1, -1
    BEQ S2, S1, L_bc_3631c3d4_use_global
    LI T6, -2
    BEQ S2, T6, L_bc_3631c3d4_use_stack
    ADD T7, S2, R0
    BEQ R0, R0, L_bc_3631c3d4_done
L_bc_3631c3d4_use_global:
    ADD T7, GP, R0
    BEQ R0, R0, L_bc_3631c3d4_done
L_bc_3631c3d4_use_stack:
    ADD T7, SB, R0
L_bc_3631c3d4_done:
    MOVE RV0, T0
    MOVE RV1, T7
; Jump to epilogue
    BEQ R0, R0, L_make_fat_ptr_99999
L_make_fat_ptr_99999:
; Return fat pointer
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
malloc:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 11 slots for locals
    ADDI SP, SP, 11
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
L_malloc_5:
    ADD S2, FP, R0
    STORE S3, SB, S2
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S3, SB, SC
; Call function init_heap
    CALL init_heap
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD S1, FP, R0
    LOAD S0, SB, S1
    LI T7, 0
    SLT T6, T7, S0
    LI T5, 1
    SUB S0, T5, T6
    BEQ S0, R0, L_malloc_8
; Branch to L_malloc_8 if condition is false
    BEQ R0, R0, L_malloc_6
; Unconditional branch to L_malloc_6 (condition was true)
; Invalidated 1 alloca bindings
L_malloc_6:
    LI RV0, 0
    LI T4, 0
    MOVE RV1, T4
; Jump to epilogue
    BEQ R0, R0, L_malloc_99999
    BEQ R0, R0, L_malloc_8
; Unconditional branch to L_malloc_8
L_malloc_8:
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op7_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD T3, FP, R0
    LOAD T2, SB, T3
    LI T1, 32767
    SLT T2, T1, T2
    BEQ T2, R0, L_malloc_11
; Branch to L_malloc_11 if condition is false
    BEQ R0, R0, L_malloc_9
; Unconditional branch to L_malloc_9 (condition was true)
; Invalidated 1 alloca bindings
L_malloc_9:
    LI RV0, 0
    LI T0, 0
    MOVE RV1, T0
; Jump to epilogue
    BEQ R0, R0, L_malloc_99999
    BEQ R0, R0, L_malloc_11
; Unconditional branch to L_malloc_11
L_malloc_11:
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op10_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t1 at FP+0
    ADD S3, FP, R0
    LOAD S2, SB, S3
; Load instruction: t7 = load Global("current_heap_offset")
; Canonicalizing global variable: current_heap_offset
    LI T6, 1
; LOAD: Pointer load_src_ptr_f4_op13_t7 has bank info: Global
; LOAD: Using bank register Gp for load
    LOAD T5, GP, T6
    LI T7, 32767
    SUB T7, T7, T5
    SLT S2, T7, S2
    BEQ S2, R0, L_malloc_14
; Branch to L_malloc_14 if condition is false
    BEQ R0, R0, L_malloc_12
; Unconditional branch to L_malloc_12 (condition was true)
; Invalidated 1 alloca bindings
L_malloc_12:
; Load instruction: t10 = load FatPtr(FatPointer { addr: Global("current_heap_bank"), bank: Global })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Global("current_heap_bank"), bank: Global })
    LI S0, 0
; LOAD: Pointer load_src_ptr_f4_op16_t10 has bank info: Global
; LOAD: Using bank register Gp for load
    LOAD S1, GP, S0
    LI T1, 0
    ADD S1, S1, T1
; Load instruction: t12 = load FatPtr(FatPointer { addr: Global("current_heap_bank"), bank: Global })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Global("current_heap_bank"), bank: Global })
    LI T2, 0
; LOAD: Pointer load_src_ptr_f4_op19_t12 has bank info: Global
; LOAD: Using bank register Gp for load
    LOAD T3, GP, T2
    LI T5, 1
    ADD T3, T3, T5
    LI T7, 0
    STORE T3, GP, T7
    LI S2, 0
    LI S3, 1
    STORE S2, GP, S3
; Load instruction: t14 = load Global("current_heap_bank")
; Canonicalizing global variable: current_heap_bank
    LI T1, 0
; LOAD: Pointer load_src_ptr_f4_op27_t14 has bank info: Global
; LOAD: Using bank register Gp for load
    LOAD T5, GP, T1
    LI T7, 255
    SLT T5, T7, T5
    BEQ T5, R0, L_malloc_17
; Branch to L_malloc_17 if condition is false
    BEQ R0, R0, L_malloc_15
; Unconditional branch to L_malloc_15 (condition was true)
L_malloc_15:
    LI RV0, 0
    LI S2, 0
    MOVE RV1, S2
; Jump to epilogue
    BEQ R0, R0, L_malloc_99999
    BEQ R0, R0, L_malloc_17
; Unconditional branch to L_malloc_17
L_malloc_17:
    BEQ R0, R0, L_malloc_14
; Unconditional branch to L_malloc_14
L_malloc_14:
    ADD S3, FP, R0
    ADDI S3, S3, 1
; Load instruction: t17 = load Global("current_heap_offset")
; Canonicalizing global variable: current_heap_offset
    LI T7, 1
; LOAD: Pointer load_src_ptr_f4_op31_t17 has bank info: Global
; LOAD: Using bank register Gp for load
    LOAD T5, GP, T7
    STORE T5, SB, S3
; Spill return_null_bank_4_f4_op6 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE T4, SB, SC
    ADD T4, FP, R0
    ADDI T4, T4, 2
; Load instruction: t19 = load Global("current_heap_bank")
; Canonicalizing global variable: current_heap_bank
    LI T0, 0
; LOAD: Pointer load_src_ptr_f4_op35_t19 has bank info: Global
; LOAD: Using bank register Gp for load
; Spill return_null_bank_4_f4_op9 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T0, SB, SC
; Spill load_f4_op12_t7_addr to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T6, SB, SC
    LOAD T6, GP, T0
    STORE T6, SB, T4
; Load instruction: t20 = load FatPtr(FatPointer { addr: Global("current_heap_offset"), bank: Global })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Global("current_heap_offset"), bank: Global })
    LI S0, 1
; LOAD: Pointer load_src_ptr_f4_op39_t20 has bank info: Global
; LOAD: Using bank register Gp for load
; Spill load_f4_op15_t10_addr to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S0, SB, SC
; Spill t11 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
    LOAD S1, GP, S0
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op41_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Spill load_f4_op18_t12_addr to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T2, SB, SC
; Recompute alloca t1 at FP+0
    ADD T2, FP, R0
; Spill t13 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T3, SB, SC
    LOAD T3, SB, T2
    ADD S1, S1, T3
    LI T3, 1
    STORE S1, GP, T3
; Load instruction: t23 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op45_t23 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T3, SB, S3
; Load instruction: t24 = load FatPtr(FatPointer { addr: Temp(18), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(18), bank: Stack })
; LOAD: Pointer load_src_ptr_f4_op47_t24 has bank info: Stack
; LOAD: Using bank register Sb for load
; Spill load_f4_op26_t14_addr to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T1, SB, SC
    LOAD T1, SB, T4
; Spill live registers before call
; Spill return_null_bank_4_f4_op29 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S2, SB, SC
; Spill load_f4_op30_t17_addr to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T7, SB, SC
; Spill t17 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T5, SB, SC
; Spill load_f4_op34_t19_addr to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T0, SB, SC
; Spill t19 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T6, SB, SC
; Spill load_f4_op38_t20_addr to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE S0, SB, SC
; Spill t22 to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE S1, SB, SC
; Spill t23 to slot 16
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T3, SB, SC
; Spill t24 to slot 17
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T1, SB, SC
; Setting up 2 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T3, R0
; Arg 1 (scalar) to A1
    ADD A1, T1, R0
; Call function make_fat_ptr
    CALL make_fat_ptr
; Fat pointer return value for t25
; Jump to epilogue
    BEQ R0, R0, L_malloc_99999
L_malloc_99999:
; Return fat pointer
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
free:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 10 slots for locals
    ADDI SP, SP, 10
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
L_free_18:
    ADD S2, FP, R0
    STORE S3, SB, S2
    ADDI S1, S2, 1
    STORE A1, SB, S1
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(1), bank: Stack })
; LOAD: Pointer load_src_ptr_f6_op5_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S0, SB, S2
    ADDI T7, S2, 1
    LOAD T6, SB, T7
; Bank value in T6 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Jump to epilogue
    BEQ R0, R0, L_free_99999
L_free_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
calloc:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 1 from A1
    ADD S2, A1, R0
L_calloc_19:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADD S0, FP, R0
    ADDI S0, S0, 1
    STORE S2, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
; Load instruction: t5 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op4_t5 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S1
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op6_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S0
    MUL T6, T6, T5
    STORE T6, SB, T7
; Load instruction: t8 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op9_t8 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T4, SB, S1
    LI T3, 0
    XOR T2, T4, T3
    LI T1, 0
    SLTU T4, T1, T2
; Load instruction: t10 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op13_t10 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, T7
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op15_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T5, SB, S1
    DIV T0, T0, T5
; Load instruction: t13 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op17_t13 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T2, SB, S0
    XOR T1, T0, T2
    LI T3, 0
    SLTU T0, T3, T1
    AND T4, T4, T0
    BEQ T4, R0, L_calloc_22
; Branch to L_calloc_22 if condition is false
    BEQ R0, R0, L_calloc_20
; Unconditional branch to L_calloc_20 (condition was true)
; Invalidated 3 alloca bindings
L_calloc_20:
    LI RV0, 0
    LI T5, 0
    MOVE RV1, T5
; Jump to epilogue
    BEQ R0, R0, L_calloc_99999
    BEQ R0, R0, L_calloc_22
; Unconditional branch to L_calloc_22
L_calloc_22:
    ADD T1, FP, R0
    ADDI T1, T1, 3
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op22_t17 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+2
    ADD T3, FP, R0
    ADDI T3, T3, 2
    LOAD T2, SB, T3
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
; Spill t7 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T6, SB, SC
; Spill return_null_bank_8_f8_op21 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T5, SB, SC
; Spill t17 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Call function malloc
    CALL malloc
; Fat pointer return value for t18
; Recompute alloca t16 at FP+3
    ADD T0, FP, R0
    ADDI T0, T0, 3
    STORE RV0, SB, T0
    ADDI T4, T0, 1
    STORE RV1, SB, T4
; Load instruction: t19 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op26_t19 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T7, SB, T0
    ADDI S0, T0, 1
    LOAD S1, SB, S0
; Bank value in S1 - tags: -1 = Global, -2 = Stack, positive = dynamic
    LI S3, 0
    XOR S2, T7, S3
    LI T6, 0
    SLTU T7, T6, S2
    BEQ T7, R0, L_calloc_25
; Branch to L_calloc_25 if condition is false
    BEQ R0, R0, L_calloc_23
; Unconditional branch to L_calloc_23 (condition was true)
; Invalidated 1 alloca bindings
L_calloc_23:
    ADD T5, FP, R0
    ADDI T5, T5, 5
; Load instruction: t22 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op32_t22 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t16 at FP+3
    ADD T1, FP, R0
    ADDI T1, T1, 3
    LOAD T3, SB, T1
    ADDI T2, T1, 1
    LOAD T4, SB, T2
; Bank value in T4 - tags: -1 = Global, -2 = Stack, positive = dynamic
    LI S0, 16
    SRL T3, T3, S0
    STORE T3, SB, T5
    ADD S2, FP, R0
    ADDI S2, S2, 6
; Load instruction: t25 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op37_t25 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, T1
    ADDI S3, T1, 1
    LOAD T7, SB, S3
; Bank value in T7 - tags: -1 = Global, -2 = Stack, positive = dynamic
    LI T0, -1
    AND T6, T6, T0
    STORE T6, SB, S2
    ADD T2, FP, R0
    ADDI T2, T2, 7
    LI S0, 0
    STORE S0, SB, T2
    BEQ R0, R0, L_calloc_26
; Unconditional branch to L_calloc_26
; Invalidated 4 alloca bindings
L_calloc_26:
; Load instruction: t28 = load FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op44_t28 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t27 at FP+7
    ADD S3, FP, R0
    ADDI S3, S3, 7
    LOAD T0, SB, S3
; Load instruction: t29 = load FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(4), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op46_t29 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t4 at FP+2
    ADD S0, FP, R0
    ADDI S0, S0, 2
    LOAD T1, SB, S0
    SLT T0, T0, T1
    BEQ T0, R0, L_calloc_29
; Branch to L_calloc_29 if condition is false
    BEQ R0, R0, L_calloc_27
; Unconditional branch to L_calloc_27 (condition was true)
; Invalidated 2 alloca bindings
L_calloc_27:
; Load instruction: t31 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op48_t31 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t16 at FP+3
    ADD T2, FP, R0
    ADDI T2, T2, 3
    LOAD T5, SB, T2
    ADDI S2, T2, 1
    LOAD T1, SB, S2
; Bank value in T1 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t32 = load FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op52_t32 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t27 at FP+7
    ADD T0, FP, R0
    ADDI T0, T0, 7
    LOAD S0, SB, T0
    ADD S2, S0, R0
    ADD S3, T5, S2
; Runtime bank overflow calculation for dynamic GEP
; Spill t18 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE RV0, SB, SC
; Spill load_f8_op29_t19_bank_val to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE S1, SB, SC
    LI S1, -1536
    DIV RV0, S3, S1
; Spill load_f8_op35_t22_bank_val to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T4, SB, SC
    MOD T4, S3, S1
; Base bank info: Dynamic("load_f8_op51_t31_bank_val")
; Clearing binding for 'gep_new_bank_f8_op58_t33'
; Spill t23 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T3, SB, SC
; Computing new bank gep_new_bank_f8_op58_t33 = load_f8_op51_t31_bank_val + bank_delta
    ADD T3, T1, RV0
; Result bank tracked as Dynamic(gep_new_bank_f8_op58_t33)
    ADD S3, T4, R0
; GEP: Setting bank info for t33 to Dynamic("gep_new_bank_f8_op58_t33")
    LI S2, 0
    LI S1, -1
    BEQ T3, S1, L_bc_d49b3d55_use_global
    LI T4, -2
    BEQ T3, T4, L_bc_d49b3d55_use_stack
    ADD RV0, T3, R0
    BEQ R0, R0, L_bc_d49b3d55_done
L_bc_d49b3d55_use_global:
    ADD RV0, GP, R0
    BEQ R0, R0, L_bc_d49b3d55_done
L_bc_d49b3d55_use_stack:
    ADD RV0, SB, R0
L_bc_d49b3d55_done:
    STORE S2, RV0, S3
    BEQ R0, R0, L_calloc_28
; Unconditional branch to L_calloc_28
; Invalidated 2 alloca bindings
L_calloc_28:
; Load instruction: t34 = load FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op64_t34 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t27 at FP+7
    ADD S1, FP, R0
    ADDI S1, S1, 7
    LOAD T4, SB, S1
    LI S2, 0
    ADD T4, T4, S2
; Load instruction: t36 = load FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(27), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op66_t36 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T0, SB, S1
    LI T2, 1
    ADD T0, T0, T2
    STORE T0, SB, S1
    BEQ R0, R0, L_calloc_26
; Unconditional branch to L_calloc_26
; Invalidated 1 alloca bindings
L_calloc_29:
    BEQ R0, R0, L_calloc_25
; Unconditional branch to L_calloc_25
L_calloc_25:
; Load instruction: t38 = load FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(16), bank: Stack })
; LOAD: Pointer load_src_ptr_f8_op69_t38 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t16 at FP+3
    ADD S2, FP, R0
    ADDI S2, S2, 3
    LOAD T2, SB, S2
    ADDI S1, S2, 1
; Spill load_f8_op40_t25_bank_val to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T7, SB, SC
    LOAD T7, SB, S1
; Bank value in T7 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Spill t26 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T6, SB, SC
    LI T6, -1
    BEQ T7, T6, L_bc_9599dfb2_use_global
; Spill t31 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T5, SB, SC
; Spill load_f8_op51_t31_bank_val to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T1, SB, SC
    LI T5, -2
    BEQ T7, T5, L_bc_9599dfb2_use_stack
    ADD S1, T7, R0
    BEQ R0, R0, L_bc_9599dfb2_done
L_bc_9599dfb2_use_global:
    ADD S1, GP, R0
    BEQ R0, R0, L_bc_9599dfb2_done
L_bc_9599dfb2_use_stack:
    ADD S1, SB, R0
L_bc_9599dfb2_done:
    MOVE RV0, T2
    MOVE RV1, S1
; Jump to epilogue
    BEQ R0, R0, L_calloc_99999
L_calloc_99999:
; Return fat pointer
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
realloc:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 11 slots for locals
    ADDI SP, SP, 11
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
L_realloc_30:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADDI S0, S1, 1
    STORE A1, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
    STORE S2, SB, T7
; Load instruction: t4 = load FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(2), bank: Stack })
; LOAD: Pointer load_src_ptr_f10_op7_t4 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD T6, SB, S1
    ADDI T5, S1, 1
    LOAD T4, SB, T5
; Bank value in T4 - tags: -1 = Global, -2 = Stack, positive = dynamic
    LI T3, 0
    XOR T2, T6, T3
    LI T1, 1
    SLTU T6, T2, T1
    BEQ T6, R0, L_realloc_33
; Branch to L_realloc_33 if condition is false
    BEQ R0, R0, L_realloc_31
; Unconditional branch to L_realloc_31 (condition was true)
; Invalidated 2 alloca bindings
L_realloc_31:
; Load instruction: t6 = load FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(3), bank: Stack })
; LOAD: Pointer load_src_ptr_f10_op13_t6 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t3 at FP+2
    ADD T0, FP, R0
    ADDI T0, T0, 2
    LOAD S0, SB, T0
; Spill live registers before call
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE S3, SB, SC
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S2, SB, SC
; Spill load_f10_op10_t4_bank_val to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE T4, SB, SC
; Spill t6 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S0, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S0, R0
; Call function malloc
    CALL malloc
; Fat pointer return value for t7
; Jump to epilogue
    BEQ R0, R0, L_realloc_99999
    BEQ R0, R0, L_realloc_33
; Unconditional branch to L_realloc_33
L_realloc_33:
    LI RV0, 0
    LI T5, 0
    MOVE RV1, T5
; Jump to epilogue
    BEQ R0, R0, L_realloc_99999
L_realloc_99999:
; Return fat pointer
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
