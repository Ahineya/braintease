; Generated by Ripple C99 Compiler (rcc)

; Function: test
test:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 23
; === Processing instruction #0: Alloca { result: 1, alloc_type: Ptr(I8), count: None, result_type: Ptr(Ptr(I8)) } ===
; === ModuleLowerer::get_reg for 't1' ===
; get_reg for 't1'
;   Allocated free register for t1
; Alloca for t1 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #1: Store { value: Temp(0), ptr: Temp(1) } ===
; === ModuleLowerer::get_reg for 'addr_t1_0' ===
; get_reg for 'addr_t1_0'
;   Allocated free register for addr_t1_0
    ADDI R6, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_2' ===
; get_reg for 'stack_bank_2'
;   Allocated free register for stack_bank_2
    LI R7, 1
; Store t0 to [t1]
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains ptr_preserve2_3
;   R7 contains bank_preserve_4
; t0 found in R3
;   t0 is now in R3
    STORE R3, R7, R6
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #2: Alloca { result: 2, alloc_type: I8, count: None, result_type: Ptr(I8) } ===
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
; Alloca for t2 at FP+3 (fat ptr: stack bank)
    ADDI R5, R15, 3
; === Processing instruction #3: Load { result: 3, ptr: Temp(1), result_type: I8 } ===
; Load from [t1] to t3
; === ModuleLowerer::get_reg for 'addr_t1_5' ===
; get_reg for 'addr_t1_5'
;   Allocated free register for addr_t1_5
    ADDI R6, R15, 1
; Pinning addr_t1_5 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_6' ===
; get_reg for 'stack_bank_6'
;   Allocated free register for stack_bank_6
    LI R7, 1
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   Allocated free register for t3
    LOAD R8, R7, R6
; === Processing instruction #4: Store { value: Temp(3), ptr: Temp(2) } ===
; === ModuleLowerer::get_reg for 'addr_t2_7' ===
; get_reg for 'addr_t2_7'
;   Allocated free register for addr_t2_7
    ADDI R9, R15, 3
; === ModuleLowerer::get_reg for 'stack_bank_9' ===
; get_reg for 'stack_bank_9'
;   Allocated free register for stack_bank_9
    LI R10, 1
; Store t3 to [t2]
; Getting register for temp t3
; Looking for t3 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t2
;   R6 contains addr_t1_5
;   R7 contains stack_bank_6
;   R8 contains t3
;   R? contains ptr_preserve2_10
;   R? contains bank_preserve_11
; t3 found in R8
;   t3 is now in R8
    STORE R8, R10, R9
; >>> Preserving registers: storing t3 from previous instruction
; === Processing instruction #5: Load { result: 4, ptr: Temp(2), result_type: I8 } ===
; Load from [t2] to t4
; === ModuleLowerer::get_reg for 'addr_t2_12' ===
; get_reg for 'addr_t2_12'
;   Allocated free register for addr_t2_12
    ADDI R11, R15, 3
; Pinning addr_t2_12 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_13' ===
; get_reg for 'stack_bank_13'
;   No free registers, need to spill for stack_bank_13
;     R3 contains 't0'
;     R4 contains 't100000'
;     R5 contains 't2'
;     R6 contains 'addr_t1_5'
;     R7 contains 'stack_bank_6'
;     R8 contains 't3'
;     R9 contains 'ptr_preserve2_10'
;     R10 contains 'bank_preserve_11'
;     R11 contains 'addr_t2_12'
;   Chose to spill t0 from R3
; Spilling t0 to FP+4
    ADDI R12, R15, 4
    STORE R3, R13, R12
;   Now R3 will contain stack_bank_13
    LI R3, 1
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   No free registers, need to spill for t4
;     R3 contains 'stack_bank_13'
;     R4 contains 't100000'
;     R5 contains 't2'
;     R6 contains 'addr_t1_5'
;     R7 contains 'stack_bank_6'
;     R8 contains 't3'
;     R9 contains 'ptr_preserve2_10'
;     R10 contains 'bank_preserve_11'
;     R11 contains 'addr_t2_12'
;   Chose to spill t100000 from R4
; Spilling t100000 to FP+5
    ADDI R12, R15, 5
    STORE R4, R13, R12
;   Now R4 will contain t4
    LOAD R4, R3, R11
; === Processing instruction #6: Call { result: None, function: Global("putchar"), args: [Temp(4)], result_type: Void } ===
; Getting register for temp t4
; Looking for t4 in registers
;   R3 contains stack_bank_13
;   R4 contains t4
;   R5 contains t2
;   R6 contains addr_t1_5
;   R7 contains stack_bank_6
;   R8 contains t3
;   R? contains ptr_preserve2_10
;   R? contains bank_preserve_11
;   R? contains addr_t2_12
; t4 found in R4
;   t4 is now in R4
    ADD R3, R4, R0
    CALL putchar
; === Processing instruction #7: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
