; Generated by Ripple C99 Compiler (rcc)

; Function: memcpy
memcpy:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
; === Processing instruction #0: Alloca { result: 5, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   Allocated free register for t5
; Alloca for t5 at FP+1 (fat ptr: stack bank)
    ADDI R9, R15, 1
; === Processing instruction #1: Store { value: Constant(0), ptr: Temp(5) } ===
; === ModuleLowerer::get_reg for 'addr_t5_0' ===
; get_reg for 'addr_t5_0'
;   Allocated free register for addr_t5_0
    ADDI R10, R15, 1
; Store 0 to [t5]
; === ModuleLowerer::get_reg for 'const_0_4' ===
; get_reg for 'const_0_4'
;   Allocated free register for const_0_4
    LI R11, 0
    STORE R11, R13, R10
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #2: Branch(1) ===
    BEQ R0, R0, memcpy_L1
memcpy_L1:
; === Processing instruction #0: Load { result: 6, ptr: Temp(5), result_type: I16 } ===
; Load from [t5] to t6
; === ModuleLowerer::get_reg for 'addr_t5_5' ===
; get_reg for 'addr_t5_5'
;   Allocated free register for addr_t5_5
    ADDI R9, R15, 1
; Pinning addr_t5_5 in register to prevent spilling
; === ModuleLowerer::get_reg for 't6' ===
; get_reg for 't6'
;   Allocated free register for t6
    LOAD R10, R13, R9
; === Processing instruction #1: Binary { result: 7, op: Slt, lhs: Temp(6), rhs: Temp(4), result_type: I16 } ===
; === Processing Binary t7 ===
; Binary: need(lhs)=1, need(rhs)=1
; Getting register for temp t6
; Looking for t6 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100002
;   R8 contains t3
;   R? contains addr_t5_5
;   R? contains t6
; t6 found in R?
;   t6 is now in R10
; Getting register for temp t4
; Looking for t4 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100002
;   R8 contains t3
;   R? contains addr_t5_5
;   R? contains t6
; t4 not found, allocating new register
; get_reg for 't4'
;   Allocated free register for t4
;   t4 is now in R11
; Reusing R10 for result t7
    SLTU R10, R10, R11
; Freeing right operand register R11
; === Processing instruction #2: BranchCond { condition: Temp(7), true_label: 2, false_label: 4 } ===
; Getting register for temp t7
; Looking for t7 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100002
;   R8 contains t3
;   R? contains addr_t5_5
;   R? contains t7
; t7 found in R?
;   t7 is now in R10
    BNE R10, R0, memcpy_L2
    BEQ R0, R0, memcpy_L4
memcpy_L2:
; === Processing instruction #0: Load { result: 8, ptr: Temp(5), result_type: I16 } ===
; Load from [t5] to t8
; === ModuleLowerer::get_reg for 'addr_t5_6' ===
; get_reg for 'addr_t5_6'
;   Allocated free register for addr_t5_6
    ADDI R9, R15, 1
; Pinning addr_t5_6 in register to prevent spilling
; === ModuleLowerer::get_reg for 't8' ===
; get_reg for 't8'
;   Allocated free register for t8
    LOAD R10, R13, R9
; === Processing instruction #1: GetElementPtr { result: 9, ptr: Temp(2), indices: [Temp(8)], result_type: Ptr(I8) } ===
; GetElementPtr t9 = t2 + offsets
; Getting register for temp t2
; Looking for t2 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100002
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
; t2 found in R6
;   t2 is now in R6
;   Base t2 in R6
; Getting register for temp t8
; Looking for t8 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100002
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
; t8 found in R?
;   t8 is now in R10
; === ModuleLowerer::get_reg for 't9' ===
; get_reg for 't9'
;   Allocated free register for t9
    ADD R11, R6, R10
;   Propagating bank tag from t100002 to t100009
; === Processing instruction #2: Load { result: 10, ptr: Temp(9), result_type: I8 } ===
; Load from [t9] to t10
; Getting register for temp t9
; Looking for t9 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; t9 found in R?
;   t9 is now in R11
; Pinning t9 in register to prevent spilling
; Getting bank tag for t9
; Looking for t100009 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; t100009 found in R7
; === ModuleLowerer::get_reg for 'bank_select_7' ===
; get_reg for 'bank_select_7'
;   No free registers, need to spill for bank_select_7
;     R3 contains 't0'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill t0 from R3
; Spilling t0 to FP+2
    ADDI R12, R15, 2
    STORE R3, R13, R12
;   Now R3 will contain bank_select_7
; Select bank register based on tag
    LI R3, 1
    BEQ R7, R3, memcpy_bank_stack_8
    ADD R3, R0, R0
    BEQ R0, R0, memcpy_bank_done_9
memcpy_bank_stack_8:
    ADD R3, R13, R0
memcpy_bank_done_9:
; === ModuleLowerer::get_reg for 't10' ===
; get_reg for 't10'
;   No free registers, need to spill for t10
;     R3 contains 'bank_for_t9'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill bank_for_t9 from R3
; Spilling bank_for_t9 to FP+3
    ADDI R12, R15, 3
    STORE R3, R13, R12
;   Now R3 will contain t10
    LOAD R3, R3, R11
; === Processing instruction #3: Load { result: 11, ptr: Temp(5), result_type: I16 } ===
; Load from [t5] to t11
; === ModuleLowerer::get_reg for 'addr_t5_10' ===
; get_reg for 'addr_t5_10'
;   No free registers, need to spill for addr_t5_10
;     R3 contains 't10'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill t10 from R3
; Spilling t10 to FP+4
    ADDI R12, R15, 4
    STORE R3, R13, R12
;   Now R3 will contain addr_t5_10
    ADDI R3, R15, 1
; Pinning addr_t5_10 in register to prevent spilling
; === ModuleLowerer::get_reg for 't11' ===
; get_reg for 't11'
;   No free registers, need to spill for t11
;     R3 contains 'addr_t5_10'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill t100000 from R4
; Spilling t100000 to FP+5
    ADDI R12, R15, 5
    STORE R4, R13, R12
;   Now R4 will contain t11
    LOAD R4, R13, R3
; === Processing instruction #4: GetElementPtr { result: 12, ptr: Temp(0), indices: [Temp(11)], result_type: Ptr(I8) } ===
; GetElementPtr t12 = t0 + offsets
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains addr_t5_10
;   R4 contains t11
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; get_reg for 't0'
;   No free registers, need to spill for t0
;     R3 contains 'addr_t5_10'
;     R4 contains 't11'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill addr_t5_10 from R3
; Spilling addr_t5_10 to FP+6
    ADDI R12, R15, 6
    STORE R3, R13, R12
;   Now R3 will contain t0
; Reloading t0 from FP+2
    ADDI R12, R15, 2
    LOAD R3, R13, R12
;   t0 is now in R3
;   Base t0 in R3
; Getting register for temp t11
; Looking for t11 in registers
;   R3 contains t0
;   R4 contains t11
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; t11 found in R4
;   t11 is now in R4
; === ModuleLowerer::get_reg for 't12' ===
; get_reg for 't12'
;   No free registers, need to spill for t12
;     R3 contains 't0'
;     R4 contains 't11'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill t0 from R3
; Spilling t0 to FP+2
    ADDI R12, R15, 2
    STORE R3, R13, R12
;   Now R3 will contain t12
    ADD R3, R3, R4
;   Propagating bank tag from t100000 to t100012
; === Processing instruction #5: Store { value: Temp(10), ptr: Temp(12) } ===
; Getting register for temp t12
; Looking for t12 in registers
;   R3 contains t12
;   R4 contains t100012
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; t12 found in R3
;   t12 is now in R3
; Getting bank tag for t12
; Looking for t100012 in registers
;   R3 contains ptr_preserve_11
;   R4 contains t100012
;   R5 contains t1
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; t100012 found in R4
; === ModuleLowerer::get_reg for 'bank_select_12' ===
; get_reg for 'bank_select_12'
;   No free registers, need to spill for bank_select_12
;     R3 contains 'ptr_preserve_11'
;     R4 contains 't100012'
;     R5 contains 't1'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill t1 from R5
; Spilling t1 to FP+7
    ADDI R12, R15, 7
    STORE R5, R13, R12
;   Now R5 will contain bank_select_12
; Select bank register based on tag
    LI R5, 1
    BEQ R4, R5, memcpy_bank_stack_13
    ADD R5, R0, R0
    BEQ R0, R0, memcpy_bank_done_14
memcpy_bank_stack_13:
    ADD R5, R13, R0
memcpy_bank_done_14:
; Store t10 to [t12]
; Getting register for temp t10
; Looking for t10 in registers
;   R3 contains ptr_preserve2_15
;   R4 contains t100012
;   R5 contains bank_preserve_16
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_6
;   R? contains t8
;   R? contains t9
; get_reg for 't10'
;   No free registers, need to spill for t10
;     R3 contains 'ptr_preserve2_15'
;     R4 contains 't100012'
;     R5 contains 'bank_preserve_16'
;     R6 contains 't2'
;     R7 contains 't100009'
;     R8 contains 't3'
;     R9 contains 'addr_t5_6'
;     R10 contains 't8'
;     R11 contains 't9'
;   Chose to spill t100012 from R4
; Spilling t100012 to FP+8
    ADDI R12, R15, 8
    STORE R4, R13, R12
;   Now R4 will contain t10
; Reloading t10 from FP+4
    ADDI R12, R15, 4
    LOAD R4, R13, R12
;   t10 is now in R4
    STORE R4, R5, R3
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #6: Branch(3) ===
    BEQ R0, R0, memcpy_L3
memcpy_L3:
; === Processing instruction #0: Load { result: 13, ptr: Temp(5), result_type: I16 } ===
; Load from [t5] to t13
; === ModuleLowerer::get_reg for 'addr_t5_17' ===
; get_reg for 'addr_t5_17'
;   Allocated free register for addr_t5_17
    ADDI R9, R15, 1
; Pinning addr_t5_17 in register to prevent spilling
; === ModuleLowerer::get_reg for 't13' ===
; get_reg for 't13'
;   Allocated free register for t13
    LOAD R10, R13, R9
; === Processing instruction #1: Binary { result: 14, op: Add, lhs: Temp(13), rhs: Constant(1), result_type: I16 } ===
; === Processing Binary t14 ===
; Binary: need(lhs)=1, need(rhs)=1
; Getting register for temp t13
; Looking for t13 in registers
;   R3 contains ptr_preserve2_15
;   R4 contains t10
;   R5 contains bank_preserve_16
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_17
;   R? contains t13
; t13 found in R?
;   t13 is now in R10
; === ModuleLowerer::get_reg for 'const_1_18' ===
; get_reg for 'const_1_18'
;   Allocated free register for const_1_18
    LI R11, 1
; Reusing R10 for result t14
    ADD R10, R10, R11
; Freeing right operand register R11
; === Processing instruction #2: Store { value: Temp(14), ptr: Temp(5) } ===
; === ModuleLowerer::get_reg for 'addr_t5_19' ===
; get_reg for 'addr_t5_19'
;   Allocated free register for addr_t5_19
    ADDI R11, R15, 1
; Store t14 to [t5]
; Getting register for temp t14
; Looking for t14 in registers
;   R3 contains ptr_preserve2_15
;   R4 contains t10
;   R5 contains bank_preserve_16
;   R6 contains t2
;   R7 contains t100009
;   R8 contains t3
;   R? contains addr_t5_17
;   R? contains t14
;   R? contains ptr_preserve2_21
; t14 found in R?
;   t14 is now in R10
    STORE R10, R13, R11
; >>> Preserving registers: storing t14 from previous instruction
; === Processing instruction #3: Branch(1) ===
    BEQ R0, R0, memcpy_L1
memcpy_L4:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
