; Generated by Ripple C99 Compiler (rcc)

memcpy:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 16 slots for locals
    ADDI SP, SP, 16
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
; Load param 2 from FP-7
    ADDI SC, FP, -7
    LOAD S1, SB, SC
; Load param 2 bank from FP-8
    ADDI SC, FP, -8
    LOAD S0, SB, SC
; Load param 3 from FP-9
    ADDI SC, FP, -9
    LOAD T7, SB, SC
; Load param 4 from FP-10
    ADDI SC, FP, -10
    LOAD T6, SB, SC
    ADD T5, FP, R0
    STORE S3, SB, T5
    ADDI T4, T5, 1
    STORE A1, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 2
    STORE S2, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 3
    STORE S1, SB, T2
    ADDI T1, T2, 1
    STORE S0, SB, T1
    ADD T0, FP, R0
    ADDI T0, T0, 5
    STORE T7, SB, T0
    ADD T4, FP, R0
    ADDI T4, T4, 6
    STORE T6, SB, T4
    ADD T1, FP, R0
    ADDI T1, T1, 7
; Spill param_bank_f0_op4_2 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S0, SB, SC
    LI S0, 0
    STORE S0, SB, T1
    BEQ R0, R0, L_memcpy_1
; Unconditional branch to L_memcpy_1
; Invalidated 6 alloca bindings
L_memcpy_1:
; Load instruction: t11 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op19_t11 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+7
    ADD S0, FP, R0
    ADDI S0, S0, 7
    LOAD T0, SB, S0
; Load instruction: t12 = load FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(9), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op21_t12 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t9 at FP+6
    ADD T1, FP, R0
    ADDI T1, T1, 6
    LOAD T2, SB, T1
    SLT T0, T0, T2
    BEQ T0, R0, L_memcpy_4
; Branch to L_memcpy_4 if condition is false
    BEQ R0, R0, L_memcpy_2
; Unconditional branch to L_memcpy_2 (condition was true)
; Invalidated 2 alloca bindings
L_memcpy_2:
; Load instruction: t14 = load FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(5), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op23_t14 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t5 at FP+0
    ADD T3, FP, R0
    LOAD T4, SB, T3
    ADDI T5, T3, 1
    LOAD T2, SB, T5
; Bank value in T2 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t15 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op27_t15 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+7
    ADD T0, FP, R0
    ADDI T0, T0, 7
    LOAD T1, SB, T0
    ADD T5, T1, R0
    ADD S0, T4, T5
; Runtime bank overflow calculation for dynamic GEP
; Spill t0 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S3, SB, SC
; Spill t1 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S2, SB, SC
    LI S2, 4096
    DIV S3, S0, S2
; Spill t2 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S1, SB, SC
    MOD S1, S0, S2
; Base bank info: Dynamic("load_f0_op26_t14_bank_val")
; Clearing binding for 'gep_new_bank_f0_op33_t16'
; Spill t3 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T7, SB, SC
; Computing new bank gep_new_bank_f0_op33_t16 = load_f0_op26_t14_bank_val + bank_delta
    ADD T7, T2, S3
; Result bank tracked as Dynamic(gep_new_bank_f0_op33_t16)
    ADD S0, S1, R0
; GEP: Setting bank info for t16 to Dynamic("gep_new_bank_f0_op33_t16")
; Load instruction: t17 = load FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(7), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op34_t17 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t7 at FP+3
    ADD T5, FP, R0
    ADDI T5, T5, 3
    LOAD S3, SB, T5
    ADDI S2, T5, 1
    LOAD S1, SB, S2
; Bank value in S1 - tags: -1 = Global, -2 = Stack, positive = dynamic
; Load instruction: t18 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op38_t18 has bank info: Stack
; LOAD: Using bank register Sb for load
    LOAD S2, SB, T0
; Spill t4 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T6, SB, SC
    ADD T3, S2, R0
    ADD T6, S3, T3
; Runtime bank overflow calculation for dynamic GEP
; Spill t14 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T4, SB, SC
; Spill t15 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T1, SB, SC
    LI T1, 4096
    DIV T4, T6, T1
; Spill load_f0_op26_t14_bank_val to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T2, SB, SC
    MOD T2, T6, T1
; Base bank info: Dynamic("load_f0_op37_t17_bank_val")
; Clearing binding for 'gep_new_bank_f0_op44_t19'
; Spill gep_new_bank_f0_op33_t16 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T7, SB, SC
; Computing new bank gep_new_bank_f0_op44_t19 = load_f0_op37_t17_bank_val + bank_delta
    ADD T7, S1, T4
; Result bank tracked as Dynamic(gep_new_bank_f0_op44_t19)
    ADD T6, T2, R0
; GEP: Setting bank info for t19 to Dynamic("gep_new_bank_f0_op44_t19")
; Load instruction: t20 = load FatPtr(FatPointer { addr: Temp(19), bank: Mixed })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(19), bank: Mixed })
; LOAD: Pointer t19 has bank info: Dynamic("gep_new_bank_f0_op44_t19")
    LI T4, -1
    BEQ T7, T4, L_bc_fda678a2_use_global
    LI T1, -2
    BEQ T7, T1, L_bc_fda678a2_use_stack
    ADD T3, T7, R0
    BEQ R0, R0, L_bc_fda678a2_done
L_bc_fda678a2_use_global:
    ADD T3, GP, R0
    BEQ R0, R0, L_bc_fda678a2_done
L_bc_fda678a2_use_stack:
    ADD T3, SB, R0
L_bc_fda678a2_done:
; LOAD: Using bank register T3 for load
    LOAD T2, T3, T6
; Reload gep_new_bank_f0_op33_t16 from slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    LOAD T4, SB, SC
    LI T5, -1
    BEQ T4, T5, L_bc_d8aece25_use_global
    LI T0, -2
    BEQ T4, T0, L_bc_d8aece25_use_stack
    ADD T1, T4, R0
    BEQ R0, R0, L_bc_d8aece25_done
L_bc_d8aece25_use_global:
    ADD T1, GP, R0
    BEQ R0, R0, L_bc_d8aece25_done
L_bc_d8aece25_use_stack:
    ADD T1, SB, R0
L_bc_d8aece25_done:
    STORE T2, T1, S0
    BEQ R0, R0, L_memcpy_3
; Unconditional branch to L_memcpy_3
; Invalidating GEP bank gep_new_bank_f0_op33_t16 in T4
; Invalidating GEP bank gep_new_bank_f0_op44_t19 in T7
; Invalidated 2 GEP bank bindings
L_memcpy_3:
; Load instruction: t21 = load FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(10), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op53_t21 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t10 at FP+7
    ADD T5, FP, R0
    ADDI T5, T5, 7
    LOAD T0, SB, T5
    LI T4, 1
    ADD T0, T0, T4
    STORE T0, SB, T5
    BEQ R0, R0, L_memcpy_1
; Unconditional branch to L_memcpy_1
; Invalidated 1 alloca bindings
L_memcpy_4:
; Jump to epilogue
    BEQ R0, R0, L_memcpy_99999
L_memcpy_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
