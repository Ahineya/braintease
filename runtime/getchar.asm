; Generated by Ripple C99 Compiler (rcc)

getchar:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 9 slots for locals
    ADDI SP, SP, 9
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
    ADD S3, FP, R0
    LI S2, 3
; Spill live registers before call
; Spill const_f0_op0_3 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 9
    STORE S2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t1
; Recompute alloca t0 at FP+0
    ADD S1, FP, R0
    STORE RV0, SB, S1
    BEQ R0, R0, L_getchar_1
; Unconditional branch to L_getchar_1
; Invalidated 1 alloca bindings
L_getchar_1:
; Load instruction: t2 = load FatPtr(FatPointer { addr: Temp(0), bank: Stack })
; Canonicalizing fat pointer: FatPtr(FatPointer { addr: Temp(0), bank: Stack })
; LOAD: Pointer load_src_ptr_f0_op2_t2 has bank info: Stack
; LOAD: Using bank register Sb for load
; Recompute alloca t0 at FP+0
    ADD S0, FP, R0
    LOAD T7, SB, S0
    LI T6, 1
    LI T5, 0
    SLL T6, T6, T5
    AND T7, T7, T6
    LI T4, 0
    XOR T3, T7, T4
    LI T2, 1
    SLTU T7, T3, T2
    BEQ T7, R0, L_getchar_3
; Branch to L_getchar_3 if condition is false
    BEQ R0, R0, L_getchar_2
; Unconditional branch to L_getchar_2 (condition was true)
; Invalidated 1 alloca bindings
L_getchar_2:
    LI T1, 3
; Spill live registers before call
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 10
    STORE RV0, SB, SC
; Spill const_f0_op6_3 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 11
    STORE T1, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t6
; Recompute alloca t0 at FP+0
    ADD T0, FP, R0
    STORE RV0, SB, T0
    BEQ R0, R0, L_getchar_1
; Unconditional branch to L_getchar_1
; Invalidated 1 alloca bindings
L_getchar_3:
    LI S3, 2
; Spill live registers before call
; Spill t6 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE RV0, SB, SC
; Spill const_f0_op8_2 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function mmio_read
    CALL mmio_read
; Scalar return value for t7
; Jump to epilogue
    BEQ R0, R0, L_getchar_99999
L_getchar_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
