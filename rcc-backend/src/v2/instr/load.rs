//! Load instruction lowering for V2 backend
//! 
//! Handles loading values from memory with proper bank management.
//! Supports both scalar loads and fat pointer loads (2-component).

use rcc_frontend::ir::{Value, IrType as Type};
use rcc_common::TempId;
use crate::v2::regmgmt::{RegisterPressureManager, BankInfo};
use crate::v2::naming::NameGenerator;
use rcc_codegen::{AsmInst, Reg};
use log::{debug, trace, warn};
use rcc_frontend::BankTag;
use super::helpers::{resolve_mixed_bank, resolve_bank_tag_to_info, get_bank_register_with_mgr};

/// Lower a Load instruction to assembly
/// 
/// # Parameters
/// - `mgr`: Register pressure manager for allocation and spilling
/// - `naming`: Name generator for unique temporary names
/// - `ptr_value`: Pointer value to load from (must contain bank info)
/// - `result_type`: Type of the value being loaded
/// - `result_temp`: Temp ID for the result
/// 
/// # Returns
/// Vector of assembly instructions for the load operation
pub fn lower_load(
    mgr: &mut RegisterPressureManager,
    naming: &mut NameGenerator,
    ptr_value: &Value,
    result_type: &Type,
    result_temp: TempId,
) -> Vec<AsmInst> {
    debug!("lower_load: ptr={:?}, type={:?}, result=t{}", ptr_value, result_type, result_temp);
    
    let mut insts = vec![];
    let result_name = naming.temp_name(result_temp);
    
    // Step 1: Get the pointer address register
    let (addr_reg, ptr_name) = match ptr_value {
        Value::Temp(t) => {
            let name = naming.temp_name(*t);
            trace!("  Loading from temp pointer: {}", name);
            let reg = mgr.get_register(name.clone());
            (reg, name)
        }
        Value::FatPtr(fp) => {
            // Fat pointer has explicit address and bank
            trace!("  Loading from fat pointer with bank {:?}", fp.bank);
            let addr_reg = match fp.addr.as_ref() {
                Value::Temp(t) => {
                    let name = naming.temp_name(*t);
                    mgr.get_register(name)
                }
                Value::Constant(c) => {
                    // Load constant address into register
                    let temp_reg_name = naming.load_const_addr(result_temp);
                    let temp_reg = mgr.get_register(temp_reg_name);
                    insts.push(AsmInst::Li(temp_reg, *c as i16));
                    trace!("  Loaded constant address {} into {:?}", c, temp_reg);
                    temp_reg
                }
                _ => {
                    warn!("  Unexpected address type in fat pointer: {:?}", fp.addr);
                    panic!("Invalid fat pointer address type in LOAD: {:?}", fp.addr);
                }
            };

            // Determine how to source the bank for this fat pointer
            let bank_info = resolve_bank_tag_to_info(&fp.bank, fp, mgr, naming);
            
            // Determine the key to use for tracking this pointer's bank
            let ptr_name = if matches!(fp.bank, BankTag::Mixed) {
                // For Mixed, use the temp name if available
                match fp.addr.as_ref() {
                    Value::Temp(t) => naming.temp_name(*t),
                    _ => naming.load_src_ptr_bank(result_temp),
                }
            } else {
                // For Global/Stack, use a unique key
                naming.load_src_ptr_bank(result_temp)
            };
            
            mgr.set_pointer_bank(ptr_name.clone(), bank_info);

            (addr_reg, ptr_name)
        }
        Value::Global(name) => {
            // This should never happen - globals should be resolved to FatPtr in lower.rs
            panic!("Unexpected Value::Global('{}') as load source - should have been resolved to FatPtr in lower.rs", name);
        }
        _ => {
            warn!("  Invalid pointer value for load: {:?}", ptr_value);
            panic!("Invalid pointer value for load")
        }
    };
    
    // Step 2: Get the bank register based on pointer's bank info
    let bank_info = mgr.get_pointer_bank(&ptr_name)
        .unwrap_or_else(|| {
            panic!("LOAD: COMPILER BUG: No bank info for pointer '{}'. All pointers must have tracked bank information!", ptr_name);
        });
    
    debug!("  Pointer {} has bank info: {:?}", ptr_name, bank_info);
    
    // Use the new function that can handle NamedValue and reload if necessary
    let bank_reg = get_bank_register_with_mgr(&bank_info, mgr);
    trace!("  Using {:?} for bank", bank_reg);
    
    // Step 3: Allocate destination register and generate LOAD instruction
    let dest_reg = mgr.get_register(result_name.clone());
    debug!("  Allocated {:?} for result {}", dest_reg, result_name);
    
    // Take any instructions generated by register allocation
    insts.extend(mgr.take_instructions());
    
    // Generate the actual LOAD instruction
    let load_inst = AsmInst::Load(dest_reg, bank_reg, addr_reg);
    trace!("  Generated LOAD: {:?}", load_inst);
    insts.push(load_inst);
    
    // Step 4: If loading a fat pointer, also load the bank component
    if result_type.is_pointer() {
        debug!("  Result is a pointer, loading bank component");
        
        // Calculate address for bank component (addr + 1)
        let bank_addr_name = naming.load_bank_addr(result_temp);
        let bank_addr_reg = mgr.get_register(bank_addr_name);
        insts.extend(mgr.take_instructions());
        
        insts.push(AsmInst::AddI(bank_addr_reg, addr_reg, 1));
        trace!("  Bank component at address {:?} + 1", addr_reg);
        
        // Load the bank value with a trackable name
        let bank_value_name = naming.load_bank_value(result_temp);
        let bank_dest_reg = mgr.get_register(bank_value_name.clone());
        insts.extend(mgr.take_instructions());
        
        let bank_load = AsmInst::Load(bank_dest_reg, bank_reg, bank_addr_reg);
        trace!("  Generated bank LOAD: {:?}", bank_load);
        insts.push(bank_load);
        
        // Store bank info for the loaded pointer
        // IMPORTANT: We track the bank value by NAME so it can be reloaded if spilled
        if result_type.is_pointer() {
            // Bind the bank value so it's tracked in the register manager
            mgr.bind_value_to_register(bank_value_name.clone(), bank_dest_reg);
            // Track that this pointer's bank is in a named value (not just a register)
            // This allows the bank to be reloaded if the register gets spilled
            mgr.set_pointer_bank(result_name.clone(), BankInfo::NamedValue(bank_value_name.clone()));
        }
        debug!("  Fat pointer loaded: addr in {:?}, bank in {:?} (tracked as '{}')", 
               dest_reg, bank_dest_reg, bank_value_name);
        
        // Free the temporary bank address register
        mgr.free_register(bank_addr_reg);
    }
    
    debug!("lower_load complete: generated {} instructions", insts.len());
    insts
}