//! Module to Assembly Lowering
//! 
//! This module implements the lowering from the full IR (Module/Function/Instruction)
//! to Ripple assembly instructions.

use crate::ir::{Module, Function, BasicBlock, Instruction, Value, IrType, IrBinaryOp, IrUnaryOp, GlobalVariable};
use rcc_codegen::{AsmInst, Reg, Frame};
use rcc_common::CompilerError;
use std::collections::HashMap;

/// Module to assembly lowering context
pub struct ModuleLowerer {
    /// Assembly instructions being generated
    instructions: Vec<AsmInst>,
    
    /// Register allocator (simple for now)
    next_reg: u8,
    
    /// Mapping from IR values to registers
    value_regs: HashMap<String, Reg>,
    
    /// Simple memory simulation: maps pointer temps to value temps
    /// This is a hack for M2 - real memory will be implemented in M3
    memory_map: HashMap<String, String>,
    
    /// Current function being lowered
    current_function: Option<String>,
    
    /// Whether current function has a prologue
    has_prologue: bool,
    
    /// Label counter for generating unique labels
    label_counter: u32,
}

impl ModuleLowerer {
    pub fn new() -> Self {
        Self {
            instructions: Vec::new(),
            next_reg: 3, // Start with R3 (R0-R2 reserved)
            value_regs: HashMap::new(),
            memory_map: HashMap::new(),
            current_function: None,
            has_prologue: false,
            label_counter: 0,
        }
    }
    
    /// Lower a module to assembly
    pub fn lower(&mut self, module: Module) -> Result<Vec<AsmInst>, CompilerError> {
        // Generate globals (for now, skip - would need .data section support)
        for global in &module.globals {
            self.lower_global(global)?;
        }
        
        // Generate functions
        for function in &module.functions {
            self.lower_function(function)?;
        }
        
        Ok(self.instructions.clone())
    }
    
    /// Lower a global variable
    fn lower_global(&mut self, global: &GlobalVariable) -> Result<(), CompilerError> {
        // For now, globals are not fully supported
        // They would need section support (.data, .bss, .rodata)
        self.instructions.push(AsmInst::Comment(format!("Global variable: {}", global.name)));
        Ok(())
    }
    
    /// Lower a function to assembly
    fn lower_function(&mut self, function: &Function) -> Result<(), CompilerError> {
        self.current_function = Some(function.name.clone());
        self.value_regs.clear();
        self.memory_map.clear();
        self.has_prologue = false;
        self.next_reg = 3; // Reset register allocation for each function
        
        // Function label
        self.instructions.push(AsmInst::Comment(format!("Function: {}", function.name)));
        self.instructions.push(AsmInst::Label(function.name.clone()));
        
        // Map function parameters to their input registers
        // Parameters arrive in R3-R8
        for (i, (param_id, _param_type)) in function.parameters.iter().enumerate() {
            if i < 6 {
                let param_reg = match i {
                    0 => Reg::R3,
                    1 => Reg::R4,
                    2 => Reg::R5,
                    3 => Reg::R6,
                    4 => Reg::R7,
                    5 => Reg::R8,
                    _ => unreachable!(),
                };
                // Map parameter temp ID to its register
                self.value_regs.insert(format!("t{}", param_id), param_reg);
                // For add function, we now properly use parameters from R3, R4
                self.next_reg = (i + 4) as u8; // Start allocating after parameter registers
            }
        }
        
        // Generate prologue only if function has calls (to save RA)
        // Special case: main doesn't need prologue/epilogue for RA saving
        if self.function_has_calls(function) {
            // For main, we might not need to save RA, but let's keep it simple for now
            let mut frame = Frame::new(0); // TODO: Calculate actual locals size
            frame.set_has_calls(true);
            let prologue = frame.gen_prologue();
            self.instructions.extend(prologue);
            self.has_prologue = true;
        }
        
        // Lower basic blocks
        for block in &function.blocks {
            self.lower_basic_block(block)?;
        }
        
        // Note: Epilogue is generated by return instructions
        
        self.current_function = None;
        Ok(())
    }
    
    /// Check if function has any call instructions (excluding putchar which is inlined)
    fn function_has_calls(&self, function: &Function) -> bool {
        function.blocks.iter().any(|block| {
            block.instructions.iter().any(|inst| {
                match inst {
                    Instruction::Call { function: func, .. } => {
                        // putchar is special-cased as MMIO, not a real call
                        if let Value::Function(name) = func {
                            name != "putchar"
                        } else {
                            true
                        }
                    }
                    _ => false
                }
            })
        })
    }
    
    /// Lower a basic block
    fn lower_basic_block(&mut self, block: &BasicBlock) -> Result<(), CompilerError> {
        // Add label for block if not the first one
        if block.id != 0 {
            self.instructions.push(AsmInst::Label(format!("L{}", block.id)));
        }
        
        for instruction in &block.instructions {
            self.lower_instruction(instruction)?;
        }
        
        Ok(())
    }
    
    /// Lower a single instruction
    fn lower_instruction(&mut self, instruction: &Instruction) -> Result<(), CompilerError> {
        match instruction {
            Instruction::Alloca { result, alloc_type, .. } => {
                // Stack allocation - for now, just track the temporary
                let reg = self.allocate_register();
                self.value_regs.insert(format!("t{}", result), reg);
                self.instructions.push(AsmInst::Comment(format!("Alloca for t{}", result)));
            }
            
            Instruction::Store { value, ptr } => {
                let value_reg = self.get_value_register(value)?;
                // For M2, we'll use a simple memory simulation
                // Track which register holds the value stored at this pointer
                let ptr_key = self.value_to_string(ptr);
                
                // Store the register that holds this value
                // We need to create a unique key for this stored value
                let stored_temp_key = format!("stored_at_{}", ptr_key);
                self.value_regs.insert(stored_temp_key.clone(), value_reg);
                self.memory_map.insert(ptr_key.clone(), stored_temp_key);
                
                self.instructions.push(AsmInst::Comment(format!("Store {} to {}", 
                    self.value_to_string(value), self.value_to_string(ptr))));
                
                // Keep the value in its register for now
                // Real memory implementation will come in M3
            }
            
            Instruction::Load { result, ptr, .. } => {
                let dest_reg = self.allocate_register();
                self.value_regs.insert(format!("t{}", result), dest_reg);
                
                // Check if we have a stored value for this pointer
                let ptr_key = self.value_to_string(ptr);
                if let Some(stored_value_key) = self.memory_map.get(&ptr_key) {
                    // We have a stored value, get its register
                    if let Some(&stored_reg) = self.value_regs.get(stored_value_key) {
                        // Copy the stored value to the destination
                        self.instructions.push(AsmInst::Comment(format!("Load {} from {} to t{}", 
                            stored_value_key, ptr_key, result)));
                        self.instructions.push(AsmInst::Add(dest_reg, stored_reg, Reg::R0));
                    } else {
                        // The stored value might be a constant or temp we haven't seen
                        // Try to parse it as a temp ID to get its register
                        self.instructions.push(AsmInst::Comment(format!("Load from {} to t{}", 
                            ptr_key, result)));
                        // For now, just allocate a zero
                        self.instructions.push(AsmInst::LI(dest_reg, 0));
                    }
                } else {
                    // No stored value found, load zero
                    self.instructions.push(AsmInst::Comment(format!("Load from {} to t{} (uninitialized)", 
                        ptr_key, result)));
                    self.instructions.push(AsmInst::LI(dest_reg, 0));
                }
            }
            
            Instruction::Binary { result, op, lhs, rhs, .. } => {
                let left_reg = self.get_value_register(lhs)?;
                let right_reg = self.get_value_register(rhs)?;
                let dest_reg = self.allocate_register();
                self.value_regs.insert(format!("t{}", result), dest_reg);
                
                match op {
                    IrBinaryOp::Add => {
                        self.instructions.push(AsmInst::Add(dest_reg, left_reg, right_reg));
                    }
                    IrBinaryOp::Sub => {
                        self.instructions.push(AsmInst::Sub(dest_reg, left_reg, right_reg));
                    }
                    IrBinaryOp::Mul => {
                        self.instructions.push(AsmInst::Mul(dest_reg, left_reg, right_reg));
                    }
                    _ => {
                        self.instructions.push(AsmInst::Comment(format!("Unsupported binary op: {:?}", op)));
                    }
                }
            }
            
            Instruction::Call { result, function, args, .. } => {
                // Extract function name from Value
                let func_name = match function {
                    Value::Function(name) => name.clone(),
                    _ => "unknown".to_string(),
                };
                
                // For putchar, directly handle it as a store to MMIO
                if func_name == "putchar" && args.len() == 1 {
                    let arg_reg = self.get_value_register(&args[0])?;
                    self.instructions.push(AsmInst::Store(arg_reg, Reg::R0, Reg::R0));
                } else {
                    // General function call - set up arguments first
                    // Using calling convention: R3-R8 for arguments
                    
                    // Collect argument registers and their destinations
                    let mut arg_regs = Vec::new();
                    for (i, arg) in args.iter().enumerate() {
                        if i < 6 {  // Max 6 register arguments
                            let arg_reg = self.get_value_register(arg)?;
                            let param_reg = match i {
                                0 => Reg::R3,
                                1 => Reg::R4,
                                2 => Reg::R5,
                                3 => Reg::R6,
                                4 => Reg::R7,
                                5 => Reg::R8,
                                _ => unreachable!(),
                            };
                            arg_regs.push((arg_reg, param_reg));
                        }
                    }
                    
                    // Move arguments to parameter registers
                    // Handle potential conflicts by using R9 as temporary
                    let mut moved = vec![false; arg_regs.len()];
                    
                    // First, move any that don't conflict
                    for i in 0..arg_regs.len() {
                        let (src, dst) = arg_regs[i];
                        if src == dst {
                            moved[i] = true;
                        } else {
                            // Check if dst is needed as a source for an unmoved arg
                            let dst_needed = arg_regs.iter().enumerate()
                                .any(|(j, (s, _))| !moved[j] && j != i && *s == dst);
                            
                            if !dst_needed {
                                self.instructions.push(AsmInst::Add(dst, src, Reg::R0));
                                moved[i] = true;
                            }
                        }
                    }
                    
                    // Now handle any remaining moves (these form cycles)
                    // Simple approach: use R9 to save conflicting values
                    for i in 0..arg_regs.len() {
                        if !moved[i] {
                            let (src, dst) = arg_regs[i];
                            
                            // Check if any other unmoved arg needs our dst as src
                            let mut conflict_idx = None;
                            for j in 0..arg_regs.len() {
                                if !moved[j] && j != i {
                                    let (src2, _) = arg_regs[j];
                                    if src2 == dst {
                                        conflict_idx = Some(j);
                                        break;
                                    }
                                }
                            }
                            
                            if let Some(j) = conflict_idx {
                                // Save the conflicting source to R9 first
                                let (_, dst2) = arg_regs[j];
                                self.instructions.push(AsmInst::Add(Reg::R9, dst, Reg::R0));
                                // Now we can move src to dst
                                self.instructions.push(AsmInst::Add(dst, src, Reg::R0));
                                moved[i] = true;
                                // And move R9 to dst2
                                self.instructions.push(AsmInst::Add(dst2, Reg::R9, Reg::R0));
                                moved[j] = true;
                            } else {
                                // No conflict, just move
                                self.instructions.push(AsmInst::Add(dst, src, Reg::R0));
                                moved[i] = true;
                            }
                        }
                    }
                    
                    self.instructions.push(AsmInst::Call(func_name));
                    
                    if let Some(dest) = result {
                        // Result is in R3 by convention
                        let dest_reg = self.allocate_register();
                        if dest_reg != Reg::R3 {
                            self.instructions.push(AsmInst::Add(dest_reg, Reg::R3, Reg::R0));
                        }
                        self.value_regs.insert(format!("t{}", dest), dest_reg);
                    }
                }
            }
            
            Instruction::Return(value) => {
                if let Some(val) = value {
                    let val_reg = self.get_value_register(val)?;
                    // Move return value to return register (R3 by convention)
                    if val_reg != Reg::R3 {
                        self.instructions.push(AsmInst::Add(Reg::R3, val_reg, Reg::R0));
                    }
                }
                
                // Generate epilogue if this function has a prologue
                if self.has_prologue {
                    // Restore RA from stack
                    self.instructions.push(AsmInst::AddI(Reg::R14, Reg::R14, -1));
                    self.instructions.push(AsmInst::Load(Reg::RA, Reg::R13, Reg::R14));
                }
                
                self.instructions.push(AsmInst::Ret);
            }
            
            Instruction::Branch(target) => {
                // For now, use a comment - proper label resolution would be done in a later pass
                self.instructions.push(AsmInst::Comment(format!("Jump to label {}", target)));
                // TODO: Resolve label to actual address
            }
            
            Instruction::BranchCond { condition, true_label, false_label } => {
                // Simplified conditional branch
                self.instructions.push(AsmInst::Comment(format!("Branch if {} to L{} else L{}", 
                    self.value_to_string(condition), true_label, false_label)));
                // TODO: Implement proper condition evaluation
            }
            
            _ => {
                self.instructions.push(AsmInst::Comment(format!("Unimplemented: {:?}", instruction)));
            }
        }
        
        Ok(())
    }
    
    /// Get register for a value
    fn get_value_register(&mut self, value: &Value) -> Result<Reg, CompilerError> {
        match value {
            Value::Constant(n) => {
                // Load constant into a register
                let reg = self.allocate_register();
                self.instructions.push(AsmInst::LI(reg, *n as i16));
                Ok(reg)
            }
            Value::Temp(id) => {
                let key = format!("t{}", id);
                if let Some(reg) = self.value_regs.get(&key) {
                    Ok(*reg)
                } else {
                    // Allocate new register for this temp
                    let reg = self.allocate_register();
                    self.value_regs.insert(key, reg);
                    Ok(reg)
                }
            }
            Value::Function(name) => {
                // Function references not directly loadable
                Err(CompilerError::codegen_error(
                    format!("Cannot load function '{}' into register", name),
                    rcc_common::SourceLocation::new_simple(0, 0),
                ))
            }
            Value::Global(name) => {
                // For now, globals not fully supported
                Err(CompilerError::codegen_error(
                    format!("Global variable '{}' access not yet implemented", name),
                    rcc_common::SourceLocation::new_simple(0, 0),
                ))
            }
            _ => {
                Err(CompilerError::codegen_error(
                    format!("Unsupported value type: {:?}", value),
                    rcc_common::SourceLocation::new_simple(0, 0),
                ))
            }
        }
    }
    
    /// Allocate a new register
    fn allocate_register(&mut self) -> Reg {
        let reg = match self.next_reg {
            3 => Reg::R3,
            4 => Reg::R4,
            5 => Reg::R5,
            6 => Reg::R6,
            7 => Reg::R7,
            8 => Reg::R8,
            _ => {
                // Out of registers, reuse R3 (very simple spilling)
                self.next_reg = 3;
                Reg::R3
            }
        };
        self.next_reg += 1;
        reg
    }
    
    /// Generate a unique label
    fn generate_label(&mut self, prefix: &str) -> String {
        let label = format!("{}_{}", prefix, self.label_counter);
        self.label_counter += 1;
        label
    }
    
    /// Convert a value to string for debug output
    fn value_to_string(&self, value: &Value) -> String {
        match value {
            Value::Constant(n) => format!("{}", n),
            Value::Temp(id) => format!("t{}", id),
            Value::Function(name) => name.clone(),
            Value::Global(name) => format!("@{}", name),
            _ => "?".to_string(),
        }
    }
}

/// Lower a Module to assembly instructions
pub fn lower_module_to_assembly(module: Module) -> Result<Vec<AsmInst>, CompilerError> {
    let mut lowerer = ModuleLowerer::new();
    lowerer.lower(module)
}