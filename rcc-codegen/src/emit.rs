//! Assembly Emission
//! 
//! This module handles the final step of code generation: emitting Ripple assembly
//! instructions as text that can be processed by the rasm assembler.

use crate::asm::AsmInst;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CodegenError {
    #[error("Invalid instruction: {0:?}")]
    InvalidInstruction(AsmInst),
    
    #[error("Label not found: {0}")]
    LabelNotFound(String),
    
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}

/// Emit a sequence of assembly instructions as text
pub fn emit_instructions(instructions: Vec<AsmInst>) -> Result<String, CodegenError> {
    let mut output = String::new();
    
    for instruction in instructions {
        match instruction {
            AsmInst::Label(ref label) => {
                // Labels get their own line with no indentation
                output.push_str(&format!("{}\n", instruction));
            }
            AsmInst::Comment(ref comment) => {
                // Comments get their own line with no indentation
                output.push_str(&format!("{}\n", instruction));
            }
            AsmInst::Raw(ref asm) => {
                // Raw assembly passes through with indentation
                output.push_str(&format!("    {}\n", asm));
            }
            _ => {
                // Regular instructions are indented
                output.push_str(&format!("    {}\n", instruction));
            }
        }
    }
    
    Ok(output)
}

/// Generate a complete assembly file with headers and sections
pub fn emit_complete_program(
    instructions: Vec<AsmInst>,
    has_main: bool,
) -> Result<String, CodegenError> {
    let mut output = String::new();
    
    // Add file header comment
    output.push_str("; Generated by Ripple C99 Compiler (rcc)\n\n");
    
    // Never generate _start - that's the job of crt0
    // The compiler should only generate the functions defined in the source
    
    // Emit the main program
    let program_asm = emit_instructions(instructions)?;
    output.push_str(&program_asm);
    
    Ok(output)
}

/// Utility functions for testing and debugging
pub mod utils {
    use super::*;
    
    /// Check if an instruction sequence contains a specific instruction
    pub fn contains_instruction(instructions: &[AsmInst], target: &AsmInst) -> bool {
        instructions.iter().any(|inst| inst == target)
    }
    
    /// Count occurrences of a specific instruction type
    pub fn count_instruction_type(instructions: &[AsmInst], check: fn(&AsmInst) -> bool) -> usize {
        instructions.iter().filter(|inst| check(inst)).count()
    }
    
    /// Extract all labels from a sequence of instructions
    pub fn extract_labels(instructions: &[AsmInst]) -> Vec<String> {
        instructions
            .iter()
            .filter_map(|inst| match inst {
                AsmInst::Label(label) => Some(label.clone()),
                _ => None,
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::utils::*;
    use crate::asm::{AsmInst, Reg};
    use pretty_assertions::assert_eq;

    #[test]
    fn test_emit_hello_world() {
        let instructions = vec![
            AsmInst::Label("main".to_string()),
            AsmInst::Li(Reg::T0, 'H' as i16),
            AsmInst::Store(Reg::T0, Reg::R0, Reg::R0),
            AsmInst::Li(Reg::T0, 'i' as i16),
            AsmInst::Store(Reg::T0, Reg::R0, Reg::R0),
            AsmInst::Li(Reg::T0, '\n' as i16),
            AsmInst::Store(Reg::T0, Reg::R0, Reg::R0),
            AsmInst::Halt,
        ];

        let result = emit_instructions(instructions).unwrap();
        
        // Verify the output format
        assert!(result.contains("main:\n"));
        assert!(result.contains("    LI T0, 72\n"));  // 'H' = 72
        assert!(result.contains("    LI T0, 105\n")); // 'i' = 105
        assert!(result.contains("    LI T0, 10\n"));  // '\n' = 10
        assert!(result.contains("    STORE T0, R0, R0\n"));
        assert!(result.contains("    HALT\n"));
    }

    #[test]
    fn test_emit_complete_program() {
        let instructions = vec![
            AsmInst::Label("main".to_string()),
            AsmInst::Li(Reg::T0, 42),
            AsmInst::Halt,
        ];

        let result = emit_complete_program(instructions, true).unwrap();

        // assert_eq!(result, "moo".to_string());
        
        // Should include program entry point
        assert!(result.contains("; Generated by Ripple C99 Compiler"));
        assert!(result.contains("main:\n"));
        assert!(result.contains("    LI T0, 42\n"));
        assert!(result.contains("HALT"));
    }

    #[test]
    fn test_comments_and_labels() {
        let instructions = vec![
            AsmInst::Comment("This is a test program".to_string()),
            AsmInst::Label("test_label".to_string()),
            AsmInst::Li(Reg::T0, 1),
            AsmInst::Comment("End of program".to_string()),
        ];

        let result = emit_instructions(instructions).unwrap();
        
        // Comments and labels should not be indented
        assert!(result.contains("; This is a test program\n"));
        assert!(result.contains("test_label:\n"));
        assert!(result.contains("    LI T0, 1\n"));
        assert!(result.contains("; End of program\n"));
    }

    #[test]
    fn test_utility_functions() {
        let instructions = vec![
            AsmInst::Label("main".to_string()),
            AsmInst::Li(Reg::T0, 42),
            AsmInst::Li(Reg::T1, 0),
            AsmInst::Add(Reg::T2, Reg::T0, Reg::T1),
            AsmInst::Label("loop".to_string()),
            AsmInst::Halt,
        ];

        // Test contains_instruction
        assert!(contains_instruction(&instructions, &AsmInst::Li(Reg::T0, 42)));
        assert!(!contains_instruction(&instructions, &AsmInst::Li(Reg::T0, 43)));

        // Test count_instruction_type
        let li_count = count_instruction_type(&instructions, |inst| {
            matches!(inst, AsmInst::Li(_, _))
        });
        assert_eq!(li_count, 2);

        // Test extract_labels
        let labels = extract_labels(&instructions);
        assert_eq!(labels, vec!["main".to_string(), "loop".to_string()]);
    }

    #[test]
    fn test_arithmetic_instructions() {
        let instructions = vec![
            AsmInst::Li(Reg::T0, 10),
            AsmInst::Li(Reg::T1, 20),
            AsmInst::Add(Reg::T2, Reg::T0, Reg::T1),
            AsmInst::Sub(Reg::T3, Reg::T1, Reg::T0),
            AsmInst::AddI(Reg::T4, Reg::T0, 5),
        ];

        let result = emit_instructions(instructions).unwrap();
        
        assert!(result.contains("    ADD T2, T0, T1\n"));
        assert!(result.contains("    SUB T3, T1, T0\n"));
        assert!(result.contains("    ADDI T4, T0, 5\n"));
    }

    #[test]
    fn test_control_flow() {
        let instructions = vec![
            AsmInst::Label("loop".to_string()),
            AsmInst::Beq(Reg::T0, Reg::T1, "end".to_string()),
            AsmInst::Inc(Reg::T0),
            AsmInst::Bne(Reg::T0, Reg::T2, "loop".to_string()),
            AsmInst::Label("end".to_string()),
            AsmInst::Ret,
        ];

        let result = emit_instructions(instructions).unwrap();
        
        assert!(result.contains("loop:\n"));
        assert!(result.contains("    BEQ T0, T1, end\n"));
        assert!(result.contains("    BNE T0, T2, loop\n"));
        assert!(result.contains("end:\n"));
    }
}