// ===== BASIC OPERATIONS =====

#define clear [-]
#define inc(n) {repeat(n, +)}
#define dec(n) {repeat(n, -)}
#define next(n) {repeat(n, >)}
#define prev(n) {repeat(n, <)}
#define nop +-

// Aliases for readability
#define right(n) @next(n)
#define left(n) @prev(n)

#define set(n) @clear @inc(n)

// If current cell is non-zero, execute then clear
#define if [
#define endif @clear]

// While current cell is non-zero
#define while [
#define endwhile ]

// Basic loop n times
#define loop(n) @clear @inc(n)[@dec(1)
#define endloop ]

#define default [@clear]
#define switch(n_branches, default, flag, x) flag [-]+ x {repeat(n_branches, [-)} default
#define case(n, code, flag, x) flag [@clear code] x ]

// ===== ADVANCED PATTERNS =====

// Find next zero cell to the right
#define find_zero [>]

// ===== DEBUG HELPERS =====

// Create a "breakpoint" (infinite loop)
#define break @clear @inc(1) []
#define halt @break

// MARK: ====== Program defines ======

#define LANES_COUNT 8

#define L_START 0

// [R0-R7]
#define L_REG 1

#define L_IP 2

#define L_VALUE 3
#define L_TYPE 4

#define L_SCRATCH_A 5
#define L_SCRATCH_B 6

// FASTLANE is always the last lane

// Think about the following three
#define L_STACK 8
#define L_SP 9
#define L_MEM 10

#define nextword @next(@LANES_COUNT)
#define prevword @prev(@LANES_COUNT)
#define lane(n) @next(n)

#define nextwords(n) {repeat(n, @nextword)}
#define prevwords(n) {repeat(n, @prevword)}

// TODO: Would be cool to have macro generation
#define lane_value @lane(@L_VALUE)
#define lane_value_end {repeat(@L_VALUE, <)}

#define lane_type @lane(@L_TYPE)
#define lane_type_end {repeat(@L_TYPE, <)}

#define lane_ip @lane(@L_IP)
#define lane_ip_end {repeat(@L_IP, <)}

#define lane_reg @lane(@L_REG)
#define lane_reg_end {repeat(@L_REG, <)}

#define lane_sA @lane(@L_SCRATCH_A)
#define lane_sA_end {repeat(@L_SCRATCH_A, <)}
#define lane_sB @lane(@L_SCRATCH_B)
#define lane_sB_end {repeat(@L_SCRATCH_B, <)}

#define fastlane @nextword <
#define fastlane_end > @prevword

#define goto_nonzero_left +[<[>-]>[-<+>]<]<
#define goto_nonzero_right +[>[<-]<[->+<]>]>

#define gtnzll(n) +[@left(n)[@right(n)-]@right(n)[-@left(n)+@right(n)]@left(n)]@left(n)
#define gtnzrl(n) +[@right(n)[@left(n)-]@left(n)[-@right(n)+@left(n)]@right(n)]@right(n)

#define gtzll(n) [@left(n)]
#define gtzrl(n) [@right(n)]

#define goto_nonzero_left_lane @gtnzll(@LANES_COUNT)
#define goto_nonzero_right_lane @gtnzrl(@LANES_COUNT)

#define goto_zero_left_lane @gtzll(@LANES_COUNT)
#define goto_zero_right_lane @gtzrl(@LANES_COUNT)

#define fillword(type, value, ftl) @lane_value @set(value) >@set(type)< @lane_value_end @fastlane @set(ftl) @fastlane_end @nextword

#define move_to(dest, source) [-dest+source]dest

#define move_l @move_to(@prevword, @nextword)
#define move_r @move_to(@nextword, @prevword)

#define move_l_n(n) @move_to(@prevwords(n), @nextwords(n))
#define move_r_n(n) @move_to(@nextwords(n), @prevwords(n))

#define goto_start_slow @goto_nonzero_left_lane
#define goto_start @fastlane \
  @goto_zero_left_lane \
  @fastlane_end

// To make sure it always works: go to start, and then go to IP from the left
// Think about marking macros as non-returning to lane 0
#define goto_ip_slow @goto_start @lane_ip @goto_nonzero_right_lane
#define goto_ip @goto_start @nextword @fastlane @goto_zero_right_lane @fastlane_end @lane_ip

// ======= IP movement
#define move_ip_left @goto_ip @move_l @lane_ip_end
// Perhaps bound checking via start marker? Think about this
#define move_ip_left_n(n) @goto_ip {repeat(n, @move_l)} @lane_ip_end

// Requires to be on IP
#define find_next_command @lane_ip_end @prevword @lane_type @goto_zero_left_lane @lane_type_end
#define find_prev_command @goto_ip @lane_ip_end @nextword @lane_type @goto_zero_right_lane @lane_type_end

#define move_ip_here_r @lane_ip @set(1) @nextword @goto_nonzero_right_lane @clear @goto_nonzero_left_lane
#define move_ip_here_l @lane_ip @set(1) @prevword @goto_nonzero_left_lane @clear @goto_nonzero_right_lane

#define move_ip_next_command @find_next_command @move_ip_here_r @lane_ip_end \
   @fastlane [-@nextword] @goto_nonzero_left_lane @fastlane_end @lane_ip
#define move_ip_prev_command @find_prev_command @move_ip_here_l

#define move_ip_n_next_commands(n) {repeat(n, @move_ip_next_command @lane_ip_end)} @lane_ip
#define move_ip_n_prev_commands(n) {repeat(n, @move_ip_prev_command @lane_ip_end)} @lane_ip

// so now the only thing we need to do to achieve relative IP jumps is to
// create a macro jp

// registers
#define R0 0
#define R1 1
#define R2 2
#define R3 3
#define R4 4
#define R5 5
#define R6 6
#define R7 7

// registers movement
#define goto_R0 @goto_start @lane_reg
#define goto_R1 @goto_start @lane_reg {repeat(1, @nextword)}
#define goto_R2 @goto_start @lane_reg {repeat(2, @nextword)}
#define goto_R3 @goto_start @lane_reg {repeat(3, @nextword)}
#define goto_R4 @goto_start @lane_reg {repeat(4, @nextword)}
#define goto_R5 @goto_start @lane_reg {repeat(5, @nextword)}
#define goto_R6 @goto_start @lane_reg {repeat(6, @nextword)}
#define goto_R7 @goto_start @lane_reg {repeat(7, @nextword)}

// Scratch ops
#define copy_to_A [->>+>+<<<] >>> [-<<<+>>>] <<<
#define copy_to_B [->>+>+<<<] >> [-<<+>>] <<
#define copy_to_A_via_next_B [->>+>@nextword+<<<@prevword] >>>@nextword [-<<<@prevword+>>>@nextword] <<<@prevword

#define copy_value_to_A @lane_value @copy_to_A @lane_value_end
#define copy_value_to_A_via_next_B @lane_value @copy_to_A_via_next_B @lane_value_end

// Registers fetch

#define mark_register(offs) @lane_sA \
    [- \
      @lane_sA_end \
      @goto_start \
      @lane_sA \
      @goto_nonzero_right_lane \
      @move_r \
      @lane_sA_end \
      \
      @goto_start \
      @nextword \
 \
      @goto_ip \
      @lane_ip_end \
      offs \
      @lane_sA \
    ] \
    @lane_sA_end

#define goto_marked_register(action) @goto_start \
    @nextword \
    @lane_sA \
    @goto_nonzero_right_lane \
    action \
    @lane_sA_end

#define move_register_to_ip_sA(offs) @lane_reg \
    [->>>>+>+@nextword+@prevword<<<<<]>>>>>@nextword[-@prevword<<<<<+>>>>>@nextword]@prevword<<<<< \
    @lane_reg_end \
    @lane_sA \
    [- \
      @lane_sA_end \
      @goto_start \
      @nextword \
      @goto_ip \
      \
      offs @lane_ip_end \
      @lane_sA \
      + \
      @lane_sA_end \
      @lane_sB \
      @goto_nonzero_left_lane < \
    ] \
    @lane_sA_end

#define fetch_from_register(offs_from_ip) offs_from_ip \
    @copy_value_to_A \
    @mark_register(offs_from_ip) \
    @goto_marked_register(@clear) \
    @move_register_to_ip_sA(offs_from_ip) \
    @fetch_register_cleanup

#define fetch_register_cleanup @lane_sB \
    @clear \
    @lane_sB_end \
    @goto_start \
    @nextword \
    @lane_sA \
    @set(1) \
    @lane_sA_end \
    @goto_ip \
    @lane_ip_end

#define clear_and_mark_destination_register @prevword \
    @copy_value_to_A \
    @mark_register(@prevword) \
    @goto_marked_register(@nop) \
    @lane_reg \
    @clear \
    @lane_reg_end \
    @goto_ip \
    @lane_ip_end

#define move_result_to_destination_register @lane_sB \
    @while \
      - \
      @lane_sB_end \
      @prevword \
      @goto_marked_register(@nop) \
      @lane_reg \
      + \
      @lane_reg_end \
      @goto_ip \
      @lane_ip_end \
      @lane_sB \
    @endwhile \
    @lane_sB_end

#define reset_register_mark @move_result_to_destination_register \
    @prevword \
    @goto_marked_register(@clear) \
    @goto_start \
    @nextword \
    @lane_sA \
    @set(1) \
    @lane_sA_end \
    @goto_ip \
    @lane_ip_end

// MARK: ops

#define simple_register_op(op) @fetch_from_register(@prevword @prevword) \
    @fetch_from_register(@prevword @prevword @prevword) \
    op \
    @clear_and_mark_destination_register \
    @move_result_to_destination_register \
    @reset_register_mark

// MARK: ops end

// MARK: ALU ops
// MARK: Result is stored in sB of the IP word

#define alu_add @prevword @prevword @prevword \
    @lane_sA \
    @move_r \
    @move_r \
    [->+<] \
    > \
    @move_r \
    < \
    @lane_sA_end

#define alu_sub @prevword @prevword @prevword \
    @lane_sA \
    [@nextword-@prevword>+<-] \
    >[<+>-]< \
    @clear \
    @nextword \
    @move_r \
    @nextword \
    @clear \
    @prevword \
    @move_r \
    [->+<] \
    @lane_sA_end

#define _alu_bin(binop) #define alu_and @prevwords(3) \
  @lane_sA \
  @move_to(@nextwords(3), @prevwords(3)) \
  @prevwords(2) \
  @move_to(@nextwords(2) >, < @prevwords(2)) < \
  @lane_sA_end \
  @dec2bin(@sA) \
  @dec2bin(@sB) \
  @nextwords(9) \
  @prefill_fastlane(15) \
  @nextword \
  @goto_zero_right_lane \
  @set(1) \
  [ \
  binop \
  @prevword \
  ] \
  @prevwords(9) \
  @bin2dec \
  @lane_sA \
  [->+<] \
  @lane_sA_end

#define alu_and @_alu_bin(@bit_and)

// MARK: ALU ops end

#define bit_and @lane_sA \
  [->+<]>+[-<+>]< \
  @switch(3, @default, @lane_sA_end, @lane_sA) \
  @case(3, @lane_sB @set(1) @lane_sB_end, @lane_sA_end, @lane_sA) \
  @case(2, @clear, @lane_sA_end, @lane_sA) \
  @case(1, @clear, @lane_sA_end, @lane_sA) \
  @lane_sA_end \
  @lane_sB \
  [-<+>]< \
  @lane_sA_end

// MARK: commands
#define cmd_halt @halt

#define T_OP 0
#define T_VAL 1

#define OP_HALT 0
#define OP_NOP 0

#define OP_ADD 1
#define OP_SUB 2
#define OP_AND 3
// MARK: commands end

#define POWERS_OF_2 {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768}

#define prefill_fastlane(n) @clear {repeat(n, @nextword +)} @prevwords(n)
#define clear_fastlane(n) @clear {repeat(n, @nextword @clear)} @prevwords(n)

#define set_bit_1(lane_start, lane_end) lane_end \
    @goto_zero_right_lane \
    lane_start \
    + \
    lane_end \
    @prevword \
    @clear \
    @prevword \
    @goto_zero_left_lane \
    lane_start \
    @nextwords(2)

#define set_bit_0(lane_start, lane_end) lane_end \
    @goto_zero_right_lane \
    @prevword \
    @clear \
    @prevword \
    @goto_zero_left_lane \
    lane_start \
    @nextwords(2)

#define sb0a @set_bit_0(@lane_sA, @lane_sA_end)
#define sb1a @set_bit_1(@lane_sA, @lane_sA_end)

#define sb0b @set_bit_0(@lane_sB, @lane_sB_end)
#define sb1b @set_bit_1(@lane_sB, @lane_sB_end)

#define scratch_lane(n) {if(n, @lane_sA, @lane_sB)}
#define scratch_lane_end(n) {if(n, @lane_sA_end, @lane_sB_end)}

#define sA 1
#define sB 0

#define set_next_bit(lane, bit) {if(lane, {if(bit, @sb1a, @sb0a)}, {if(bit, @sb1b, @sb0b)})}

#define set_and_nextword(v) @set(v) @nextword

#define b2d_add_dec @lane_sB [- @lane_sB_end \
  @set(1) \
  @goto_zero_left_lane \
  @lane_sA \
  @inc(1) \
  @lane_sA_end \
  @nextword \
  @goto_zero_right_lane \
  @prevword  \
  @lane_sB \
] @lane_sB_end

#define b2d_skip_bit @lane_sB @clear @lane_sB_end

// Division layout is n, 0, d, 0, 0, 0, 0
// Result layout is >0, n, d-n%d, n%d, n/d
#define divmod [-@nextword+@nextword-[@nextword+@nextwords(2)]@nextword[+[-@prevword+@nextword]@nextword+@nextwords(2)]@prevwords(6)]

// Result will be stored in scratch lane 16 cells starting from current_word + 9
#define dec2bin(sl) @prefill_fastlane(24) \
@scratch_lane(sl) \
[ \
  @nextwords(2) \
  @set(2) \
  @prevwords(2) \
  @divmod \
  @nextword @clear \
  @nextword @clear \
  @nextword \
  + \
  @switch(2, @default, @prevword, @nextword) \
  @case(2, @set_next_bit(sl, 1), @prevword, @nextword) \
  @case(1, @set_next_bit(sl, 0), @prevword, @nextword) \
  @nextword \
  @move_l_n(4) \
] \
@scratch_lane_end(sl) \
@clear_fastlane(24)

#define b2d_setup @prefill_fastlane(24) \
  @nextwords(10) \
  @scratch_lane(@sB) \
  {for(v in {reverse(@POWERS_OF_2)}, @set_and_nextword(v))} \
  @prevword \
  @scratch_lane_end(@sB)

#define b2d_cleanup @goto_zero_left_lane @clear_fastlane(24)

// bin2dec requires binary value to be in sA, and uses sB and lane 0 as helper lanes
#define bin2dec @b2d_setup \
@scratch_lane(@sB) \
@while \
  @prev(1) \
  @inc(1) \
  @switch(2, @default, @scratch_lane_end(@sA), @scratch_lane(@sA)) \
  @case(2, @b2d_add_dec, @scratch_lane_end(@sA), @scratch_lane(@sA)) \
  @case(1, @b2d_skip_bit, @scratch_lane_end(@sA), @scratch_lane(@sA)) \
  @prevword \
  @next(1) \
@endwhile \
@scratch_lane_end(@sB) \
@b2d_cleanup

#define add @lane_sB_end @simple_register_op(@alu_add) >
#define sub @lane_sB_end @simple_register_op(@alu_sub) >
#define and @lane_sB_end @simple_register_op(@alu_and) >

// Set START marker
@set(1)
@lane_sA
@nextword
@set(1) // Mark the R1 register
@lane_sA_end
@prevword

// Set registers
@nextword
@goto_R2
@set(37)  // binary 0000 0000 0010 0101
@nextword
@set(172) // binary 0000 0000 1010 1100
@lane_reg_end

@goto_start_slow

// ===== CMD =======
@fillword(@T_OP, @OP_HALT, 0) // First op should always be halt
@fillword(@T_OP, @OP_NOP, 1)
@fillword(@T_OP, @OP_NOP, 1)
@fillword(@T_OP, @OP_NOP, 1)
@fillword(@T_OP, @OP_NOP, 1)

// AND R1, R2, R3 -- (37 & 172) — expecting 36 (0000 0000 0010 0100)
@fillword(@T_VAL, @R3, 1) // rt
@fillword(@T_VAL, @R2, 1) // rs
@fillword(@T_VAL, @R1, 1) // rd
@fillword(@T_OP, @OP_AND, 0)
// ===== CMD END ===

// Set IP
@lane_ip
@prevword
@set(1)
@lane_ip_end

@prevword
@goto_start

// Main loop
@while
  @nextword
  @goto_ip
  @lane_ip_end

  // execute command
  // decode command start
  @lane_value // Now we are at the opcode
    //[] // If zero, we need to halt?

    @copy_to_A
  @lane_value_end

  @lane_sA

  @switch(3, @default, >, <)
  @case(3, @and, >, <)
  @case(2, @sub, >, <)
  @case(1, @add, >, <)

  @lane_ip
  @move_ip_next_command

  @lane_ip_end
  @goto_start
$
  @halt // MARK: One operation finished. Let's chill forever
@endwhile