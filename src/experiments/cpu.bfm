// MARK: ------------- START -------------

#define PROGRAM {

@prg(
  // Memory
  @lane(#L_MEM,
    {for(s in {'H','e','l','l','o',',',' ','R','i','p','p','l','e','!',10,0}, @set(s) @nextword)}
  ),

  // Program
  @program_start(@OP_LI    , @R3 , 0   , 0)
  @cmd(@OP_LI    , @R4 , 3   , 0)
  @cmd(@OP_LI    , @R5 , 2   , 0)
  @cmd(@OP_LOAD  , @R3 , @R0 , @R5)
  @cmd(@OP_BNE   , @R3 , @R0 , 2)
  @cmd(@OP_HALT  , 0   , 0   , 0)
  @cmd(@OP_ADDI  , @R5 , @R5 , 1)
  @cmd(@OP_STOR  , @R3 , @R0 , 0)
  @cmd(@OP_JAL   , 0   , 0   , 3)
  @program_end
)

}

// MARK: ----------- CODE END ----------













#define FALSE 0
#define TRUE  1

#define ENDL 0xA

#define clear [-]
#define inc(n) {repeat(n, +)}
#define dec(n) {repeat(n, -)}
#define next(n) {repeat(n, >)}
#define prev(n) {repeat(n, <)}
#define nop +-
#define print .

#define set_int_max @clear -


// Aliases for readability
#define right(n) @next(n)
#define left(n) @prev(n)

#define set(n) @clear @inc(n)

// If current cell is non-zero, clear then execute
#define if [ @clear
#define endif ]

// While current cell is non-zero
#define while(code) [code]
#define times(code) [- code]

// Basic loop n times

#define default [@clear]
#define switch(n_branches, default, flag, x) flag @clear+ x {repeat(n_branches, [-)} default
#define case(n, code, flag, x) flag [@clear code] x ]

// ===== DEBUG HELPERS =====

// Create a "breakpoint" (infinite loop)
#define break @clear @inc(1) [$]
#define halt @break

// MARK: ----- Lane Constants

#define STATE_SETUP   3
#define STATE_RUNNING 2
#define STATE_HALT    1

#define BANK_SIZE 16 // should be 65535, BUT 8*0xffff = A LOT OF CELLS, let's wait for the perf improvement of the tape UI
#define CMD_SIZE 4

#define LANES_COUNT 8

#define L_START 0

#define L_REG 1

#define L_POINTER 2

#define L_CODE 3
#define L_RAM 4

#define L_SCRATCH_A 5
#define L_SCRATCH_B 6

// Shorter aliases
#define L_SA @L_SCRATCH_A
#define L_SB @L_SCRATCH_B
#define L_PTR @L_POINTER
#define L_MEM @L_RAM

// FASTLANE is always the last lane, marking the range between start and instruction pointer

// MARK: ----- Opcode Constants
#define cmd_halt @halt

#define T_OP  0
#define T_VAL 1

#define OP_HALT 0
#define OP_NOP  0

#define OP_ADD  0x1
#define OP_SUB  0x2
#define OP_AND  0x3
#define OP_OR   0x4
#define OP_XOR  0x5
#define OP_SL   0x6 // Bit Shift Left
#define OP_SR   0x7 // Bit Shift Right
#define OP_SLT  0x8 // Set Less Than signed
#define OP_SLTU 0x9 // Set Less Than unsigned

#define OP_ADDI 0xA
#define OP_ANDI 0xB
#define OP_ORI  0xC
#define OP_XORI 0xD
#define OP_LI   0xE
#define OP_SLI  0xF
#define OP_SRI  0x10

#define OP_LOAD 0x11

#define OP_STOR 0x12

#define OP_JAL  0x13
#define OP_JALR 0x14

#define OP_BEQ  0x15
#define OP_BNE  0x16
#define OP_BLT  0x17
#define OP_BGE  0x18

// MARK: ----- Register Constants
#define REG_ZONE_W  20
#define REG_ZONE_CW 5

#define R0   0

#define PC   1
#define PCB  2

#define RA   3 // R1
#define RAB  4 // R2

#define R3   5
#define R4   6
#define R5   7
#define R6   8
#define R7   9
#define R8   10
#define R9   11
#define R10  12
#define R11  13
#define R12  14
#define R13  15
#define R14  16
#define R15  17

// MARK: -- Memory mapping
#define OUT      0x00
#define OUT_FLAG 0x01

// MARK: -- Lane Operations

#define nextword @next(#LANES_COUNT)
#define prevword @prev(#LANES_COUNT)
#define lane_start(n) @next(n)
#define lane_end(n) {repeat(n, <)}

#define nextwords(n) {repeat(n, @nextword)}
#define prevwords(n) {repeat(n, @prevword)}

#define lane_reg @lane_start(@L_REG)
#define lane_reg_end @lane_end(@L_REG)

#define lane(lane, code) @lane_start(lane) code @lane_end(lane)

#define fastlane @nextword <
#define fastlane_end > @prevword

#define fl(code) @fastlane code @fastlane_end

#define gtnzll(n) +[@left(n)[@right(n)-]@right(n)[-@left(n)+@right(n)]@left(n)]@left(n)
#define gtnzrl(n) +[@right(n)[@left(n)-]@left(n)[-@right(n)+@left(n)]@right(n)]@right(n)

#define gtzll(n) [@left(n)]
#define gtzrl(n) [@right(n)]

#define goto_nonzero_left_lane @gtnzll(@LANES_COUNT)
#define goto_nonzero_right_lane @gtnzrl(@LANES_COUNT)

#define goto_zero_left_lane @gtzll(@LANES_COUNT)
#define goto_zero_right_lane @gtzrl(@LANES_COUNT)

#define clear_to_zero_left_lane [-@left(@LANES_COUNT)]

// MARK: -- Movement Helpers

#define set_lane(lane, v) @lane(lane, @set(v))

#define instr(instrs) @nextwords(3) instrs @nextwords(5)

#define _instr(value, ftl) + @lane(@L_CODE, @set(value)) @fl(@set(ftl)) @prevword
#define i1(value) @_instr(value, 1)
#define i0(value) @_instr(value, 0)

#define move_to(dest, source) [-dest+source]dest

#define move_l @move_to(@prevword, @nextword)
#define move_r @move_to(@nextword, @prevword)

#define move_l_n(n) @move_to(@prevwords(n), @nextwords(n))
#define move_r_n(n) @move_to(@nextwords(n), @prevwords(n))

#define goto_start_slow @goto_nonzero_left_lane
#define goto_start @fl(@goto_zero_left_lane)

// To make sure it always works: go to start, and then go to IP from the left
#define goto_ip_word @goto_start @nextword @fl(@goto_zero_right_lane)
#define goto_ip_left @fl(@goto_nonzero_left_lane @nextword)

// MARK: -- IP movement and prg flow

#define skip_mmapped @lane(#L_MEM, @nextwords(2))

#define set_noinc_pc_flag {
  @prevword
  @goto_start
  @lane(@L_SA, @set(1))
  @nextword
  @goto_ip_word
}

// Requires to be on IP
#define move_ip_next_command {

  @prevword
  @goto_start
  @lane(@L_SA,
    @if
      @lane_end(@L_SA)
      @lane(@L_REG,
          @nextwords(2) @dec(1) @prevwords(2) // PC
      )

      @nextword
      @goto_ip_word
      @fl(@prevword
        - @prevword
        - @prevword
        - @prevword
        - @prevword
      )
      @goto_start
      @lane_start(@L_SA)
    @endif
  )

  @nextword
  @goto_ip_word

  @fl( {repeat(@CMD_SIZE, +@nextword)} ) @prevword
  @goto_PC @inc(1) @lane_end(@L_REG)
  // TODO: IF INCREMENT WRAPPED PC, NEED TO INC PCB!!!
  @goto_ip_word
  @prevword
}

// MARK: -- PTR ops

#define goto_ptr_start @lane(@L_POINTER, @goto_zero_left_lane)
#define goto_ptr_end @lane(@L_POINTER, @goto_zero_right_lane)

#define ptr_cleanup {
  @lane(@L_POINTER,
    @goto_zero_right_lane
    @prevword
    [-@prevword]
  )
}

// MARK: -- Registers Movement
// TODO: Make these conform to "all goto ops go to word n lane L_START"
#define goto_PC @goto_start @lane_reg {repeat(@PC, @nextword)} @nextword
#define goto_PCB @goto_start @lane_reg {repeat(@PCB, @nextword)} @nextword

#define _copy_pc_ra {
  @copy_reg_to_A_via_B

  @nextwords(2)
  @lane(@L_REG, @clear)
  @prevwords(2)

  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)
      @nextwords(2)
      @lane_reg
      +
      @lane_reg_end
      @prevwords(2)
      @lane_start(@L_SA)
    )
  )
}

// MARK: -- Scratch ops
#define copy_to_A [->>+>+<<<] >>> [-<<<+>>>] <<<
#define copy_to_B [->>+>+<<<] >> [-<<+>>] <<

#define copy_value_to_A @lane(@L_CODE, @copy_to_A)
#define copy_value_to_B @lane(@L_CODE, @copy_to_B)

#define copy_reg_to_A_via_B @lane(@L_REG, [->>>>+>+<<<<<] >>>>> [-<<<<<+>>>>>] <<<<<)

// MARK: -- Registers fetch
#define mark_register(offs) {
  @lane(@L_SA, // MARK: do lane times
    @times(
      @lane_end(@L_SA)
      @goto_start

      @nextword

      @lane(@L_PTR, [@nextword]+)

      @goto_start
      @nextword

      @goto_ip_word
      offs
      @lane_start(@L_SA)
    )
  )
}

#define goto_marked_register {
  @goto_start
  @nextword
  @goto_ptr_end
}

#define move_register_to_ip_sA(offs) {
  @lane(@L_REG,
    [->>>>+>+@nextword+@prevword<<<<<]>>>>>@nextword[-@prevword<<<<<+>>>>>@nextword]@prevword<<<<<
  )

  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)
      @goto_start
      @nextword
      @goto_ip_word

      offs
      @lane(@L_SA, +)
      @lane(@L_SB, @goto_nonzero_left_lane)
      @lane_start(@L_SA)
    )
  )
}


#define fetch_from_register(offs_from_ip) {
    offs_from_ip
    @copy_value_to_A
    @mark_register(offs_from_ip)
    @goto_marked_register
    @move_register_to_ip_sA(offs_from_ip)
    @fetch_register_cleanup
}

#define fetch_register_cleanup {
    @lane(@L_SB, @clear)
    @goto_start
    @nextword
    @ptr_cleanup
    @nextword
    @goto_ip_word
}

#define clear_and_mark_destination_register {
    @prevword
    @copy_value_to_A
    @mark_register(@prevword)
    @goto_marked_register
    @lane(@L_REG, @clear)
    @goto_ip_word
}

#define move_result_to_destination_register {
  @lane(@L_SB,
    @times(
      @lane_end(@L_SB)
      @prevword
      @goto_marked_register
      @lane(@L_REG, +)
      @goto_ip_word
      @lane_start(@L_SB)
    )
  )
}

#define reset_register_mark {
    @prevword

    @goto_start
    @nextword

    @ptr_cleanup
    @nextword
    @goto_ip_word
}

// MARK: -- math and logic

#define eq(tox, toy) [-toy-tox]+toy[tox-toy[-]] tox
#define not(totemp, tox) - [totemp-tox-] totemp[tox+totemp-] tox
#define neq(tox, toy) @eq(tox, toy) @not(tox, toy)

// Ok. This abomination works ONLY in sA, required layout words: [0, y, >x, [0, 1]]
#define lt {
  @nextword > + < @prevword
  +@prevword+@nextword

  [-@prevword-[@prevword]@nextword @nextword]

  >[-
       // BLOCK (a>=b)
      < @prevword @set(0) @nextword >
  ]

  @nextword[-
       // BLOCK(a<b)
    < @prevwords(2) - @nextword @set(1) @nextwords(2) >
  ]

  < @prevword @prevword
}

// MARK: -- simple_register_op

#define two_registers_op(op) {
    @fetch_from_register(@prevword @prevword)
    @fetch_from_register(@prevword @prevword @prevword)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

#define two_registers_op_no_set(op) {
    @fetch_from_register(@prevword @prevword)
    @fetch_from_register(@prevword @prevword @prevword)
    op
}

#define two_registers_branch_op(op) {
  @fetch_from_register(@prevword)
  @fetch_from_register(@prevword @prevword)
  op
}

#define one_register_op(op) {
    @fetch_from_register(@prevwords(2))
    // Load immediate
    @prevwords(3)
    @copy_value_to_A
    @nextwords(3)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

#define no_register_imm1_op(op) {
    // Load immediate
    @prevwords(2)
    @copy_value_to_A
    @nextwords(2)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

#define no_register_imm2_op(op) {
    // Load immediate
    @prevwords(2)
    @copy_value_to_A
    @nextwords(2)
    @prevwords(3)
    @copy_value_to_A
    @nextwords(3)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

// MARK: ------------ ALU ops ------------
// Result is stored in sB of the IP word

#define alu_add {
  @prevword @prevword @prevword
  @lane(@L_SA,
    [-@nextword+@prevword]
    @nextword
    @move_to(@nextword @nextword >, < @prevword @prevword)
    <
  )
}

#define alu_sub {
  @prevword @prevword @prevword
  @lane(@L_SA,
    [@nextword-@prevword>+<-]
    >[<+>-]<
    @clear
    @nextword
    @move_r
    @nextword
    @clear
    @prevword
    @move_r
    [->+<]
  )
}

#define _alu_bin(binop) {
  @prevwords(3)
  @lane(@L_SA,
    @move_to(@nextwords(3), @prevwords(3))
    @prevwords(2)
    @move_to(@nextwords(2) >, < @prevwords(2)) <
  )
  @dec2bin(@sA)
  @dec2bin(@sB)
  @nextwords(9)
  @prefill_fastlane(15)
  @nextword
  @goto_zero_right_lane
  @set(1)
  [
    binop
    @prevword
  ]
  @prevwords(9)
  @bin2dec
  @lane(@L_SA, [->+<])
}

#define alu_and @_alu_bin(@bit_and)
#define alu_or @_alu_bin(@bit_or)
#define alu_xor @_alu_bin(@bit_xor)

#define setup_alu_shift {
  @lane(@L_SA,
    @prevwords(2)
    @move_to(@nextwords(2),  @prevwords(2))
  )
  @dec2bin(@sA)
  @prevwords(3)
  @lane(@L_SA,
    @move_to(@nextwords(3), @prevwords(3))
  )
}

#define alu_sl {
  @setup_alu_shift

  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)
      @nextwords(9)
      @prefill_fastlane(16) // Yes, 16 to capture the LSB

      @nextword
      @times(

        @lane(@L_SA,
          @move_l
          @nextword
        )

        @nextword
      )

      @goto_ip_left
      @lane_start(@L_SA)
    )
  )

  @lane(@L_SA,
    @nextwords(9)
    @clear
    @prevwords(9)
  )

  @bin2dec

  @lane(@L_SA, [->+<]) // MARK: Candidate for extract
}

#define alu_sr {
  @setup_alu_shift

  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)
      @nextwords(9)
      @prefill_fastlane(16) // Yes, 16 to capture the LSB
      @nextword
      @goto_zero_right_lane

      @prevword

      @times(
        @lane(@L_SA,
          @move_r
          @prevword
        )

        @prevword
      )

      @goto_ip_left
      @lane_start(@L_SA)
    )
  )

  @lane(@L_SA,
    @nextwords(26)
    @clear
    @prevwords(26)
  )

  @bin2dec

  @lane(@L_SA, [->+<])
}

#define _alu_slt_different_sign {
  // If the sign is different, then we just move rs's sign to the result cell
  @lane(@L_SA,
    @prevword

    @move_to(@prevwords(8) >, < @nextwords(8))
    <
    @nextwords(8)
  )
}

#define _alu_slt_same_sign {
  @lane(@L_SA,
    @nextwords(2)
    // Clean the old binary representations
    {repeat(16, @clear @nextword)}
    >
    {repeat(16, @clear @prevword)}
    <
    @prevwords(2)

    @prevwords(10)

    @move_r
    @prevword >
    @move_r <
  )

  @_cmp_unsigned_lt

  @lane(@L_SA, [->+<])

  @nextwords(8)
}

#define alu_slt {
  @prevwords(2)
  @lane_start(@L_SA) // MARK: Bad Pavlo, starts at sA, ends at sB
  [-@nextword+@nextword+@prevwords(2)]@nextwords(2)

  @prevwords(3)
  [->+<]>
  [-@nextwords(2)+@nextword+@prevwords(3)]@nextwords(3)
  @lane_end(@L_SB)

  @dec2bin(@sA)
  @dec2bin(@sB)

  @nextwords(10)
  @lane_start(@L_SA)

  [-@prevword+@prevword+@prevword+@nextwords(3)] @prevwords(3) @move_to(@nextwords(3), @prevwords(3))
  >
  [-@prevword+@prevword+@prevword+@nextwords(3)] @prevwords(3) @move_to(@nextwords(3), @prevwords(3))
  <

  @prevwords(1)

  [->+<]
  >+

  @switch(3, @default, @lane_end(@L_SB), @lane_start(@L_SB))
  @case(3, @_alu_slt_same_sign, @lane_end(@L_SB), @lane_start(@L_SB))
  @case(2, @_alu_slt_different_sign, @lane_end(@L_SB), @lane_start(@L_SB)) // When signs are different, the one with 0 is bigger. We can just copy the sign of the second operand
  @case(1, @_alu_slt_same_sign, @lane_end(@L_SB), @lane_start(@L_SB))

  @prevwords(8)
  @lane_end(@L_SB)

  // Cleanup
  @prevword
  @lane(@L_SA, @clear > @clear <)
  @nextword

  @lane(@L_SA,
    @nextwords(8)
    {repeat(18, @clear >)}
    >
    {repeat(18, @clear <)}
    <
    @prevwords(8)
  )
}

#define alu_sltu {
  @lane(@L_SA,
    @prevwords(2)
    @move_r_n(2)
    @prevwords(3)
    @move_to(@nextwords(3) >, < @prevwords(3)) <
  )

  @_cmp_unsigned_lt

  @lane(@L_SA, [->+<])
}

// MARK: ---------- ALU ops end ----------

// MARK: ---------- Instructions ---------

#define _jump_to_bank_addr {
  // MARK: START JTADDR, addr is word[-2] for BANK, word[-3] for ADDR
  // 1. Copy fastlane to PTR. Now fastlane can be freely changed
  @prevword
  @fl(
    [
      @fastlane_end
      @lane(@L_PTR, +)
      @fastlane
      @prevword
    ]
  )

  @nextword
  @goto_ptr_end

  // Now we want to fill fastlane with REG_ZONE + new PCB * BANK_SIZE * CMD_SIZE + PC
  @prevword
  @fl([-@prevword])

  @fl(@prefill_fastlane(@REG_ZONE_W))

  @nextword
  @goto_ptr_end

  @prevword
  @lane(@L_SA, @set(@BANK_SIZE))
  @lane(@L_SB, @set(@CMD_SIZE))

  @prevword
  @lane(@L_SB, // Now we are at a new bank. @nextword has @CMD_SIZE, @nextword < has @BANK_SIZE
    @nop // MARK: HERE WE CAN SWITCH TO ANOTHER BANK, DO WHEN NEEDED!
    @nextword @clear < @clear > @prevword // MARK: Now let's just clear the fuck out
  )

  @prevword

  @lane(@L_SB,
    @nextwords(2)
      @set(@CMD_SIZE)
    @prevwords(2)

    // So now, @CMD_SIZE * PC + 1 times we need to :
    @nextwords(2)
    @times( // @CMD_SIZE times
      // Copy PC to sA
      @prevwords(2)
      [-<+@nextword+@prevword>]
       <@nextword
      [->@prevword+@nextword<]
      @prevword>

      @times( // PC times
        @lane_end(@L_SB)
        @goto_ptr_start

        @nextword @fl(@goto_zero_right_lane + @goto_zero_left_lane)

        @nextword
        @goto_ptr_end
        @prevwords(3)
        @lane_start(@L_SB)
      )

      <[->+<]>
      @nextwords(2)
    )

    @prevwords(2)
    @clear
    @nextwords(2)
  )

  @goto_ptr_start
  @nextword
  @ptr_cleanup
  @nextword
  @goto_ip_word

  @fl({repeat(4, @set(1) @nextword)})
  @prevword
  @fl(@clear) // We need 0 in the last fastlane pos
}

#define ins_jal {
  @prevword
  @goto_PC
  @lane_reg_end

  @_copy_pc_ra

  @nextword

  // Copy PC to RA
  @_copy_pc_ra

  @goto_ip_word
  @prevwords(2)
  @lane(@L_SA, // First op param is BANK
    [->+@nextwords(2)+@prevwords(2)<]@nextwords(2)
  )

  // MARK: Candidate for "set pcb"
  @prevword
  @goto_start
  @goto_PCB @clear
  @lane_reg_end
  @goto_ip_word
  @lane(@L_SB,
    @times(
      @lane_end(@L_SB)
      @prevword
      @goto_start
      @goto_PCB
      +
      @lane_reg_end
      @goto_ip_word
      @lane_start(@L_SB)
    )
  )

  @prevwords(3)
  @lane(@L_SA, // Second op param is ADDR
    [->+@nextwords(3)+@prevwords(3)<]@nextwords(3)
  )

  // MARK: Candidate for "set pc"
  @prevword
  @goto_start
  @nextword

  @goto_PC @clear
  @lane_reg_end

  @goto_ip_word
  @lane(@L_SB,
    @times(
      @lane_end(@L_SB)
      @prevword
      @goto_start
      @nextword @goto_PC
      +
      @lane_reg_end
      @goto_ip_word
      @lane_start(@L_SB)
    )
  )

  // Now bank and addr are in word[-2] and word[-3]

  @set_noinc_pc_flag

  @_jump_to_bank_addr
}

#define ins_beq(should_inverse) @ins_branch(@eq(@nextword, @prevword), should_inverse)
#define ins_blt(should_inverse) @ins_branch(@lt, should_inverse)

#define ins_branch(cmp, should_inverse) {
  @prevword

  @lane(@L_SA,
    cmp
    {if(should_inverse, @not(>, <), @nop)}
  )
  @lane_start(@L_SA)

  // Early exit
  // Copy comparison result to here[-2]
  [-@prevword+@prevword+@nextwords(2)] @prevwords(2) @move_to(@nextwords(2), @prevwords(2))

  @eq(<, >)  // if zero
  @if
    @lane_end(@L_SA)
    @nextword
  @endif

  @prevword [-@nextword+@prevword] @nextword

  @if
    @lane_end(@L_SA)

    // Copy from PCB to word[-1][sA], extract and reuse for other branch commands
    @goto_PCB
    @lane_reg_end
    @copy_reg_to_A_via_B

    @lane(@L_SA,
      @times(
        @lane_end(@L_SA)
        @goto_ip_word
        @prevword
        @lane(@L_SA, +)
        @goto_PCB
        @lane_reg_end
        @lane_start(@L_SA)
      )
    )
    @goto_ip_word // word[-1][sA] LOADED from PCB

    // move it to word[-2]
    @prevword

    @lane(@L_SA,
      @move_to(@prevword >, < @nextword) <
    )

    @nextwords(2)

    @prevword
    @goto_PC
    @lane_reg_end
    @copy_reg_to_A_via_B

    @lane(@L_SA,
      @times(
        @lane_end(@L_SA)
        @goto_ip_word
        @prevword
        @lane(@L_SA, +)
        @goto_PC
        @lane_reg_end
        @lane_start(@L_SA)
      )
    )
    @goto_ip_word

    @prevwords(3)
    @copy_value_to_B

    @nextwords(2)


    @lane(@L_SA,
      @move_to(@prevwords(2) >, < @nextwords(2)) < // Very important! calculating addr by PC + imm
    )

    // Now we need to copy new calculated addr to PC
    @lane(@L_SB,
      [-@prevword+@prevword+@nextwords(2)] @prevwords(2) @move_to(@nextwords(2), @prevwords(2))
    )

    @goto_PC @clear @lane_reg_end
    @goto_ip_word
    @prevwords(4)

    @lane(@L_SB,
      @times(
        @lane_end(@L_SB)
        @goto_PC + @lane_reg_end
        @goto_ip_word
        @prevwords(4)
        @lane_start(@L_SB)
      )
    )
    @nextwords(4)
    // Copied. Safe to jump!

    // MARK: HERE!!!
    @set_noinc_pc_flag

    @_jump_to_bank_addr // ?

  @endif
}

#define mem_ptr_fill_banks(offs_from_ip) {
  @lane(@L_SB,
    @set(@BANK_SIZE)
  )
  @lane(@L_SA,
    @times(
      >
      @times(
        @lane_end(@L_SB)
        @goto_start
        @lane(@L_PTR, @goto_zero_right_lane @inc(1))

        @goto_ptr_start @nextword
        @nextword @goto_ip_word
        offs_from_ip
        @lane_start(@L_SB)
      )
      <
    )
  )
  @lane(@L_SB, @clear)
}

#define mem_ptr_fill(offs_from_ip) {
  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)
      @goto_start

      @lane(@L_PTR, @goto_zero_right_lane @inc(1))

      @nextword @goto_ip_word
      offs_from_ip
      @lane_start(@L_SA)
    )
  )
}

#define ins_stor {
  @fetch_from_register(@prevword)

  @prevwords(2)

  // Before all this shit we want to possibly mo mmapped shit
  // If we are writing to @OUT, then we want to twinkle twinkle

  @lane(@L_SA,
    // copy via sB prevword
    [->+@prevword+@nextword<] >@prevword [-@nextword<+>@prevword] @nextword <
  )

  // if @L_SB is not zero, then poop
  // if zero, then check addr

  // memory mapped io subroutine
  @prevword
    @lane(@L_SA,
      [->+@prevword+@nextword<] >@prevword [-@nextword<+>@prevword] @nextword <
    )

    @lane(@L_SB,
      @eq(@nextword, @prevword)
      [-@prevword+@prevword+@nextword @nextword] @prevword @prevword [-@nextword @nextword+ @prevword @prevword] @nextword @nextword

      @if
        @nextwords(2) <
          @print
        > @prevwords(2)
      @endif
    )
  @nextword

  @mem_ptr_fill_banks(@prevwords(2))

  // Filling ptr lane up to the needed cell
  @prevword
  @mem_ptr_fill(@prevwords(3))
  @nextwords(3)

  // clear mem
  @prevword
  @goto_start
  @goto_ptr_end
    @lane(@L_RAM, @clear)
  @goto_ptr_start
  @nextword
  @goto_ip_word

  // memset
  @prevword
  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)

      @goto_start
      @goto_ptr_end
        @lane(@L_RAM, @inc(1))
        @prevword
      @goto_ptr_start
      @nextword
      @goto_ip_word

      @prevword
      @lane_start(@L_SA)
    )
  )


  @prevwords(3)
  @lane(@L_SB,
    @if
      @lane_end(@L_SB)
      @goto_start
        @lane(@L_RAM, @nextword @clear @inc(1) @prevword)
      @nextword
      @goto_ip_word
      @prevwords(3)
      @lane_start(@L_SB)
    @endif
  )
  @nextwords(2)

  @goto_start
  @ptr_cleanup
  @nextword
  @goto_ip_word
}

#define ins_load {
  @prevwords(2)
  @mem_ptr_fill_banks(@prevwords(2))

  // Filling ptr lane up to the needed cell
  @prevword
  @mem_ptr_fill(@prevwords(3))
  @nextwords(3)

  // memget
  @prevword
  @goto_start
  @goto_ptr_end

  @lane(@L_RAM,
    [->+>+<<] >> [-<<+>>] << // Copy ram value to sA via sB
  )

  @lane(@L_SA,
    @times(
      @lane_end(@L_SA)

      @prevword @goto_ptr_start

      @nextword @nextword
      @goto_ip_word
      @lane(@L_SB, @inc(1))
      @prevword
      @goto_start

      @goto_ptr_end
      @lane_start(@L_SA)
    )
  )

  @goto_start
  @ptr_cleanup
  @nextword
  @goto_ip_word
}

// MARK: --------Instructions end --------

// MARK: -- Bin ops
#define bit_and {
  @lane(@L_SA,
    [->+<]>+[-<+>]<
    @switch(3, @default, @lane_end(@L_SA), @lane_start(@L_SA))
    @case(3, @set_lane(@L_SB, 1), @lane_end(@L_SA), @lane_start(@L_SA))
    @case(2, @clear, @lane_end(@L_SA), @lane_start(@L_SA))
    @case(1, @clear, @lane_end(@L_SA), @lane_start(@L_SA))
  )
  @lane(@L_SB, [-<+>]) // copy b to a
}

#define bit_or {
  @lane(@L_SA,
    [->+<]>+[-<+>]<
    @switch(3, @default, @lane_end(@L_SA), @lane_start(@L_SA))
    @case(3, @set_lane(@L_SB, 1), @lane_end(@L_SA), @lane_start(@L_SA))
    @case(2, @set_lane(@L_SB, 1), @lane_end(@L_SA), @lane_start(@L_SA))
    @case(1, @clear, @lane_end(@L_SA), @lane_start(@L_SA))
  )

  @lane(@L_SB, [-<+>])
}

#define bit_xor {
  @lane(@L_SA,
    [->+<]>+[-<+>]<
    @switch(3, @default, @lane_end(@L_SA), @lane_start(@L_SA))
    @case(3, @clear, @lane_end(@L_SA), @lane_start(@L_SA))
    @case(2, @set_lane(@L_SB, 1), @lane_end(@L_SA), @lane_start(@L_SA))
    @case(1, @clear, @lane_end(@L_SA), @lane_start(@L_SA))
  )
  @lane(@L_SB, [-<+>])
}

#define POWERS_OF_2 {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768}

// MARK: -- Helpers
#define prefill_fastlane(n) @clear {repeat(n, @nextword +)} @prevwords(n)
#define clear_fastlane(n) @clear {repeat(n, @nextword @clear)} @prevwords(n)

#define set_bit_1(lane_start, lane_end) {
    lane_end
    @goto_zero_right_lane
    lane_start
    +
    lane_end
    @prevword
    @clear
    @prevword
    @goto_zero_left_lane
    lane_start
    @nextwords(2)
}

#define set_bit_0(lane_start, lane_end) {
    lane_end
    @goto_zero_right_lane
    @prevword
    @clear
    @prevword
    @goto_zero_left_lane
    lane_start
    @nextwords(2)
}

#define sb0a @set_bit_0(@lane_start(@L_SA), @lane_end(@L_SA))
#define sb1a @set_bit_1(@lane_start(@L_SA), @lane_end(@L_SA))

#define sb0b @set_bit_0(@lane_start(@L_SB), @lane_end(@L_SB))
#define sb1b @set_bit_1(@lane_start(@L_SB), @lane_end(@L_SB))

// TODO: Think if this is really necessary.
#define scratch_lane(n) {if(n, @lane_start(@L_SA), @lane_start(@L_SB))}
#define scratch_lane_end(n) {if(n, @lane_end(@L_SA), @lane_end(@L_SB))}

#define sA 1
#define sB 0

#define set_next_bit(lane, bit) {if(lane, {if(bit, @sb1a, @sb0a)}, {if(bit, @sb1b, @sb0b)})}

#define set_and_nextword(v) @set(v) @nextword

#define b2d_add_dec {
  @lane(#L_SB,
    @times(
      @lane_end(#L_SB)
      @set(1)
      @goto_zero_left_lane
      @lane(#L_SA, @inc(1))
      @nextword
      @goto_zero_right_lane
      @prevword
      @lane_start(#L_SB)
    )
  )
}

#define b2d_skip_bit @lane(@L_SB, @clear)

// Division layout is n, 0, d, 0, 0, 0, 0
// Result layout is >0, n, d-n%d, n%d, n/d
#define divmod [-@nextword+@nextword-[@nextword+@nextwords(2)]@nextword[+[-@prevword+@nextword]@nextword+@nextwords(2)]@prevwords(6)]

// Result will be stored in scratch lane 16 cells starting from current_word + 9
#define dec2bin(sl) {
  @prefill_fastlane(24)
  @scratch_lane(sl)
  [
  @nextwords(2)
  @set(2)
  @prevwords(2)
  @divmod
  @nextword @clear
  @nextword @clear
  @nextword
  +
  @switch(2, @default, @prevword, @nextword)
  @case(2, @set_next_bit(sl, 1), @prevword, @nextword)
  @case(1, @set_next_bit(sl, 0), @prevword, @nextword)
  @nextword
  @move_l_n(4)
  ]
  @scratch_lane_end(sl)
  @clear_fastlane(24)
}

#define b2d_setup {
  @prefill_fastlane(24)
  @nextwords(10)
  @scratch_lane(@sB)
  {for(v in {reverse(@POWERS_OF_2)}, @set_and_nextword(v))}
  @prevword
  @scratch_lane_end(@sB)
}

#define b2d_cleanup @goto_zero_left_lane @clear_fastlane(24)

// bin2dec requires binary value to be in sA, and uses sB and lane 0 as helper lanes
#define bin2dec {
  @b2d_setup
  @scratch_lane(@sB)
  @while(
    @prev(1)
    @inc(1)
    @switch(2, @default, @scratch_lane_end(@sA), @scratch_lane(@sA))
      @case(2, @b2d_add_dec, @scratch_lane_end(@sA), @scratch_lane(@sA))
      @case(1, @b2d_skip_bit, @scratch_lane_end(@sA), @scratch_lane(@sA))
    @prevword
    @next(1)
  )
  @scratch_lane_end(@sB)
  @b2d_cleanup
}

// TODO: NEVER! NEVER CALL THIS ONE DIRECTLY WITHOUT
// CHECKING THAT B IS 0!
#define _cmp_unsigned_neq_lt {
  <
  @nextword
  @move_r_n(4)
  @prevwords(4)
  >[-<+>]<

  @move_r_n(3)
  // Careful here — this will never run if b is 0.
  [-[@nextword-[@prevword @prevword-@prevword]@prevword[-]@nextwords(2)+@nextword @prevwords(3)]@nextword @clear @nextwords(2)]
  @prevword @move_l_n(5)

  @prevword
  >
}

#define _cmp_unsigned_lt { // TODO: Replace with @lt
// Requires [0, 0, 0, b, a, 0, 0]
  @lane(#L_SA,

    // If one of them is zero, then the other one is zero too.
    // So we can just gtfo.
    // Let's copy b to scratch
    >
    [-@prevword+@prevword+@nextwords(2)] @prevwords(2) @move_r_n(2)
    <
    @prevword

    [->-<]+>[<->[-]]< // What the fuck is this sorcery?
    +
    // Now, if b was equal to 0, we stand at 2. Otherwise at 1.
    @switch(2, @default, >, <)
      @case(2, @nextword @clear < @clear > @prevword, >, <) // Both were 0, gtfo
      @case(1, @_cmp_unsigned_neq_lt, >, <) // They were not, compare
    @nextword

  )
}

// MARK: ------ Opcode Handlers ---------

#define ophandler(handler) @lane_end(#L_SB) handler @lane_start(#L_SB)

#define add  @ophandler(@two_registers_op(@alu_add))
#define sub  @ophandler(@two_registers_op(@alu_sub))
#define and  @ophandler(@two_registers_op(@alu_and))
#define or   @ophandler(@two_registers_op(@alu_or))
#define xor  @ophandler(@two_registers_op(@alu_xor))
#define sl   @ophandler(@two_registers_op(@alu_sl))
#define sr   @ophandler(@two_registers_op(@alu_sr))
#define slt  @ophandler(@two_registers_op(@alu_slt))
#define sltu @ophandler(@two_registers_op(@alu_sltu))

#define addi @ophandler(@one_register_op(@alu_add))
#define andi @ophandler(@one_register_op(@alu_and))
#define ori  @ophandler(@one_register_op(@alu_or))
#define xori @ophandler(@one_register_op(@alu_xor))
#define li   @ophandler(@no_register_imm1_op(@alu_or))
#define sli  @ophandler(@one_register_op(@alu_sl))
#define sri  @ophandler(@one_register_op(@alu_sr))

#define load @ophandler(@two_registers_op(@ins_load)) // MARK: TODO: SHOULD FUCKING COPY THE VALUE
#define stor @ophandler(@two_registers_op_no_set(@ins_stor))

#define jal  @ophandler(@no_register_imm2_op(@ins_jal))
#define jalr @ophandler(@two_registers_op_no_set(@ins_jal))

#define beq  @ophandler(@two_registers_branch_op(@ins_beq(#FALSE))) // beq rs rt imm, jumps to current pcb+pc+imm
#define bne  @ophandler(@two_registers_branch_op(@ins_beq(#TRUE)))
#define blt  @ophandler(@two_registers_branch_op(@ins_blt(#FALSE)))
#define bge  @ophandler(@two_registers_branch_op(@ins_blt(#TRUE)))

#define opcase(op, han) @case(op,  han, >, <)

#define program_start(w1, w2, w3, w4) {
  {repeat(@REG_ZONE_CW,
    @instr(@i1(#OP_NOP) @i1(0) @i1(0) @i1(0))
  )}

  @instr(@i0(w1) @i1(w2) @i1(w3) @i1(w4))
}

#define cmd(w1, w2, w3, w4) {
  @instr(@i0(w1) @i0(w2) @i0(w3) @i0(w4))
}

#define program_end {
  @cmd(  #OP_HALT, #OP_NOP, #OP_NOP, #OP_NOP)
}

// MARK: ------------ MAIN ---------------
// Set START marker
@set(#STATE_SETUP)

// MARK: -- Set registers
@nextword
@nextword
#define REG_VALUES {0,0}
@lane(#L_REG,
  {for(v in #REG_VALUES, @set(v) @nextword)}
)

@goto_start_slow

@skip_mmapped

#define prg(data, code) data @goto_start_slow @nextword code
@PROGRAM

@prevword
@clear_to_zero_left_lane
@nextword
@set(#STATE_RUNNING)

// MARK: -- Main loop
@while(
  [->+>+<<]>>[-<<+>>]<< // Copy start flag to >, so switch does not fuck up our start marker
  >
  @switch(2, @default, >, <)
  @case(#STATE_RUNNING, <<@execute>>, >, <)
  @case(#STATE_HALT, @clear <<@clear>>, >, <)
  <
)

// MARK: ---- Executor
#define execute {
  @nextword

  @goto_ip_word
  @lane(@L_CODE, @copy_to_A)
  @lane(@L_SA,
    @inc(1) // To properly work with switch statement

    // MARK: ------- Opcode Switch
    @switch(25, @default, >, <)

      @opcase(#OP_BGE,   @bge)
      @opcase(#OP_BLT,   @blt)
      @opcase(#OP_BNE,   @bne)
      @opcase(#OP_BEQ,   @beq)

      @opcase(#OP_JALR,  @jalr)
      @opcase(#OP_JAL,   @jal)

      @opcase(#OP_STOR,  @stor)
      @opcase(#OP_LOAD,  @load)

      @opcase(#OP_SRI,   @sri)
      @opcase(#OP_SLI,   @sli)
      @opcase(#OP_LI,    @li)
      @opcase(#OP_XORI,  @xori)
      @opcase(#OP_ORI,   @ori)
      @opcase(#OP_ANDI,  @andi)
      @opcase(#OP_ADDI,  @addi)
      @opcase(#OP_SLTU,  @sltu)
      @opcase(#OP_SLT,   @slt)
      @opcase(#OP_SR,    @sr)
      @opcase(#OP_SL,    @sl)
      @opcase(#OP_XOR,   @xor)
      @opcase(#OP_OR,    @or)
      @opcase(#OP_AND,   @and)
      @opcase(#OP_SUB,   @sub)
      @opcase(#OP_ADD,   @add)
      @opcase(#OP_HALT,  @lane_end(#L_SB) @prevword @goto_start @set(#STATE_HALT) @goto_ip_word @lane_start(#L_SB))
  )

  @move_ip_next_command

  @goto_start
}
