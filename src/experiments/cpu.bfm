// MARK: ------------- START -------------

#define clear [-]
#define inc(n) {repeat(n, +)}
#define dec(n) {repeat(n, -)}
#define next(n) {repeat(n, >)}
#define prev(n) {repeat(n, <)}
#define nop +-

// Aliases for readability
#define right(n) @next(n)
#define left(n) @prev(n)

#define set(n) @clear @inc(n)

// If current cell is non-zero, execute then clear
#define if [
#define endif @clear]

// While current cell is non-zero
#define while [
#define endwhile ]

#define times [-
#define endtimes ]

// Basic loop n times
#define loop(n) @clear @inc(n)[@dec(1)
#define endloop ]

#define default [@clear]
#define switch(n_branches, default, flag, x) flag [-]+ x {repeat(n_branches, [-)} default
#define case(n, code, flag, x) flag [@clear code] x ]

// ===== ADVANCED PATTERNS =====

// Find next zero cell to the right
#define find_zero [>]

// ===== DEBUG HELPERS =====

// Create a "breakpoint" (infinite loop)
#define break @clear @inc(1) []
#define halt @break

// MARK: ----- Lane Constants

#define STATE_RUNNING 2
#define STATE_HALT 1

#define BANK_SIZE 128 // should be 65535, BUT 8*0xffff = A LOT OF CELLS, let's wait for the perf improvement of the tape UI
#define CMD_SIZE 4

#define LANES_COUNT 8

#define L_START 0

#define L_REG 1

#define L_POINTER 2

#define L_VALUE 3
#define L_TYPE 4

#define L_SCRATCH_A 5
#define L_SCRATCH_B 6

// FASTLANE is always the last lane, marking the range between start and instruction pointer

// MARK: ----- Opcode Constants
#define cmd_halt @halt

#define T_OP 0
#define T_VAL 1

#define OP_HALT 0
#define OP_NOP 0

#define OP_ADD  1
#define OP_SUB  2
#define OP_AND  3
#define OP_OR   4
#define OP_XOR  5
#define OP_SL   6 // Bit Shift Left
#define OP_SR   7 // Bit Shift Right
#define OP_SLT  8 // Set Less Than signed
#define OP_SLTU 9 // Set Less Than unsigned

#define OP_ADDI 10
#define OP_ANDI 11
#define OP_ORI  12
#define OP_XORI 13
#define OP_LI   14
#define OP_SLI  15
#define OP_SRI  16

#define OP_LOAD 17
#define OP_STOR 18

#define OP_J    19
#define OP_JAL  20

// MARK: ----- Register Constants
#define REG_ZONE 20

#define R0   0

#define PC   1
#define PCB  2

#define RA   3 // R1
#define RAB  4 // R2

#define R3   5
#define R4   6
#define R5   7
#define R6   8
#define R7   9
#define R8   10
#define R9   11
#define R10  12
#define R11  13
#define R12  14
#define R13  15
#define R14  16
#define R15  17

// MARK: -- Lane Operations

#define nextword @next(@LANES_COUNT)
#define prevword @prev(@LANES_COUNT)
#define lane(n) @next(n)

#define nextwords(n) {repeat(n, @nextword)}
#define prevwords(n) {repeat(n, @prevword)}

#define lane_value @lane(@L_VALUE)
#define lane_value_end {repeat(@L_VALUE, <)}

#define lane_type @lane(@L_TYPE)
#define lane_type_end {repeat(@L_TYPE, <)}

#define lane_reg @lane(@L_REG)
#define lane_reg_end {repeat(@L_REG, <)}

#define lane_ptr @lane(@L_POINTER)
#define lane_ptr_end {repeat(@L_POINTER, <)}

#define lane_sA @lane(@L_SCRATCH_A)
#define lane_sA_end {repeat(@L_SCRATCH_A, <)}
#define lane_sB @lane(@L_SCRATCH_B)
#define lane_sB_end {repeat(@L_SCRATCH_B, <)}

#define fastlane @nextword <
#define fastlane_end > @prevword

#define goto_nonzero_left +[<[>-]>[-<+>]<]<
#define goto_nonzero_right +[>[<-]<[->+<]>]>

#define gtnzll(n) +[@left(n)[@right(n)-]@right(n)[-@left(n)+@right(n)]@left(n)]@left(n)
#define gtnzrl(n) +[@right(n)[@left(n)-]@left(n)[-@right(n)+@left(n)]@right(n)]@right(n)

#define gtzll(n) [@left(n)]
#define gtzrl(n) [@right(n)]

#define goto_nonzero_left_lane @gtnzll(@LANES_COUNT)
#define goto_nonzero_right_lane @gtnzrl(@LANES_COUNT)

#define goto_zero_left_lane @gtzll(@LANES_COUNT)
#define goto_zero_right_lane @gtzrl(@LANES_COUNT)

#define clear_to_zero_left_lane [-@left(@LANES_COUNT)]

// MARK: -- Movement Helpers

#define fillword(type, value, ftl) + @lane_value @set(value) >@set(type)< @lane_value_end @fastlane @set(ftl) @fastlane_end @nextword

#define move_to(dest, source) [-dest+source]dest

#define move_l @move_to(@prevword, @nextword)
#define move_r @move_to(@nextword, @prevword)

#define move_l_n(n) @move_to(@prevwords(n), @nextwords(n))
#define move_r_n(n) @move_to(@nextwords(n), @prevwords(n))

#define goto_start_slow @goto_nonzero_left_lane
#define goto_start @fastlane @goto_zero_left_lane @fastlane_end

// To make sure it always works: go to start, and then go to IP from the left
#define goto_ip_word @goto_start @nextword @fastlane @goto_zero_right_lane @fastlane_end
#define goto_ip_left @fastlane @goto_nonzero_left_lane @nextword @fastlane_end

// MARK: -- IP movement

// Requires to be on IP
#define move_ip_next_command {
  //@prevwords(@CMD_SIZE) @fastlane [-@nextword] @goto_nonzero_left_lane @fastlane_end
  @fastlane {repeat(@CMD_SIZE, +@nextword)} @fastlane_end @prevword
}

// so now the only thing we need to do to achieve relative IP jumps is to
// create a macro jp

// MARK: -- PTR ops

#define ptr_end {
  @lane_ptr
    @goto_zero_right_lane
  @lane_ptr_end
}

#define ptr_start {
  @lane_ptr
    @goto_zero_left_lane
  @lane_ptr_end
}

#define ptr_cleanup {
  @lane_ptr
    @goto_zero_right_lane
    @prevword
    [-@prevword]
  @lane_ptr_end
}

// MARK: -- Registers Movement
#define goto_R0 @goto_start @lane_reg
#define goto_PC @goto_start @lane_reg {repeat(@PC, @nextword)}
#define goto_PCB @goto_start @lane_reg {repeat(@PCB, @nextword)}
#define goto_RA @goto_start @lane_reg {repeat(@RA, @nextword)}
#define goto_RAB @goto_start @lane_reg {repeat(@RAB, @nextword)}
#define goto_R3 @goto_start @lane_reg {repeat(@R3, @nextword)}
#define goto_R4 @goto_start @lane_reg {repeat(@R4, @nextword)}
#define goto_R5 @goto_start @lane_reg {repeat(@R5, @nextword)}
#define goto_R6 @goto_start @lane_reg {repeat(@R6, @nextword)}
#define goto_R7 @goto_start @lane_reg {repeat(@R7, @nextword)}

#define copy_pc_ra {
  @copy_reg_to_A_via_B

  @nextwords(2)
  @lane_reg @clear @lane_reg_end
  @prevwords(2)

  @lane_sA
  @while -
    @lane_sA_end
    @nextwords(2)
    @lane_reg
    +
    @lane_reg_end
    @prevwords(2)
    @lane_sA
  @endwhile
  @lane_sA_end
}

// MARK: -- Scratch ops
#define copy_to_A [->>+>+<<<] >>> [-<<<+>>>] <<<
#define copy_to_B [->>+>+<<<] >> [-<<+>>] <<
#define copy_to_A_via_next_B [->>+>@nextword+<<<@prevword] >>>@nextword [-<<<@prevword+>>>@nextword] <<<@prevword

#define copy_value_to_A @lane_value @copy_to_A @lane_value_end
#define copy_value_to_A_via_next_B @lane_value @copy_to_A_via_next_B @lane_value_end

#define copy_reg_to_A_via_B @lane_reg [->>>>+>+<<<<<] >>>>> [-<<<<<+>>>>>] <<<<< @lane_reg_end

// MARK: -- Registers fetch
#define mark_register(offs) {
  @lane_sA
  [-
    @lane_sA_end
    @goto_start

    @nextword

    @lane_ptr
    [@nextword]+
    @lane_ptr_end

    @goto_start
    @nextword

    @goto_ip_word
    offs
    @lane_sA
  ]
  @lane_sA_end
}

#define goto_marked_register {
    @goto_start
    @nextword
    @ptr_end
}

#define move_register_to_ip_sA(offs) {
    @lane_reg
      [->>>>+>+@nextword+@prevword<<<<<]>>>>>@nextword[-@prevword<<<<<+>>>>>@nextword]@prevword<<<<<
    @lane_reg_end
    @lane_sA
    [-
      @lane_sA_end
      @goto_start
      @nextword
      @goto_ip_word

      offs
      @lane_sA
      +
      @lane_sA_end
      @lane_sB
      @goto_nonzero_left_lane <
    ]
    @lane_sA_end
}


#define fetch_from_register(offs_from_ip) {
    offs_from_ip
    @copy_value_to_A
    @mark_register(offs_from_ip)
    @goto_marked_register
    @move_register_to_ip_sA(offs_from_ip)
    @fetch_register_cleanup
}

#define fetch_register_cleanup {
    @lane_sB
    @clear
    @lane_sB_end
    @goto_start
    @nextword
    @ptr_cleanup
    @nextword
    @goto_ip_word
}

#define clear_and_mark_destination_register {
    @prevword
    @copy_value_to_A
    @mark_register(@prevword)
    @goto_marked_register
    @lane_reg
    @clear
    @lane_reg_end
    @goto_ip_word
}

#define move_result_to_destination_register {
    @lane_sB
    @while
      -
      @lane_sB_end
      @prevword
      @goto_marked_register
      @lane_reg
      +
      @lane_reg_end
      @goto_ip_word
      @lane_sB
    @endwhile
    @lane_sB_end
}

#define reset_register_mark {
    @prevword

    @goto_start
    @nextword

    @ptr_cleanup
    @nextword
    @goto_ip_word
}


// MARK: -- simple_register_op

#define two_registers_op(op) {
    @fetch_from_register(@prevword @prevword)
    @fetch_from_register(@prevword @prevword @prevword)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

#define two_registers_op_no_set(op) {
    @fetch_from_register(@prevword @prevword)
    @fetch_from_register(@prevword @prevword @prevword)
    op
}

#define one_register_op(op) {
    @fetch_from_register(@prevwords(2))
    // Load immediate
    @prevwords(3)
    @copy_value_to_A
    @nextwords(3)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

#define no_register_op(op) {
    // Load immediate
    @prevwords(2)
    @copy_value_to_A
    @nextwords(2)
    op
    @clear_and_mark_destination_register
    @move_result_to_destination_register
    @reset_register_mark
}

// MARK: ------------ ALU ops ------------
// Result is stored in sB of the IP word

#define alu_add {
    @prevword @prevword @prevword
    @lane_sA
    @move_r_n(2)
    [->+<]
    >
    @move_r
    <
    @lane_sA_end
}

#define alu_sub {
    @prevword @prevword @prevword
    @lane_sA
    [@nextword-@prevword>+<-]
    >[<+>-]<
    @clear
    @nextword
    @move_r
    @nextword
    @clear
    @prevword
    @move_r
    [->+<]
    @lane_sA_end
}

#define _alu_bin(binop) {
  @prevwords(3)
  @lane_sA
  @move_to(@nextwords(3), @prevwords(3))
  @prevwords(2)
  @move_to(@nextwords(2) >, < @prevwords(2)) <
  @lane_sA_end
  @dec2bin(@sA)
  @dec2bin(@sB)
  @nextwords(9)
  @prefill_fastlane(15)
  @nextword
  @goto_zero_right_lane
  @set(1)
  [
  binop
  @prevword
  ]
  @prevwords(9)
  @bin2dec
  @lane_sA
  [->+<]
  @lane_sA_end
}

#define alu_and @_alu_bin(@bit_and)
#define alu_or @_alu_bin(@bit_or)
#define alu_xor @_alu_bin(@bit_xor)

#define setup_alu_shift {
  @lane_sA
  @prevwords(2)
  @move_to(@nextwords(2),  @prevwords(2))
  @lane_sA_end
  @dec2bin(@sA)
  @prevwords(3)
  @lane_sA
  @move_to(@nextwords(3), @prevwords(3))
  @lane_sA_end
}

#define alu_sl {
  @setup_alu_shift

  @lane_sA
  [-
    @lane_sA_end
    @nextwords(9)
    @prefill_fastlane(16) // Yes, 16 to capture the LSB

    @nextword
    [
      -

      @lane_sA
      @move_l
      @nextword
      @lane_sA_end

      @nextword
    ]

    @goto_ip_left
    @lane_sA
  ]
  @lane_sA_end

  @lane_sA
  @nextwords(9)
  @clear
  @prevwords(9)
  @lane_sA_end

  @bin2dec

  @lane_sA
  [->+<]
  @lane_sA_end
}

#define alu_sr {
  @setup_alu_shift

  @lane_sA
  [-
    @lane_sA_end
    @nextwords(9)
    @prefill_fastlane(16) // Yes, 16 to capture the LSB
    @nextword
    @goto_zero_right_lane

    @prevword
    [
      -

      @lane_sA
      @move_r
      @prevword
      @lane_sA_end

      @prevword
    ]

    @goto_ip_left
    @lane_sA
  ]
  @lane_sA_end

  @lane_sA
  @nextwords(26)
  @clear
  @prevwords(26)
  @lane_sA_end

  @bin2dec

  @lane_sA
  [->+<]
  @lane_sA_end
}

#define _alu_slt_different_sign {
  // If the sign is different, then we just move rs's sign to the result cell
  @lane_sA
  @prevword

  @move_to(@prevwords(8) >, < @nextwords(8))
  <
  @nextwords(8)
  @lane_sA_end
}

#define _alu_slt_same_sign {
  @lane_sA
  @nextwords(2)
  // Clean the old binary representations
  {repeat(16, @clear @nextword)}
  >
  {repeat(16, @clear @prevword)}
  <
  @prevwords(2)

  @prevwords(10)

  @move_r
  @prevword >
  @move_r <
  @lane_sA_end

  @_cmp_unsigned_lt

  @lane_sA
  [->+<]

  @nextwords(8)
  @lane_sA_end
}

#define alu_slt {

  @prevwords(2)
  @lane_sA

  [-@nextword+@nextword+@prevwords(2)]@nextwords(2)

  @prevwords(3)
  [->+<]>
  [-@nextwords(2)+@nextword+@prevwords(3)]@nextwords(3)
  @lane_sB_end

  @dec2bin(@sA)

  @dec2bin(@sB)

  @nextwords(10)
  @lane_sA

  [-@prevword+@prevword+@prevword+@nextwords(3)] @prevwords(3) @move_to(@nextwords(3), @prevwords(3))
  >
  [-@prevword+@prevword+@prevword+@nextwords(3)] @prevwords(3) @move_to(@nextwords(3), @prevwords(3))
  <

  @prevwords(1)

  [->+<]
  >+

  @switch(3, @default, @lane_sB_end, @lane_sB)
  @case(3, @_alu_slt_same_sign, @lane_sB_end, @lane_sB)
  @case(2, @_alu_slt_different_sign, @lane_sB_end, @lane_sB) // When signs are different, the one with 0 is bigger. We can just copy the sign of the second operand
  @case(1, @_alu_slt_same_sign, @lane_sB_end, @lane_sB)

  @prevwords(8)
  @lane_sB_end

  // Cleanup
  @prevword
  @lane_sA
  @clear > @clear <
  @lane_sA_end
  @nextword

  @lane_sA
  @nextwords(8)
  {repeat(18, @clear >)}
  >
  {repeat(18, @clear <)}
  <
  @prevwords(8)
  @lane_sA_end
}

#define alu_sltu {
  @lane_sA
  @prevwords(2)
  @move_r_n(2)
  @prevwords(3)
  @move_to(@nextwords(3) >, < @prevwords(3)) <
  @lane_sA_end
  @_cmp_unsigned_lt
  @lane_sA
  [->+<]
  @lane_sA_end
}

// MARK: ---------- ALU ops end ----------

// MARK: ---------- Instructions ---------

#define ins_jal {
  @prevword
  @goto_PCB
  @lane_reg_end

  //@lane_sA
  // pcb is two words after, move to it
  // MARK: Copy PCB to RAB
  @copy_pc_ra

  @nextword

  // MARK: Copy PC to RA
  @copy_pc_ra

  // So this works like two register op.
  // ACTUALLY it needs to also fetch PC and PCB.
  // These two should be initialized to bank 1 and pc 0
  // THEN put PC and PCB into RA and RAB.
  // Both can be just done in place by copy — we know where they are
  // THEN put fetched register values into PC and PCB
  @goto_ip_word
  @prevwords(2)
  @lane_sA // First op param is BANK
  [->+@nextwords(2)+@prevwords(2)<]@nextwords(2)
   // MARK: I feel I did something like this already, check
  @lane_sA_end

  // MARK: Candidate for "set pcb"
  @prevword
  @goto_start
  @goto_PCB @clear
  @lane_reg_end
  @goto_ip_word
  @lane_sB
  [-
    @lane_sB_end
    @prevword
    @goto_start
    @goto_PCB
    +
    @lane_reg_end
    @goto_ip_word
    @lane_sB
  ]
  @lane_sB_end

  @prevwords(3)
  @lane_sA // Second op param is ADDR
  [->+@nextwords(3)+@prevwords(3)<]@nextwords(3)
  @lane_sA_end

  // MARK: Candidate for "set pc"
  @prevword
  @goto_start
  @nextword @goto_PC @clear
  @lane_reg_end
  @goto_ip_word
  @lane_sB
  [-
    @lane_sB_end
    @prevword
    @goto_start
    @nextword @goto_PC
    +
    @lane_reg_end
    @goto_ip_word
    @lane_sB
  ]
  @lane_sB_end
  // THEN update fastlane

  // 1. Copy fastlane to PTR. Now fastlane can be freely changed
  @prevword
  @fastlane
  [
    @fastlane_end
    @lane_ptr
    +
    @lane_ptr_end
    @fastlane
    @prevword
  ]
  @fastlane_end

  @nextword
  @ptr_end

  // Now we want to fill fastlane with REG_ZONE + new PCB * BANK_SIZE * CMD_SIZE + PC
  @prevword
  @fastlane
  [-@prevword]
  @fastlane_end

  @fastlane
  @prefill_fastlane(@REG_ZONE)
  @fastlane_end

  @nextword
  @ptr_end

  @prevword
  @lane_sA
    @set(@BANK_SIZE)
  @lane_sA_end
  @lane_sB
    @set(@CMD_SIZE)
  @lane_sB_end

  @prevword
  @lane_sB // Now we are at a new bank. @nextword has @CMD_SIZE, @nextword < has @BANK_SIZE
    @nop // MARK: HERE WE CAN SWITCH TO ANOTHER BANK, DO WHEN NEEDED!
    @nextword @clear < @clear > @prevword // MARK: Now let's just clear the fuck out
  @lane_sB_end

  @prevword
  @lane_sB
  @nextwords(2)
    @set(@CMD_SIZE)
  @prevwords(2)

  // So now, @CMD_SIZE * PC times we need to :
  @nextwords(2)
  @times // @CMD_SIZE times
    // Copy PC to sA
    @prevwords(2)
    [-<+@nextword+@prevword>]
     <@nextword
    [->@prevword+@nextword<]
    @prevword>

    @times // PC times
      @lane_sB_end
      @ptr_start

      @nextword @fastlane @goto_zero_right_lane + @goto_zero_left_lane @fastlane_end

      @nextword
      @ptr_end
      @prevwords(3)
      @lane_sB

    @endtimes

    <[->+<]>
    @nextwords(2)
  @endtimes

  @prevwords(2)
  @clear
  @nextwords(2)

  @lane_sB_end
  @ptr_start
  @nextword
  @ptr_cleanup
  @nextword
  @goto_ip_word

  @prevword
  @fastlane @clear @fastlane_end // We need 0 in the last fastlane pos
}

// MARK: --------Instructions end --------

// MARK: -- Bin ops
#define bit_and {
  @lane_sA
  [->+<]>+[-<+>]<
  @switch(3, @default, @lane_sA_end, @lane_sA)
  @case(3, @lane_sB @set(1) @lane_sB_end, @lane_sA_end, @lane_sA)
  @case(2, @clear, @lane_sA_end, @lane_sA)
  @case(1, @clear, @lane_sA_end, @lane_sA)
  @lane_sA_end
  @lane_sB
  [-<+>]<
  @lane_sA_end
}

#define bit_or {
  @lane_sA
  [->+<]>+[-<+>]<
  @switch(3, @default, @lane_sA_end, @lane_sA)
  @case(3, @lane_sB @set(1) @lane_sB_end, @lane_sA_end, @lane_sA)
  @case(2, @lane_sB @set(1) @lane_sB_end, @lane_sA_end, @lane_sA)
  @case(1, @clear, @lane_sA_end, @lane_sA)
  @lane_sA_end
  @lane_sB
  [-<+>]<
  @lane_sA_end
}

#define bit_xor {
  @lane_sA
  [->+<]>+[-<+>]<
  @switch(3, @default, @lane_sA_end, @lane_sA)
  @case(3, @clear, @lane_sA_end, @lane_sA)
  @case(2, @lane_sB @set(1) @lane_sB_end, @lane_sA_end, @lane_sA)
  @case(1, @clear, @lane_sA_end, @lane_sA)
  @lane_sA_end
  @lane_sB
  [-<+>]<
  @lane_sA_end
}

#define POWERS_OF_2 {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768}

// MARK: -- Helpers
#define prefill_fastlane(n) @clear {repeat(n, @nextword +)} @prevwords(n)
#define clear_fastlane(n) @clear {repeat(n, @nextword @clear)} @prevwords(n)

#define set_bit_1(lane_start, lane_end) {
    lane_end
    @goto_zero_right_lane
    lane_start
    +
    lane_end
    @prevword
    @clear
    @prevword
    @goto_zero_left_lane
    lane_start
    @nextwords(2)
}

#define set_bit_0(lane_start, lane_end) {
    lane_end
    @goto_zero_right_lane
    @prevword
    @clear
    @prevword
    @goto_zero_left_lane
    lane_start
    @nextwords(2)
}

#define sb0a @set_bit_0(@lane_sA, @lane_sA_end)
#define sb1a @set_bit_1(@lane_sA, @lane_sA_end)

#define sb0b @set_bit_0(@lane_sB, @lane_sB_end)
#define sb1b @set_bit_1(@lane_sB, @lane_sB_end)

#define scratch_lane(n) {if(n, @lane_sA, @lane_sB)}
#define scratch_lane_end(n) {if(n, @lane_sA_end, @lane_sB_end)}

#define sA 1
#define sB 0

#define set_next_bit(lane, bit) {if(lane, {if(bit, @sb1a, @sb0a)}, {if(bit, @sb1b, @sb0b)})}

#define set_and_nextword(v) @set(v) @nextword

#define b2d_add_dec {
  @lane_sB
  [-
    @lane_sB_end
    @set(1)
    @goto_zero_left_lane
    @lane_sA
    @inc(1)
    @lane_sA_end
    @nextword
    @goto_zero_right_lane
    @prevword
    @lane_sB
  ]
  @lane_sB_end
}

#define b2d_skip_bit @lane_sB @clear @lane_sB_end

// Division layout is n, 0, d, 0, 0, 0, 0
// Result layout is >0, n, d-n%d, n%d, n/d
#define divmod [-@nextword+@nextword-[@nextword+@nextwords(2)]@nextword[+[-@prevword+@nextword]@nextword+@nextwords(2)]@prevwords(6)]

// Result will be stored in scratch lane 16 cells starting from current_word + 9
#define dec2bin(sl) {
  @prefill_fastlane(24)
  @scratch_lane(sl)
  [
  @nextwords(2)
  @set(2)
  @prevwords(2)
  @divmod
  @nextword @clear
  @nextword @clear
  @nextword
  +
  @switch(2, @default, @prevword, @nextword)
  @case(2, @set_next_bit(sl, 1), @prevword, @nextword)
  @case(1, @set_next_bit(sl, 0), @prevword, @nextword)
  @nextword
  @move_l_n(4)
  ]
  @scratch_lane_end(sl)
  @clear_fastlane(24)
}

#define b2d_setup {
  @prefill_fastlane(24)
  @nextwords(10)
  @scratch_lane(@sB)
  {for(v in {reverse(@POWERS_OF_2)}, @set_and_nextword(v))}
  @prevword
  @scratch_lane_end(@sB)
}

#define b2d_cleanup @goto_zero_left_lane @clear_fastlane(24)

// bin2dec requires binary value to be in sA, and uses sB and lane 0 as helper lanes
#define bin2dec {
  @b2d_setup
  @scratch_lane(@sB)
  @while
    @prev(1)
    @inc(1)
    @switch(2, @default, @scratch_lane_end(@sA), @scratch_lane(@sA))
      @case(2, @b2d_add_dec, @scratch_lane_end(@sA), @scratch_lane(@sA))
      @case(1, @b2d_skip_bit, @scratch_lane_end(@sA), @scratch_lane(@sA))
    @prevword
    @next(1)
  @endwhile
  @scratch_lane_end(@sB)
  @b2d_cleanup
}

// TODO: NEVER! NEVER CALL THIS ONE DIRECTLY WITHOUT
// CHECKING THAT B IS 0!
#define _cmp_unsigned_neq_lt {
  <
  @nextword
  @move_r_n(4)
  @prevwords(4)
  >[-<+>]<

  @move_r_n(3)
  // Careful here — this will never run if b is 0.
  [-[@nextword-[@prevword @prevword-@prevword]@prevword[-]@nextwords(2)+@nextword @prevwords(3)]@nextword @clear @nextwords(2)]
  @prevword @move_l_n(5)

  @prevword
  >
}

#define _cmp_unsigned_lt {
// Requires [0, 0, 0, b, a, 0, 0]
  @lane_sA

  // If one of them is zero, then the other one is zero too.
  // So we can just gtfo.
  // Let's copy b to scratch
  >
  [-@prevword+@prevword+@nextwords(2)] @prevwords(2) @move_r_n(2)
  <
  @prevword

  [->-<]+>[<->[-]]< // What the fuck is this sorcery?
  +
  // Now, if b was equal to 0, we stand at 2. Otherwise at 1.
  @switch(2, @default, >, <)
    @case(2, @nextword @clear < @clear > @prevword, >, <) // Both were 0, gtfo
    @case(1, @_cmp_unsigned_neq_lt, >, <) // They were not, compare
  @nextword

  @lane_sA_end
}

// MARK: ------ Opcode Handlers ---------

#define add  @lane_sB_end @two_registers_op(@alu_add ) @lane_sB
#define sub  @lane_sB_end @two_registers_op(@alu_sub ) @lane_sB
#define and  @lane_sB_end @two_registers_op(@alu_and ) @lane_sB
#define or   @lane_sB_end @two_registers_op(@alu_or  ) @lane_sB
#define xor  @lane_sB_end @two_registers_op(@alu_xor ) @lane_sB
#define sl   @lane_sB_end @two_registers_op(@alu_sl  ) @lane_sB
#define sr   @lane_sB_end @two_registers_op(@alu_sr  ) @lane_sB
#define slt  @lane_sB_end @two_registers_op(@alu_slt ) @lane_sB
#define sltu @lane_sB_end @two_registers_op(@alu_sltu) @lane_sB

#define addi @lane_sB_end @one_register_op(@alu_add  ) @lane_sB
#define andi @lane_sB_end @one_register_op(@alu_and  ) @lane_sB
#define ori  @lane_sB_end @one_register_op(@alu_or   ) @lane_sB
#define xori @lane_sB_end @one_register_op(@alu_xor  ) @lane_sB
#define li   @lane_sB_end @no_register_op( @alu_or   ) @lane_sB
#define sli  @lane_sB_end @one_register_op(@alu_sl   ) @lane_sB
#define sri  @lane_sB_end @one_register_op(@alu_sr   ) @lane_sB

#define load @lane_sB_end @one_register_op(@nop  ) @lane_sB
#define stor @lane_sB_end @one_register_op(@nop   ) @lane_sB

#define j    $ @lane_sB_end @one_register_op(@nop   ) @lane_sB
#define jal  @lane_sB_end @two_registers_op_no_set(@ins_jal ) @lane_sB

// MARK: ------------ MAIN ---------------
// Set START marker
@set(@STATE_RUNNING)

// MARK: -- Set registers
@nextword
@nextword
#define REG_VALUES {1,0,3,4,5,6,0,2,9,10}
@lane_reg
  {for(v in @REG_VALUES, @set(v) @nextword)}
@lane_reg_end

@goto_start_slow

// MARK: -- Program code
@fillword(@T_OP, @OP_HALT, 0) // First op should always be halt

// ALWAYS go past the registers.
{repeat(@REG_ZONE, @fillword(@T_OP, @OP_NOP, 1))}

@fillword(@T_VAL, @R6, 1) // rt
@fillword(@T_VAL, @R5, 1) // rs
@fillword(@T_VAL, @R0, 1) // rd
@fillword(@T_OP,  @OP_JAL, 0)

@fillword(@T_VAL, 1, 0) // rt
@fillword(@T_VAL, @R6, 0) // rs
@fillword(@T_VAL, @R5, 0) // rd
@fillword(@T_OP,  @OP_SRI, 0)

@fillword(@T_OP, @OP_NOP, 0)
@fillword(@T_OP, @OP_NOP, 0)
@fillword(@T_OP, @OP_NOP, 0)
@fillword(@T_OP, @OP_HALT, 0)

//@fillword(@T_VAL, @R4, 1) // rt
//@fillword(@T_VAL, @R3, 1) // rs
//@fillword(@T_VAL, @R3, 1) // rd
//@fillword(@T_OP, @OP_SUB, 1)

//@fillword(@T_VAL, @R4, 1) // rt
//@fillword(@T_VAL, @R3, 1) // rs
//@fillword(@T_VAL, @R3, 1) // rd
//@fillword(@T_OP,  @OP_XOR, 0)

// MARK: -- Program code end

@prevword
@clear_to_zero_left_lane
@nextword

// MARK: -- Main loop
@while
[->+>+<<]>>[-<<+>>]<< // Copy start flag to >, so switch does not fuck up our start marker
  >
  @switch(2, @default, >, <)
  @case(@STATE_RUNNING, <<@execute>>, >, <)
  @case(@STATE_HALT, @clear <<@clear>>, >, <)
  <
@endwhile

// MARK: ---- Executor
#define execute {
  @nextword

  @goto_ip_word
  @lane_value // Now we are at the opcode
  @copy_to_A
  @lane_value_end
  @lane_sA
  @inc(1) // To properly work with switch statement

  // MARK: ------- Opcode Switch
  @switch(21, @default, >, <)
    @case(21, @jal, >, <)
    @case(20, @j, >, <)

    @case(19, @stor, >, <)
    @case(18, @load, >, <)

    @case(17, @sri, >, <)
    @case(16, @sli, >, <)
    @case(15, @li, >, <)
    @case(14, @xori, >, <)
    @case(13, @ori, >, <)
    @case(12, @andi, >, <)
    @case(11, @addi, >, <)
    @case(10, @sltu, >, <)
    @case(9,  @slt, >, <)
    @case(8,  @sr, >, <)
    @case(7,  @sl, >, <)
    @case(6,  @xor, >, <)
    @case(5,  @or, >, <)
    @case(4,  @and, >, <)
    @case(3,  @sub, >, <)
    @case(2,  @add, >, <)
    @case(1,  @lane_sB_end @prevword @goto_start @set(@STATE_HALT) @goto_ip_word @lane_sB, >, <)

  @lane_sA_end
  @move_ip_next_command

  @goto_start
}

