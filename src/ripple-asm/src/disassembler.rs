use crate::types::{Instruction, Opcode, InstructionFormat};
use std::collections::HashMap;
use crate::Register;

pub struct Disassembler {
    labels: HashMap<u32, String>,
    next_label_id: usize,
}

impl Disassembler {
    pub fn new() -> Self {
        Self {
            labels: HashMap::new(),
            next_label_id: 0,
        }
    }

    pub fn disassemble_binary(&mut self, binary: &[u8]) -> Result<String, String> {
        // Check magic number
        if binary.len() < 5 {
            return Err("Invalid binary: too short".to_string());
        }
        
        let mut offset = 0;
        let mut instruction_count = 0;
        
        // Detect format by magic number
        if &binary[0..4] == b"RASM" {
            // RASM format from assembler
            offset = 4;
            
            // Read version
            if binary.len() < offset + 4 {
                return Err("Invalid binary: missing version".to_string());
            }
            let _version = u32::from_le_bytes([
                binary[offset], binary[offset + 1], 
                binary[offset + 2], binary[offset + 3]
            ]);
            offset += 4;
            
            // Read instruction count
            if binary.len() < offset + 4 {
                return Err("Invalid binary: missing instruction count".to_string());
            }
            instruction_count = u32::from_le_bytes([
                binary[offset], binary[offset + 1],
                binary[offset + 2], binary[offset + 3]
            ]) as usize;
            offset += 4;
        } else if &binary[0..5] == b"RLINK" {
            // RLINK format from linker
            offset = 5;
            
            // Skip entry point (4 bytes)
            if binary.len() < offset + 4 {
                return Err("Invalid binary: missing entry point".to_string());
            }
            offset += 4;
            
            // Read instruction count
            if binary.len() < offset + 4 {
                return Err("Invalid binary: missing instruction count".to_string());
            }
            instruction_count = u32::from_le_bytes([
                binary[offset], binary[offset + 1],
                binary[offset + 2], binary[offset + 3]
            ]) as usize;
            offset += 4;
        } else {
            return Err("Invalid binary format: unknown magic number".to_string());
        }

        // Read instructions
        let mut instructions = Vec::new();
        for _ in 0..instruction_count {
            if binary.len() < offset + 8 {
                return Err("Invalid binary: incomplete instruction data".to_string());
            }
            
            let opcode = binary[offset];
            let _word0 = binary[offset + 1];
            let word1 = u16::from_le_bytes([binary[offset + 2], binary[offset + 3]]);
            let word2 = u16::from_le_bytes([binary[offset + 4], binary[offset + 5]]);
            let word3 = u16::from_le_bytes([binary[offset + 6], binary[offset + 7]]);
            
            instructions.push(Instruction {
                opcode,
                word0: opcode,
                word1,
                word2,
                word3,
            });
            
            offset += 8;
        }

        // Read data section size
        if binary.len() < offset + 4 {
            return Err("Invalid binary: missing data section size".to_string());
        }
        let data_size = u32::from_le_bytes([
            binary[offset], binary[offset + 1],
            binary[offset + 2], binary[offset + 3]
        ]) as usize;
        offset += 4;

        // Read data section
        let mut data = Vec::new();
        if data_size > 0 {
            if binary.len() < offset + data_size {
                return Err("Invalid binary: incomplete data section".to_string());
            }
            data.extend_from_slice(&binary[offset..offset + data_size]);
        }

        // First pass: collect labels for jumps and branches
        self.collect_labels(&instructions);

        // Second pass: generate assembly
        let mut output = String::new();
        
        // Add header comment
        output.push_str("; Disassembled from binary\n");
        output.push_str("; Generated by rasm --disassemble\n\n");

        // Add code section
        output.push_str(".code\n");
        
        for (idx, inst) in instructions.iter().enumerate() {
            // Check if this instruction is a label target
            if let Some(label) = self.labels.get(&(idx as u32)) {
                output.push_str(&format!("{}:\n", label));
            }
            
            // Disassemble the instruction
            let line = self.disassemble_instruction(inst, idx)?;
            output.push_str(&format!("    {}\n", line));
        }
        
        // Check if we need to add a label after the last instruction
        let last_idx = instructions.len() as u32;
        if let Some(label) = self.labels.get(&last_idx) {
            output.push_str(&format!("{}:\n", label));
        }

        // Add data section if not empty
        if !data.is_empty() {
            output.push_str("\n.data\n");
            output.push_str(&self.format_data_section(&data));
        }

        Ok(output)
    }

    fn collect_labels(&mut self, instructions: &[Instruction]) {
        for (idx, inst) in instructions.iter().enumerate() {
            if let Some(opcode) = self.opcode_from_byte(inst.opcode) {
                match opcode {
                    Opcode::Jal => {
                        // JAL uses absolute addressing
                        let target = ((inst.word2 as u32) << 16) | (inst.word3 as u32);
                        if !self.labels.contains_key(&target) {
                            let label = format!("L_{:04X}", target);
                            self.labels.insert(target, label);
                        }
                    }
                    Opcode::Beq | Opcode::Bne | Opcode::Blt | Opcode::Bge => {
                        // Branches use relative addressing
                        let offset = inst.word3 as i16;
                        let target = ((idx as i32) + (offset as i32)) as u32;
                        if !self.labels.contains_key(&target) {
                            let label = format!("L_{:04X}", target);
                            self.labels.insert(target, label);
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    fn disassemble_instruction(&self, inst: &Instruction, idx: usize) -> Result<String, String> {
        let opcode = self.opcode_from_byte(inst.opcode)
            .ok_or_else(|| format!("Unknown opcode: 0x{:02X}", inst.opcode))?;

        // Check for HALT (NOP with all zeros)
        if inst.is_halt() {
            return Ok("HALT".to_string());
        }

        match opcode.format() {
            InstructionFormat::R => self.disassemble_r_format(opcode, inst),
            InstructionFormat::I => self.disassemble_i_format(opcode, inst, idx),
            InstructionFormat::I1 => self.disassemble_i1_format(opcode, inst),
        }
    }

    fn disassemble_r_format(&self, opcode: Opcode, inst: &Instruction) -> Result<String, String> {
        match opcode {
            Opcode::Nop | Opcode::Brk if inst.word1 == 0 && inst.word2 == 0 && inst.word3 == 0 => {
                Ok(opcode.to_str().to_string())
            }
            Opcode::Jalr => {
                let rd = self.register_name(inst.word1 as u8)?;
                let rs = self.register_name(inst.word2 as u8)?;
                let offset = inst.word3;
                if offset == 0 {
                    Ok(format!("{} {}, {}", opcode.to_str(), rd, rs))
                } else {
                    Ok(format!("{} {}, {}, {}", opcode.to_str(), rd, rs, offset))
                }
            }
            _ => {
                let rd = self.register_name(inst.word1 as u8)?;
                let rs1 = self.register_name(inst.word2 as u8)?;
                let rs2 = self.register_name(inst.word3 as u8)?;
                Ok(format!("{} {}, {}, {}", opcode.to_str(), rd, rs1, rs2))
            }
        }
    }

    fn disassemble_i_format(&self, opcode: Opcode, inst: &Instruction, idx: usize) -> Result<String, String> {
        match opcode {
            Opcode::Load => {
                let rd = self.register_name(inst.word1 as u8)?;
                let bank = self.format_operand(inst.word2);
                let addr = self.format_operand(inst.word3);
                Ok(format!("{} {}, {}, {}", opcode.to_str(), rd, bank, addr))
            }
            Opcode::Store => {
                let rs = self.register_name(inst.word1 as u8)?;
                let bank = self.format_operand(inst.word2);
                let addr = self.format_operand(inst.word3);
                Ok(format!("{} {}, {}, {}", opcode.to_str(), rs, bank, addr))
            }
            Opcode::Jal => {
                let rd = self.register_name(inst.word1 as u8)?;
                let target = ((inst.word2 as u32) << 16) | (inst.word3 as u32);
                
                if let Some(label) = self.labels.get(&target) {
                    Ok(format!("{} {}, {}", opcode.to_str(), rd, label))
                } else {
                    Ok(format!("{} {}, 0x{:X}", opcode.to_str(), rd, target))
                }
            }
            Opcode::Beq | Opcode::Bne | Opcode::Blt | Opcode::Bge => {
                let rs1 = self.register_name(inst.word1 as u8)?;
                let rs2 = self.register_name(inst.word2 as u8)?;
                let offset = inst.word3 as i16;
                let target = ((idx as i32) + (offset as i32)) as u32;
                
                if let Some(label) = self.labels.get(&target) {
                    Ok(format!("{} {}, {}, {}", opcode.to_str(), rs1, rs2, label))
                } else {
                    Ok(format!("{} {}, {}, {}", opcode.to_str(), rs1, rs2, offset))
                }
            }
            _ => {
                let rd = self.register_name(inst.word1 as u8)?;
                let rs = self.register_name(inst.word2 as u8)?;
                let imm = self.format_immediate(inst.word3);
                Ok(format!("{} {}, {}, {}", opcode.to_str(), rd, rs, imm))
            }
        }
    }

    fn disassemble_i1_format(&self, opcode: Opcode, inst: &Instruction) -> Result<String, String> {
        let rd = self.register_name(inst.word1 as u8)?;
        
        if inst.word3 == 0 {
            // Simple immediate
            let imm = self.format_immediate(inst.word2);
            Ok(format!("{} {}, {}", opcode.to_str(), rd, imm))
        } else {
            // Large immediate (high and low parts)
            let imm_high = self.format_immediate(inst.word2);
            let imm_low = self.format_immediate(inst.word3);
            Ok(format!("{} {}, {}, {}", opcode.to_str(), rd, imm_high, imm_low))
        }
    }

    fn format_operand(&self, value: u16) -> String {
        // Check if it's a register value
        if value < 18 {
            if let Ok(reg) = self.register_name(value as u8) {
                return reg;
            }
        }
        // Otherwise format as immediate
        self.format_immediate(value)
    }

    fn format_immediate(&self, value: u16) -> String {
        let signed = value as i16;
        if signed < 0 {
            format!("{}", signed)
        } else if value > 9 {
            format!("0x{:X}", value)
        } else {
            format!("{}", value)
        }
    }

    fn register_name(&self, reg: u8) -> Result<String, String> {
        let name = Register::from_u8(reg)
            .map(|r| r.to_string());

        name.ok_or_else(|| format!("Invalid register: {}", reg))
    }

    fn opcode_from_byte(&self, byte: u8) -> Option<Opcode> {
        match byte {
            0x00 => Some(Opcode::Nop),
            0x01 => Some(Opcode::Add),
            0x02 => Some(Opcode::Sub),
            0x03 => Some(Opcode::And),
            0x04 => Some(Opcode::Or),
            0x05 => Some(Opcode::Xor),
            0x06 => Some(Opcode::Sll),
            0x07 => Some(Opcode::Srl),
            0x08 => Some(Opcode::Slt),
            0x09 => Some(Opcode::Sltu),
            0x0A => Some(Opcode::Addi),
            0x0B => Some(Opcode::Andi),
            0x0C => Some(Opcode::Ori),
            0x0D => Some(Opcode::Xori),
            0x0E => Some(Opcode::Li),
            0x0F => Some(Opcode::Slli),
            0x10 => Some(Opcode::Srli),
            0x11 => Some(Opcode::Load),
            0x12 => Some(Opcode::Store),
            0x13 => Some(Opcode::Jal),
            0x14 => Some(Opcode::Jalr),
            0x15 => Some(Opcode::Beq),
            0x16 => Some(Opcode::Bne),
            0x17 => Some(Opcode::Blt),
            0x18 => Some(Opcode::Bge),
            0x19 => Some(Opcode::Brk),
            0x1A => Some(Opcode::Mul),
            0x1B => Some(Opcode::Div),
            0x1C => Some(Opcode::Mod),
            0x1D => Some(Opcode::Muli),
            0x1E => Some(Opcode::Divi),
            0x1F => Some(Opcode::Modi),
            _ => None,
        }
    }

    fn format_data_section(&self, data: &[u8]) -> String {
        let mut output = String::new();
        let mut i = 0;
        
        while i < data.len() {
            // Try to detect strings
            let mut string_end = i;
            while string_end < data.len() && data[string_end] >= 0x20 && data[string_end] < 0x7F {
                string_end += 1;
            }
            
            if string_end > i + 3 {
                // Found a string of at least 4 printable characters
                let string = String::from_utf8_lossy(&data[i..string_end]);
                
                // Check if null-terminated
                if string_end < data.len() && data[string_end] == 0 {
                    output.push_str(&format!("    .asciiz \"{}\"\n", string));
                    i = string_end + 1;
                } else {
                    output.push_str(&format!("    .string \"{}\"\n", string));
                    i = string_end;
                }
            } else {
                // Output as bytes
                let mut bytes = Vec::new();
                let mut j = i;
                while j < data.len() && j < i + 16 {
                    // Stop if we hit printable characters
                    if j > i && data[j] >= 0x20 && data[j] < 0x7F {
                        let mut check = j;
                        while check < data.len() && data[check] >= 0x20 && data[check] < 0x7F {
                            check += 1;
                        }
                        if check - j > 3 {
                            break;
                        }
                    }
                    bytes.push(format!("0x{:02X}", data[j]));
                    j += 1;
                }
                
                if !bytes.is_empty() {
                    output.push_str(&format!("    .byte {}\n", bytes.join(", ")));
                    i = j;
                }
            }
        }
        
        output
    }
}