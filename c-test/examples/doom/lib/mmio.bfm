#pragma once

#define HDR_TTY_OUT         0x0
#define HDR_TTY_STATUS      0x1
#define HDR_TTY_IN_POP      0x2
#define HDR_TTY_IN_STATUS   0x3
#define HDR_RNG             0x4
#define HDR_RNG_SEED        0x5
#define HDR_DISP_MODE       0x6
#define HDR_DISP_STATUS     0x7
#define HDR_DISP_CTL        0x8
#define HDR_DISP_FLUSH      0x9
#define HDR_KEY_UP          0xA
#define HDR_KEY_DOWN        0xB
#define HDR_KEY_LEFT        0xC
#define HDR_KEY_RIGHT       0xD
#define HDR_KEY_Z           0xE
#define HDR_KEY_X           0xF
#define HDR_DISP_RESOLUTION 0x10
#define HDR_STORE_BLOCK     0x11
#define HDR_STORE_ADDR      0x12
#define HDR_STORE_DATA      0x13
#define HDR_STORE_CTL       0x14

#define STORE_CTL_BUSY        0x1
#define STORE_CTL_DIRTY       0x2
#define STORE_CTL_COMMIT      0x4
#define STORE_CTL_COMMIT_ALL  0x8

#define DISP_MODE_OFF    0
#define DISP_MODE_TTY    1
#define DISP_MODE_TEXT40 2
#define DISP_MODE_RGB565 3

#define DISP_CTL_ENABLE 1
#define DISP_CTL_CLEAR  2

#define DISP_STATUS_READY      1
#define DISP_STATUS_FLUSH_DONE 2

#define mmio_write(value, pin) @poke_imm(value, r0, pin)
#define mmio_read(set, pin)    @peek_imm(set,   r0, pin)

#define mmio_write_r(reg, pin) @poke(reg, r0, pin)
#define mmio_read_r(reg, pin)  @peek(reg, r0, pin)

@leaf(storage_set_block,
  @mmio_write(@arg1, #HDR_STORE_BLOCK)
)
@leaf(storage_set_addr,
  @mmio_write(@arg1, #HDR_STORE_ADDR)
)

@proc(storage_read,
  @mmio_read(rv0, #HDR_STORE_DATA)
  @retval(rv0, r0)
)

@proc(storage_get_status,
  @mmio_read(rv0, #HDR_STORE_CTL)
)

@leaf(storage_write,
  @mmio_write(@arg1, #HDR_STORE_DATA)
)

@proc(storage_commit,
  @set(sc, #STORE_CTL_COMMIT)
  @mmio_write(sc, #HDR_STORE_CTL)
)

@proc(storage_commit_all,
  @set(sc, #STORE_CTL_COMMIT_ALL)
  @mmio_write(sc, #HDR_STORE_CTL)
)

@leaf(storage_write_at,
  @call1(storage_set_block, @reg, @arg1)
  @call1(storage_set_addr, @reg, @arg2)
  @call1(storage_write, @reg, @arg3)
)

@proc(storage_read_at,
  @call1(storage_set_block, @reg, @arg1)
  @call1(storage_set_addr, @reg, @arg2)
  @call(storage_read)
  @retval(rv0, r0)
)

@proc(storage_read_at_le_unpack,
  @call1(storage_set_block, @reg, @arg1)
  @call1(storage_set_addr, @reg, @arg2)
  @call(storage_read)
  
  @andi(rv1, rv0, 0xFF00)
  @srli(rv1, rv1, 8)
  @andi(rv0, rv0, 0x00FF)

  @retval(rv0, rv1)
)

#define WORD_FROM_LE(t_lo, t_hi, dst) {           
  @andi(t_lo, rv0, 0x00FF)
  @srli(t_hi, rv0, 8)
  @andi(t_hi, t_hi, 0x00FF)
  @slli(t_hi, t_hi, 8)
  @or(dst, t_lo, t_hi)
}

@proc(storage_read_u16_le,
  @mov(s0, @arg1)
  @mov(s1, @arg2)
  @set(s2, 0)

  @let(s2, @read_byte(s0, s1))

  @inc(s1)
  @read_byte(s0, s1)
  
  @slli(rv0, rv0, 8)
  @or(s2, s2, rv0)

  @retval(s2, r0)
)

@proc(storage_read_u32_le,
  @mov(s0, @arg1)
  @mov(s1, @arg2)
  @set(s2, 0)
  @set(s3, 0)

  @let(s2, @read_u16(s0, s1))
  @addi(s1, s1, 2)
  @let(s3, @read_u16(s0, s1))

  @retval(s3, s2)
)

#define read_byte(block, addr) @call2(storage_read_at, @reg, s0, @reg, s1)
#define read_u16(block, addr) @call2(storage_read_u16_le, @reg, block, @reg, addr)

// Graphix

@leaf(graphics_flush,
  @set(sc, 1)
  @mmio_write(sc, #HDR_DISP_FLUSH)
)

