#pragma once

#include "crt0.bfm"

#define ASCII_0 48
#define ASCII_A_MINUS_10 55

#define MAX_UINT 65535

#define a(code) code {br}
#define set(reg, val) {:li } reg {:,} val {br}
#define mov(reg, val) {:add } reg {:,} val {:,} r0 {br}
#define sltu(out, reg1, reg2) {:sltu } out, {:, } reg1 {:, } reg2 {br}

#define jmp(label) {:beq r0, r0, } label {br}

#define not(reg) {:xori } reg {:, } reg {:, } 1 {br}

#define addi(reg1, reg2, imm) {:addi } reg1 {:, } reg2 {:, } imm {br}
#define add(reg1, reg2, reg3) {:add } reg1 {:, } reg2 {:, } reg3 {br}

#define divi(out, reg1, imm) {:divi } out {:, } reg1 {:, } imm {br}
#define modi(out, reg1, imm) {:modi } out {:, } reg1 {:, } imm {br}

#define poke(val, bank, addr) {
  {:store } val {:, } bank {:, } addr {br}
}

#define peek(set, bank, addr) {
  {:load } set {:, } bank {:, } addr  {br}
}

#define push(reg)   @poke(reg, sb, sp) @inc(sp)
#define pop(reg)    @dec(sp) @peek(reg, sb, sp)

#define arg1 a0
#define arg2 a1
#define arg3 a2
#define arg4 a3

#define reg 0
#define imm 1

#define while(cond, code) {
  {label loop}:{br}
  cond {:, } {label cont} {br}
  {:beq r0, r0, } {label end} {br}
  {label cont}: {br}
  code {br}
  {:beq r0, r0, } {label loop} {br}
  {label end}: {br}
}

#define ifelse(cond, true_branch, false_branch) {
  {:bne } cond {:, } r0, {label efelsetruebranch} {br}
  {label ifelsefalsebranch}: {br}
  false_branch {br}
  @jmp({label endifelse}){br}
  {label efelsetruebranch}: {br}
  true_branch {br}
  {label endifelse}: {br} 
}

#define if(cond, true_branch) {
  {:bne } cond {:, } r0, {label iftruebranch} {br}
  @jmp({label endif}){br}
  {label iftruebranch}: {br}
  true_branch {br}
  {label endif}: {br} 
}

#define ne(reg1, reg2) {:bne } reg1 {:, } reg2
#define eq(reg1, reg2) {:beq } reg1 {:, } reg2
#define lt(reg1, reg2) {:blt } reg1 {:, } reg2
#define ge(reg1, reg2) {:bge } reg1 {:, } reg2

#define inc(reg) {:addi } reg {:, } reg {:, } 1 {br}
#define dec(reg) {:addi } reg {:, } reg {:, } -1 {br}

#define setarg(source, arg, dst) {if(source, @set(dst, arg), @mov(dst, arg))}
#define call(func) {:call } func {br}

#define call1(func, source1, arg1) {
  @setarg(source1, arg1, @arg1)
  @call(func)
}

#define call2(func, source1, arg1, source2, arg2) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @call(func)
}

#define call3(func, source1, arg1, source2, arg2, source3, arg3) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @call(func)
}

#define call4(func, source1, arg1, source2, arg2, source3, arg3, source4, arg4) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @setarg(source4, arg4, @arg4)
  @call(func)
}

#define halt {:HALT}
#define ret @a({:jalr rab, rab, ra})
#define retval(reg1, reg2) {
  @mov(rv0, reg1)
  @mov(rv1, reg2)
}

#define prologue(locals) {
  @push(ra)
  @push(fp)
  @push(s0)
  @push(s1)
  @push(s2)
  @push(s3)

  @mov(fp, sp)

  @addi(sp, sp, locals)  
}

#define epilogue(locals) {
  @addi(sp, sp, {:-locals})

  @pop(s3)
  @pop(s2)
  @pop(s1)
  @pop(s0)
  @pop(fp)
  @pop(ra)
  
  @ret
}

#define leaf(name, body) name:{br} body{br} @ret

#define proc(name, body) {
  name:{br}
  @prologue(0)
  body{br}
  @epilogue(0)
}

#define procN(name, locals, body) {
  name:{br}
  @prologue(locals)
  body{br}
  @epilogue(locals)
}

#define ascii(s)  {for(c in s, c{: })}
#define asciiz(s) {for(c in s, c{: })} {:0}

#define local_addr_i(tmp, imm)   @addi(tmp, fp, imm)
#define local_addr_r(tmp, reg)   @add(tmp, fp, reg)

#define local_store_i(imm, src)  @local_addr_i(t0, imm) @poke(src, sb, t0)
#define local_store_r(reg, src)  @local_addr_r(t0, reg) @poke(src, sb, t0)

#define local_load_i(dst, imm)   @local_addr_i(t0, imm) @peek(dst, sb, t0)
#define local_load_r(dst, reg)   @local_addr_r(t0, reg) @peek(dst, sb, t0)

#define local_arr(tmp, idx_reg, offs_reg, s, slen) {
  {for(c, i in s,
    @set(tmp, c)
    @addi(idx_reg, offs_reg, i)
    @local_store_r(idx_reg, tmp)
  )}
  @set(tmp, 0)
  @addi(idx_reg, offs_reg, slen)
  @local_store_r(idx_reg, tmp)
}

@crt0