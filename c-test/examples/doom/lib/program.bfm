#pragma once

#include "crt0.bfm"

#define a(code) code {br}
#define set(reg, val) {:li } reg {:,} val {br}
#define mov(reg, val) {:add } reg {:,} val {:,} r0 {br}

#define poke(val, bank, addr) {
  {:store } val {:, } bank {:, } addr {br}
}

#define peek(set, bank, addr) {
  {:load } set {:, } bank {:, } addr  {br}
}

#define push(reg)   @poke(reg, sb, sp) @inc(sp)
#define pop(reg)    @dec(sp) @peek(reg, sb, sp)

#define arg1 s0
#define arg2 s1
#define arg3 s2
#define arg4 s3

#define reg 0
#define imm 1

#define while(cond, code) {
  {label loop}:{br}
  cond {:, } {label cont} {br}
  {:beq r0, r0, } {label end} {br}
  {label cont}: {br}
  code {br}
  {:beq r0, r0, } {label loop} {br}
  {label end}: {br}
}

#define ne(reg1, reg2) {:bne } reg1 {:, } reg2
#define eq(reg1, reg2) {:beq } reg1 {:, } reg2
#define lt(reg1, reg2) {:blt } reg1 {:, } reg2
#define ge(reg1, reg2) {:bge } reg1 {:, } reg2

#define inc(reg) {:addi } reg {:, } reg {:, } 1 {br}
#define dec(reg) {:addi } reg {:, } reg {:, } -1 {br}

#define setarg(source, arg, dst) {if(source, @set(dst, arg), @mov(dst, arg))}
#define call(func) {:call } func {br}

#define call1(func, source1, arg1) {
  @setarg(source1, arg1, @arg1)
  @call(func)
}

#define call2(func, source1, arg1, source2, arg2) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @call(func)
}

#define call3(func, source1, arg1, source2, arg2, source3, arg3) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @call(func)
}

#define call4(func, source1, arg1, source2, arg2, source3, arg3, source4, arg4) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @setarg(source4, arg4, @arg4)
  @call(func)
}

#define halt {:HALT}
#define ret @a({:jalr rab, rab, ra})
#define retval(reg1, reg2) {
  @mov(rv0, reg1)
  @mov(rv1, reg2)
}

#define prologue {
  @push(ra)
  @push(fp)
  @push(@arg1)
  @push(@arg2)
  @push(@arg3)
  @push(@arg4)

  @mov(fp, sp)
}

#define epilogue {
  @pop(@arg4)
  @pop(@arg3)
  @pop(@arg2)
  @pop(@arg1)
  @pop(fp)
  @pop(ra)
  
  @ret
}

#define leaf(name, body) name:{br} body{br} @ret

#define proc(name, body) {
  name:{br}
  @prologue
  body{br}
  @epilogue
}

#define ascii(s)  {for(c in s, c{: })}
#define asciiz(s) {for(c in s, c{: })} {:0}

@crt0