#pragma once

#include "crt0.bfm"

#define a(code) code {br}
#define set(reg, val) {:li } reg {:,} val {br}
#define mov(reg, val) {:add } reg {:,} val {:,} r0 {br}

#define addi(reg1, reg2, imm) {
  {:addi } reg1 {:, } reg2 {:, } imm {br}
}

#define poke(val, bank, addr) {
  {:store } val {:, } bank {:, } addr {br}
}

#define peek(set, bank, addr) {
  {:load } set {:, } bank {:, } addr  {br}
}

#define push(reg)   @poke(reg, sb, sp) @inc(sp)
#define pop(reg)    @dec(sp) @peek(reg, sb, sp)

#define arg1 a0
#define arg2 a1
#define arg3 a2
#define arg4 a3

#define reg 0
#define imm 1

#define while(cond, code) {
  {label loop}:{br}
  cond {:, } {label cont} {br}
  {:beq r0, r0, } {label end} {br}
  {label cont}: {br}
  code {br}
  {:beq r0, r0, } {label loop} {br}
  {label end}: {br}
}

#define ne(reg1, reg2) {:bne } reg1 {:, } reg2
#define eq(reg1, reg2) {:beq } reg1 {:, } reg2
#define lt(reg1, reg2) {:blt } reg1 {:, } reg2
#define ge(reg1, reg2) {:bge } reg1 {:, } reg2

#define inc(reg) {:addi } reg {:, } reg {:, } 1 {br}
#define dec(reg) {:addi } reg {:, } reg {:, } -1 {br}

#define setarg(source, arg, dst) {if(source, @set(dst, arg), @mov(dst, arg))}
#define call(func) {:call } func {br}

#define call1(func, source1, arg1) {
  @setarg(source1, arg1, @arg1)
  @call(func)
}

#define call2(func, source1, arg1, source2, arg2) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @call(func)
}

#define call3(func, source1, arg1, source2, arg2, source3, arg3) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @call(func)
}

#define call4(func, source1, arg1, source2, arg2, source3, arg3, source4, arg4) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @setarg(source4, arg4, @arg4)
  @call(func)
}

#define halt {:HALT}
#define ret @a({:jalr rab, rab, ra})
#define retval(reg1, reg2) {
  @mov(rv0, reg1)
  @mov(rv1, reg2)
}

#define prologue(locals) {
  @push(ra)
  @push(fp)
  @push(s0)
  @push(s1)
  @push(s2)
  @push(s3)

  @mov(fp, sp)

  @addi(sp, sp, locals)  
}

#define epilogue(locals) {
  @addi(sp, sp, {:-locals})

  @pop(s3)
  @pop(s2)
  @pop(s1)
  @pop(s0)
  @pop(fp)
  @pop(ra)
  
  @ret
}

#define leaf(name, body) name:{br} body{br} @ret

#define proc(name, body) {
  name:{br}
  @prologue(0)
  body{br}
  @epilogue(0)
}

#define procN(name, locals, body) {
  name:{br}
  @prologue(locals)
  body{br}
  @epilogue(locals)
}

#define ascii(s)  {for(c in s, c{: })}
#define asciiz(s) {for(c in s, c{: })} {:0}

#define local_addr(tmp, i)   @addi(tmp, fp, i)

#define local_load(dst, i)   @local_addr(t0, i) @peek(dst, sb, t0)
#define local_store(i, src)  @local_addr(t0, i) @poke(src, sb, t0)

@crt0