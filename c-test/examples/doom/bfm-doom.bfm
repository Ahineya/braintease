#define a(code) code {br}
#define set(reg, val) {:li } reg {:,} val {br}
#define mov(reg, val) {:add } reg {:,} val {:,} r0 {br}

#define arg1 s0
#define arg2 s1
#define arg3 s2
#define arg4 s3

#define reg 0
#define imm 1

#define setarg(source, arg, dst) {if(source, @set(dst, arg), @mov(dst, arg))}
#define call(func) {:call } func {br}

#define call1(func, source1, arg1) {
  @setarg(source1, arg1, @arg1)
  @call(func)
}

#define call2(func, source1, arg1, source2, arg2) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @call(func)
}

#define call3(func, source1, arg1, source2, arg2, source3, arg3) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @call(func)
}

#define call4(func, source1, arg1, source2, arg2, source3, arg3, source4, arg4) {
  @setarg(source1, arg1, @arg1)
  @setarg(source2, arg2, @arg2)
  @setarg(source3, arg3, @arg3)
  @setarg(source4, arg4, @arg4)
  @call(func)
}

#define halt {:HALT}
#define ret @a({:jalr rab, rab, ra})
#define retval(reg1, reg2) {
  @a({:addi rv0, reg1, 0})
  @a({:addi rv1, reg2, 0})
}

#define prologue {
  @a({:store ra, sb, sp})
  @a({:addi sp, sp, 1})
  @a({:store fp, sb, sp})
  @a({:add fp, sp, r0})
}

#define epilogue {
  @a({:load fp, sb, sp})
  @a({:addi sp, sp, -1})
  @a({:load ra, sb, sp})
  @ret
}

#define leaf(name, body) name:{br} body{br} @ret

#define proc(name, body) {
  name:{br}
  @prologue
  body{br}
  @epilogue
}

#define crt0 {
  @set(sb, 2)
  @set(sp, 1)
  @set(fp, 1)
  @set(gp, 1)

  @call(main)
  @halt
}

#define ascii(s) {for(c in s, c{: })}
#define asciiz(s) {for(c in s, c{: })} {:0}

.code

@crt0

@leaf(putchar, 
  @a({:store s0, r0, r0})
)

@proc(add,
  {:add sc, } @arg1 {:, } @arg2 {br}
  @retval(sc, r0)
)

@proc(main,
  @call1(putchar, @imm, @asciiz("A"))
  @call2(add, @imm, 5, @imm, 10)
  @call2(add, @reg, rv0, @reg, rv0)
)