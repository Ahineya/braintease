; Generated by Ripple C99 Compiler (rcc)

_init_globals:
    RET
; Function: swap
swap:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 25
; === Processing instruction #0: Alloca { result: 2, alloc_type: Ptr(I16), count: None, result_type: Ptr(Ptr(I16)) } ===
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
; Alloca for t2 at FP+1 (fat ptr: stack bank)
    ADDI R7, R15, 1
; === Processing instruction #1: Store { value: Temp(0), ptr: Temp(2) } ===
; === ModuleLowerer::get_reg for 'addr_t2_0' ===
; get_reg for 'addr_t2_0'
;   Allocated free register for addr_t2_0
    ADDI R8, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_2' ===
; get_reg for 'stack_bank_2'
;   Allocated free register for stack_bank_2
    LI R9, 1
; Store t0 to [t2]
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
;   R8 contains ptr_preserve2_3
;   R? contains bank_preserve_4
; t0 found in R3
;   t0 is now in R3
    STORE R3, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #2: Alloca { result: 3, alloc_type: Ptr(I16), count: None, result_type: Ptr(Ptr(I16)) } ===
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   Allocated free register for t3
; Alloca for t3 at FP+3 (fat ptr: stack bank)
    ADDI R7, R15, 3
; === Processing instruction #3: Store { value: Temp(1), ptr: Temp(3) } ===
; === ModuleLowerer::get_reg for 'addr_t3_5' ===
; get_reg for 'addr_t3_5'
;   Allocated free register for addr_t3_5
    ADDI R8, R15, 3
; === ModuleLowerer::get_reg for 'stack_bank_7' ===
; get_reg for 'stack_bank_7'
;   Allocated free register for stack_bank_7
    LI R9, 1
; Store t1 to [t3]
; Getting register for temp t1
; Looking for t1 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t3
;   R8 contains ptr_preserve2_8
;   R? contains bank_preserve_9
; t1 found in R5
;   t1 is now in R5
    STORE R5, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #4: Alloca { result: 4, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   Allocated free register for t4
; Alloca for t4 at FP+5 (fat ptr: stack bank)
    ADDI R7, R15, 5
; === Processing instruction #5: Load { result: 5, ptr: Temp(2), result_type: Ptr(I16) } ===
; Load from [t2] to t5
; === ModuleLowerer::get_reg for 'addr_t2_10' ===
; get_reg for 'addr_t2_10'
;   Allocated free register for addr_t2_10
    ADDI R8, R15, 1
; Pinning addr_t2_10 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_11' ===
; get_reg for 'stack_bank_11'
;   Allocated free register for stack_bank_11
    LI R9, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   Allocated free register for t5
    LOAD R10, R9, R8
; === ModuleLowerer::get_reg for 'next_addr_12' ===
; get_reg for 'next_addr_12'
;   Allocated free register for next_addr_12
    ADDI R11, R8, 1
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_11
; Bank register still valid in R9
; === ModuleLowerer::get_reg for 't100005' ===
; get_reg for 't100005'
;   No free registers, need to spill for t100005
;     R3 contains 't0'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t0 from R3
; Spilling t0 to FP+6
    ADDI R12, R15, 6
    STORE R3, R13, R12
;   Now R3 will contain t100005
    LOAD R3, R9, R11
; === Processing instruction #6: Load { result: 6, ptr: Temp(5), result_type: I16 } ===
; Load from [t5] to t6
; Getting register for temp t5
; Looking for t5 in registers
;   R3 contains t100005
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; t5 found in R?
;   t5 is now in R10
; Pinning t5 in register to prevent spilling
; Getting bank tag for t5
; Looking for t100005 in registers
;   R3 contains t100005
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; t100005 found in R3
; === ModuleLowerer::get_reg for 'bank_select_13' ===
; get_reg for 'bank_select_13'
;   No free registers, need to spill for bank_select_13
;     R3 contains 't100005'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t100000 from R4
; Spilling t100000 to FP+7
    ADDI R12, R15, 7
    STORE R4, R13, R12
;   Now R4 will contain bank_select_13
; Select bank register based on tag
    LI R4, 1
    BEQ R3, R4, swap_bank_stack_14
    ADD R4, R0, R0
    BEQ R0, R0, swap_bank_done_15
swap_bank_stack_14:
    LI R4, 1
swap_bank_done_15:
; === ModuleLowerer::get_reg for 't6' ===
; get_reg for 't6'
;   No free registers, need to spill for t6
;     R3 contains 't100005'
;     R4 contains 'bank_for_t5'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t100005 from R3
; Spilling t100005 to FP+8
    ADDI R12, R15, 8
    STORE R3, R13, R12
;   Now R3 will contain t6
    LOAD R3, R4, R10
; === Processing instruction #7: Store { value: Temp(6), ptr: Temp(4) } ===
; === ModuleLowerer::get_reg for 'addr_t4_16' ===
; get_reg for 'addr_t4_16'
;   No free registers, need to spill for addr_t4_16
;     R3 contains 't6'
;     R4 contains 'bank_for_t5'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t6 from R3
; Spilling t6 to FP+9
    ADDI R12, R15, 9
    STORE R3, R13, R12
;   Now R3 will contain addr_t4_16
    ADDI R3, R15, 5
; === ModuleLowerer::get_reg for 'stack_bank_18' ===
; get_reg for 'stack_bank_18'
;   No free registers, need to spill for stack_bank_18
;     R3 contains 'ptr_preserve_17'
;     R4 contains 'bank_for_t5'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill bank_for_t5 from R4
; Spilling bank_for_t5 to FP+10
    ADDI R12, R15, 10
    STORE R4, R13, R12
;   Now R4 will contain stack_bank_18
    LI R4, 1
; Store t6 to [t4]
; Getting register for temp t6
; Looking for t6 in registers
;   R3 contains ptr_preserve2_19
;   R4 contains bank_preserve_20
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; get_reg for 't6'
;   No free registers, need to spill for t6
;     R3 contains 'ptr_preserve2_19'
;     R4 contains 'bank_preserve_20'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t1 from R5
; Spilling t1 to FP+11
    ADDI R12, R15, 11
    STORE R5, R13, R12
;   Now R5 will contain t6
; Reloading t6 from FP+9
    ADDI R12, R15, 9
    LOAD R5, R13, R12
;   t6 is now in R5
    STORE R5, R4, R3
; >>> Preserving registers: storing t6 from previous instruction
; === Processing instruction #8: Load { result: 7, ptr: Temp(3), result_type: Ptr(I16) } ===
; Load from [t3] to t7
; === ModuleLowerer::get_reg for 'addr_t3_21' ===
; get_reg for 'addr_t3_21'
;   No free registers, need to spill for addr_t3_21
;     R3 contains 'ptr_preserve2_19'
;     R4 contains 'bank_preserve_20'
;     R5 contains 't6'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill ptr_preserve2_19 from R3
; Spilling ptr_preserve2_19 to FP+12
    ADDI R12, R15, 12
    STORE R3, R13, R12
;   Now R3 will contain addr_t3_21
    ADDI R3, R15, 3
; Pinning addr_t3_21 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_22' ===
; get_reg for 'stack_bank_22'
;   No free registers, need to spill for stack_bank_22
;     R3 contains 'addr_t3_21'
;     R4 contains 'bank_preserve_20'
;     R5 contains 't6'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill bank_preserve_20 from R4
; Spilling bank_preserve_20 to FP+13
    ADDI R12, R15, 13
    STORE R4, R13, R12
;   Now R4 will contain stack_bank_22
    LI R4, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't7' ===
; get_reg for 't7'
;   No free registers, need to spill for t7
;     R3 contains 'addr_t3_21'
;     R4 contains 'stack_bank_22'
;     R5 contains 't6'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t6 from R5
; Spilling t6 to FP+9
    ADDI R12, R15, 9
    STORE R5, R13, R12
;   Now R5 will contain t7
    LOAD R5, R4, R3
; === ModuleLowerer::get_reg for 'next_addr_23' ===
; get_reg for 'next_addr_23'
;   No free registers, need to spill for next_addr_23
;     R3 contains 'addr_t3_21'
;     R4 contains 'stack_bank_22'
;     R5 contains 't7'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill stack_bank_22 from R4
; Spilling stack_bank_22 to FP+14
    ADDI R12, R15, 14
    STORE R4, R13, R12
;   Now R4 will contain next_addr_23
    ADDI R4, R3, 1
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_22
; Bank register was spilled, reloading stack_bank_22
; Looking for stack_bank_22 in registers
;   R3 contains addr_t3_21
;   R4 contains next_addr_23
;   R5 contains t7
;   R6 contains t100001
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; get_reg for 'stack_bank_22'
;   No free registers, need to spill for stack_bank_22
;     R3 contains 'addr_t3_21'
;     R4 contains 'next_addr_23'
;     R5 contains 't7'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t7 from R5
; Spilling t7 to FP+15
    ADDI R12, R15, 15
    STORE R5, R13, R12
;   Now R5 will contain stack_bank_22
; Reloading stack_bank_22 from FP+14
    ADDI R12, R15, 14
    LOAD R5, R13, R12
; Reloaded bank value to R5
; === ModuleLowerer::get_reg for 't100007' ===
; get_reg for 't100007'
;   No free registers, need to spill for t100007
;     R3 contains 'addr_t3_21'
;     R4 contains 'next_addr_23'
;     R5 contains 'stack_bank_22'
;     R6 contains 't100001'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t100001 from R6
; Spilling t100001 to FP+16
    ADDI R12, R15, 16
    STORE R6, R13, R12
;   Now R6 will contain t100007
    LOAD R6, R5, R4
; === Processing instruction #9: Load { result: 8, ptr: Temp(7), result_type: I16 } ===
; Load from [t7] to t8
; Getting register for temp t7
; Looking for t7 in registers
;   R3 contains addr_t3_21
;   R4 contains next_addr_23
;   R5 contains stack_bank_22
;   R6 contains t100007
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; get_reg for 't7'
;   No free registers, need to spill for t7
;     R3 contains 'addr_t3_21'
;     R4 contains 'next_addr_23'
;     R5 contains 'stack_bank_22'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill addr_t3_21 from R3
; Spilling addr_t3_21 to FP+17
    ADDI R12, R15, 17
    STORE R3, R13, R12
;   Now R3 will contain t7
; Reloading t7 from FP+15
    ADDI R12, R15, 15
    LOAD R3, R13, R12
;   t7 is now in R3
; Pinning t7 in register to prevent spilling
; Getting bank tag for t7
; Looking for t100007 in registers
;   R3 contains t7
;   R4 contains next_addr_23
;   R5 contains stack_bank_22
;   R6 contains t100007
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; t100007 found in R6
; === ModuleLowerer::get_reg for 'bank_select_24' ===
; get_reg for 'bank_select_24'
;   No free registers, need to spill for bank_select_24
;     R3 contains 't7'
;     R4 contains 'next_addr_23'
;     R5 contains 'stack_bank_22'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill next_addr_23 from R4
; Spilling next_addr_23 to FP+18
    ADDI R12, R15, 18
    STORE R4, R13, R12
;   Now R4 will contain bank_select_24
; Select bank register based on tag
    LI R4, 1
    BEQ R6, R4, swap_bank_stack_25
    ADD R4, R0, R0
    BEQ R0, R0, swap_bank_done_26
swap_bank_stack_25:
    LI R4, 1
swap_bank_done_26:
; === ModuleLowerer::get_reg for 't8' ===
; get_reg for 't8'
;   No free registers, need to spill for t8
;     R3 contains 't7'
;     R4 contains 'bank_for_t7'
;     R5 contains 'stack_bank_22'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill stack_bank_22 from R5
; Spilling stack_bank_22 to FP+14
    ADDI R12, R15, 14
    STORE R5, R13, R12
;   Now R5 will contain t8
    LOAD R5, R4, R3
; === Processing instruction #10: Load { result: 9, ptr: Temp(2), result_type: Ptr(I16) } ===
; Load from [t2] to t9
; === ModuleLowerer::get_reg for 'addr_t2_27' ===
; get_reg for 'addr_t2_27'
;   No free registers, need to spill for addr_t2_27
;     R3 contains 't7'
;     R4 contains 'bank_for_t7'
;     R5 contains 't8'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t7 from R3
; Spilling t7 to FP+15
    ADDI R12, R15, 15
    STORE R3, R13, R12
;   Now R3 will contain addr_t2_27
    ADDI R3, R15, 1
; Pinning addr_t2_27 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_28' ===
; get_reg for 'stack_bank_28'
;   No free registers, need to spill for stack_bank_28
;     R3 contains 'addr_t2_27'
;     R4 contains 'bank_for_t7'
;     R5 contains 't8'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill bank_for_t7 from R4
; Spilling bank_for_t7 to FP+19
    ADDI R12, R15, 19
    STORE R4, R13, R12
;   Now R4 will contain stack_bank_28
    LI R4, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't9' ===
; get_reg for 't9'
;   No free registers, need to spill for t9
;     R3 contains 'addr_t2_27'
;     R4 contains 'stack_bank_28'
;     R5 contains 't8'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t8 from R5
; Spilling t8 to FP+20
    ADDI R12, R15, 20
    STORE R5, R13, R12
;   Now R5 will contain t9
    LOAD R5, R4, R3
; === ModuleLowerer::get_reg for 'next_addr_29' ===
; get_reg for 'next_addr_29'
;   No free registers, need to spill for next_addr_29
;     R3 contains 'addr_t2_27'
;     R4 contains 'stack_bank_28'
;     R5 contains 't9'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill stack_bank_28 from R4
; Spilling stack_bank_28 to FP+21
    ADDI R12, R15, 21
    STORE R4, R13, R12
;   Now R4 will contain next_addr_29
    ADDI R4, R3, 1
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_28
; Bank register was spilled, reloading stack_bank_28
; Looking for stack_bank_28 in registers
;   R3 contains addr_t2_27
;   R4 contains next_addr_29
;   R5 contains t9
;   R6 contains t100007
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; get_reg for 'stack_bank_28'
;   No free registers, need to spill for stack_bank_28
;     R3 contains 'addr_t2_27'
;     R4 contains 'next_addr_29'
;     R5 contains 't9'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t9 from R5
; Spilling t9 to FP+22
    ADDI R12, R15, 22
    STORE R5, R13, R12
;   Now R5 will contain stack_bank_28
; Reloading stack_bank_28 from FP+21
    ADDI R12, R15, 21
    LOAD R5, R13, R12
; Reloaded bank value to R5
; === ModuleLowerer::get_reg for 't100009' ===
; get_reg for 't100009'
;   No free registers, need to spill for t100009
;     R3 contains 'addr_t2_27'
;     R4 contains 'next_addr_29'
;     R5 contains 'stack_bank_28'
;     R6 contains 't100007'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill t100007 from R6
; Spilling t100007 to FP+23
    ADDI R12, R15, 23
    STORE R6, R13, R12
;   Now R6 will contain t100009
    LOAD R6, R5, R4
; === Processing instruction #11: Store { value: Temp(8), ptr: Temp(9) } ===
; Getting register for temp t9
; Looking for t9 in registers
;   R3 contains addr_t2_27
;   R4 contains next_addr_29
;   R5 contains stack_bank_28
;   R6 contains t100009
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; get_reg for 't9'
;   No free registers, need to spill for t9
;     R3 contains 'addr_t2_27'
;     R4 contains 'next_addr_29'
;     R5 contains 'stack_bank_28'
;     R6 contains 't100009'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill addr_t2_27 from R3
; Spilling addr_t2_27 to FP+24
    ADDI R12, R15, 24
    STORE R3, R13, R12
;   Now R3 will contain t9
; Reloading t9 from FP+22
    ADDI R12, R15, 22
    LOAD R3, R13, R12
;   t9 is now in R3
; Getting bank tag for t9
; Looking for t100009 in registers
;   R3 contains ptr_preserve_30
;   R4 contains next_addr_29
;   R5 contains stack_bank_28
;   R6 contains t100009
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; t100009 found in R6
; === ModuleLowerer::get_reg for 'bank_select_31' ===
; get_reg for 'bank_select_31'
;   No free registers, need to spill for bank_select_31
;     R3 contains 'ptr_preserve_30'
;     R4 contains 'next_addr_29'
;     R5 contains 'stack_bank_28'
;     R6 contains 't100009'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill next_addr_29 from R4
; Spilling next_addr_29 to FP+25
    ADDI R12, R15, 25
    STORE R4, R13, R12
;   Now R4 will contain bank_select_31
; Select bank register based on tag
    LI R4, 1
    BEQ R6, R4, swap_bank_stack_32
    ADD R4, R0, R0
    BEQ R0, R0, swap_bank_done_33
swap_bank_stack_32:
    LI R4, 1
swap_bank_done_33:
; Store t8 to [t9]
; Getting register for temp t8
; Looking for t8 in registers
;   R3 contains ptr_preserve2_34
;   R4 contains bank_preserve_35
;   R5 contains stack_bank_28
;   R6 contains t100009
;   R7 contains t4
;   R8 contains addr_t2_10
;   R? contains stack_bank_11
;   R? contains t5
;   R? contains next_addr_12
; get_reg for 't8'
;   No free registers, need to spill for t8
;     R3 contains 'ptr_preserve2_34'
;     R4 contains 'bank_preserve_35'
;     R5 contains 'stack_bank_28'
;     R6 contains 't100009'
;     R7 contains 't4'
;     R8 contains 'addr_t2_10'
;     R9 contains 'stack_bank_11'
;     R10 contains 't5'
;     R11 contains 'next_addr_12'
;   Chose to spill stack_bank_28 from R5
; Spilling stack_bank_28 to FP+21
    ADDI R12, R15, 21
    STORE R5, R13, R12
;   Now R5 will contain t8
; Reloading t8 from FP+20
    ADDI R12, R15, 20
    LOAD R5, R13, R12
;   t8 is now in R5
    STORE R5, R4, R3
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #12: Load { result: 10, ptr: Temp(4), result_type: I16 } ===
; Load from [t4] to t10
; === ModuleLowerer::get_reg for 'addr_t4_36' ===
; get_reg for 'addr_t4_36'
;   Allocated free register for addr_t4_36
    ADDI R7, R15, 5
; Pinning addr_t4_36 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_37' ===
; get_reg for 'stack_bank_37'
;   Allocated free register for stack_bank_37
    LI R8, 1
; === ModuleLowerer::get_reg for 't10' ===
; get_reg for 't10'
;   Allocated free register for t10
    LOAD R9, R8, R7
; === Processing instruction #13: Load { result: 11, ptr: Temp(3), result_type: Ptr(I16) } ===
; Load from [t3] to t11
; === ModuleLowerer::get_reg for 'addr_t3_38' ===
; get_reg for 'addr_t3_38'
;   Allocated free register for addr_t3_38
    ADDI R10, R15, 3
; Pinning addr_t3_38 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_39' ===
; get_reg for 'stack_bank_39'
;   Allocated free register for stack_bank_39
    LI R11, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't11' ===
; get_reg for 't11'
;   No free registers, need to spill for t11
;     R3 contains 'ptr_preserve2_34'
;     R4 contains 'bank_preserve_35'
;     R5 contains 't8'
;     R6 contains 't100009'
;     R7 contains 'addr_t4_36'
;     R8 contains 'stack_bank_37'
;     R9 contains 't10'
;     R10 contains 'addr_t3_38'
;     R11 contains 'stack_bank_39'
;   Chose to spill ptr_preserve2_34 from R3
; Spilling ptr_preserve2_34 to FP+26
    ADDI R12, R15, 26
    STORE R3, R13, R12
;   Now R3 will contain t11
    LOAD R3, R11, R10
; === ModuleLowerer::get_reg for 'next_addr_40' ===
; get_reg for 'next_addr_40'
;   No free registers, need to spill for next_addr_40
;     R3 contains 't11'
;     R4 contains 'bank_preserve_35'
;     R5 contains 't8'
;     R6 contains 't100009'
;     R7 contains 'addr_t4_36'
;     R8 contains 'stack_bank_37'
;     R9 contains 't10'
;     R10 contains 'addr_t3_38'
;     R11 contains 'stack_bank_39'
;   Chose to spill t11 from R3
; Spilling t11 to FP+27
    ADDI R12, R15, 27
    STORE R3, R13, R12
;   Now R3 will contain next_addr_40
    ADDI R3, R10, 1
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_39
; Bank register still valid in R11
; === ModuleLowerer::get_reg for 't100011' ===
; get_reg for 't100011'
;   No free registers, need to spill for t100011
;     R3 contains 'next_addr_40'
;     R4 contains 'bank_preserve_35'
;     R5 contains 't8'
;     R6 contains 't100009'
;     R7 contains 'addr_t4_36'
;     R8 contains 'stack_bank_37'
;     R9 contains 't10'
;     R10 contains 'addr_t3_38'
;     R11 contains 'stack_bank_39'
;   Chose to spill bank_preserve_35 from R4
; Spilling bank_preserve_35 to FP+28
    ADDI R12, R15, 28
    STORE R4, R13, R12
;   Now R4 will contain t100011
    LOAD R4, R11, R3
; === Processing instruction #14: Store { value: Temp(10), ptr: Temp(11) } ===
; Getting register for temp t11
; Looking for t11 in registers
;   R3 contains next_addr_40
;   R4 contains t100011
;   R5 contains t8
;   R6 contains t100009
;   R7 contains addr_t4_36
;   R8 contains stack_bank_37
;   R? contains t10
;   R? contains addr_t3_38
;   R? contains stack_bank_39
; get_reg for 't11'
;   No free registers, need to spill for t11
;     R3 contains 'next_addr_40'
;     R4 contains 't100011'
;     R5 contains 't8'
;     R6 contains 't100009'
;     R7 contains 'addr_t4_36'
;     R8 contains 'stack_bank_37'
;     R9 contains 't10'
;     R10 contains 'addr_t3_38'
;     R11 contains 'stack_bank_39'
;   Chose to spill next_addr_40 from R3
; Spilling next_addr_40 to FP+29
    ADDI R12, R15, 29
    STORE R3, R13, R12
;   Now R3 will contain t11
; Reloading t11 from FP+27
    ADDI R12, R15, 27
    LOAD R3, R13, R12
;   t11 is now in R3
; Getting bank tag for t11
; Looking for t100011 in registers
;   R3 contains ptr_preserve_41
;   R4 contains t100011
;   R5 contains t8
;   R6 contains t100009
;   R7 contains addr_t4_36
;   R8 contains stack_bank_37
;   R? contains t10
;   R? contains addr_t3_38
;   R? contains stack_bank_39
; t100011 found in R4
; === ModuleLowerer::get_reg for 'bank_select_42' ===
; get_reg for 'bank_select_42'
;   No free registers, need to spill for bank_select_42
;     R3 contains 'ptr_preserve_41'
;     R4 contains 't100011'
;     R5 contains 't8'
;     R6 contains 't100009'
;     R7 contains 'addr_t4_36'
;     R8 contains 'stack_bank_37'
;     R9 contains 't10'
;     R10 contains 'addr_t3_38'
;     R11 contains 'stack_bank_39'
;   Chose to spill t8 from R5
; Spilling t8 to FP+20
    ADDI R12, R15, 20
    STORE R5, R13, R12
;   Now R5 will contain bank_select_42
; Select bank register based on tag
    LI R5, 1
    BEQ R4, R5, swap_bank_stack_43
    ADD R5, R0, R0
    BEQ R0, R0, swap_bank_done_44
swap_bank_stack_43:
    LI R5, 1
swap_bank_done_44:
; Store t10 to [t11]
; Getting register for temp t10
; Looking for t10 in registers
;   R3 contains ptr_preserve2_45
;   R4 contains t100011
;   R5 contains bank_preserve_46
;   R6 contains t100009
;   R7 contains addr_t4_36
;   R8 contains stack_bank_37
;   R? contains t10
;   R? contains addr_t3_38
;   R? contains stack_bank_39
; t10 found in R?
;   t10 is now in R9
    STORE R9, R5, R3
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #15: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
; Function: main
main:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 22
main_L1:
; === Processing instruction #0: Alloca { result: 0, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't0' ===
; get_reg for 't0'
;   Allocated free register for t0
; Alloca for t0 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #1: Store { value: Constant(1), ptr: Temp(0) } ===
; === ModuleLowerer::get_reg for 'addr_t0_47' ===
; get_reg for 'addr_t0_47'
;   Allocated free register for addr_t0_47
    ADDI R6, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_49' ===
; get_reg for 'stack_bank_49'
;   Allocated free register for stack_bank_49
    LI R7, 1
; Store 1 to [t0]
; === ModuleLowerer::get_reg for 'const_1_52' ===
; get_reg for 'const_1_52'
;   Allocated free register for const_1_52
    LI R8, 1
    STORE R8, R7, R6
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #2: Alloca { result: 1, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't1' ===
; get_reg for 't1'
;   Allocated free register for t1
; Alloca for t1 at FP+2 (fat ptr: stack bank)
    ADDI R5, R15, 2
; === Processing instruction #3: Store { value: Constant(2), ptr: Temp(1) } ===
; === ModuleLowerer::get_reg for 'addr_t1_53' ===
; get_reg for 'addr_t1_53'
;   Allocated free register for addr_t1_53
    ADDI R6, R15, 2
; === ModuleLowerer::get_reg for 'stack_bank_55' ===
; get_reg for 'stack_bank_55'
;   Allocated free register for stack_bank_55
    LI R7, 1
; Store 2 to [t1]
; === ModuleLowerer::get_reg for 'const_2_58' ===
; get_reg for 'const_2_58'
;   Allocated free register for const_2_58
    LI R8, 2
    STORE R8, R7, R6
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #4: Call { result: None, function: Global("swap"), args: [Temp(0), Temp(1)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t0_59' ===
; get_reg for 'addr_t0_59'
;   Allocated free register for addr_t0_59
    ADDI R5, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_60' ===
; get_reg for 'stack_bank_60'
;   Allocated free register for stack_bank_60
    LI R6, 1
; === ModuleLowerer::get_reg for 'addr_t1_61' ===
; get_reg for 'addr_t1_61'
;   Allocated free register for addr_t1_61
    ADDI R7, R15, 2
; === ModuleLowerer::get_reg for 'stack_bank_62' ===
; get_reg for 'stack_bank_62'
;   Allocated free register for stack_bank_62
    LI R8, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    ADD R5, R7, R0
    ADD R6, R8, R0
    CALL swap
; === Processing instruction #5: Load { result: 2, ptr: Temp(0), result_type: I16 } ===
; Load from [t0] to t2
; === ModuleLowerer::get_reg for 'addr_t0_63' ===
; Clearing R5 which contained addr_t0_59
; Clearing R6 which contained stack_bank_60
; Clearing R7 which contained addr_t1_61
; Clearing R8 which contained stack_bank_62
; get_reg for 'addr_t0_63'
;   Allocated free register for addr_t0_63
    ADDI R8, R15, 1
; Pinning addr_t0_63 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_64' ===
; get_reg for 'stack_bank_64'
;   Allocated free register for stack_bank_64
    LI R7, 1
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
    LOAD R6, R7, R8
; === Processing instruction #6: Binary { result: 3, op: Add, lhs: Constant(48), rhs: Temp(2), result_type: I16 } ===
; === Processing Binary t3 ===
; Binary: need(lhs)=1, need(rhs)=1
; === ModuleLowerer::get_reg for 'const_48_65' ===
; get_reg for 'const_48_65'
;   Allocated free register for const_48_65
    LI R5, 48
; Getting register for temp t2
; Looking for t2 in registers
;   R5 contains const_48_65
;   R6 contains t2
;   R7 contains stack_bank_64
;   R8 contains addr_t0_63
; t2 found in R6
;   t2 is now in R6
; Reusing R5 for result t3
    ADD R5, R5, R6
; Freeing right operand register R6
; === Processing instruction #7: Call { result: None, function: Global("putchar"), args: [Temp(3)], result_type: Void } ===
; Getting register for temp t3
; Looking for t3 in registers
;   R5 contains t3
;   R7 contains stack_bank_64
;   R8 contains addr_t0_63
; t3 found in R5
;   t3 is now in R5
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #8: Load { result: 4, ptr: Temp(1), result_type: I16 } ===
; Load from [t1] to t4
; === ModuleLowerer::get_reg for 'addr_t1_66' ===
; Clearing R5 which contained t3
; Clearing R7 which contained stack_bank_64
; Clearing R8 which contained addr_t0_63
; get_reg for 'addr_t1_66'
;   Allocated free register for addr_t1_66
    ADDI R8, R15, 2
; Pinning addr_t1_66 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_67' ===
; get_reg for 'stack_bank_67'
;   Allocated free register for stack_bank_67
    LI R7, 1
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   Allocated free register for t4
    LOAD R5, R7, R8
; === Processing instruction #9: Binary { result: 5, op: Add, lhs: Constant(48), rhs: Temp(4), result_type: I16 } ===
; === Processing Binary t5 ===
; Binary: need(lhs)=1, need(rhs)=1
; === ModuleLowerer::get_reg for 'const_48_68' ===
; get_reg for 'const_48_68'
;   Allocated free register for const_48_68
    LI R6, 48
; Getting register for temp t4
; Looking for t4 in registers
;   R5 contains t4
;   R6 contains const_48_68
;   R7 contains stack_bank_67
;   R8 contains addr_t1_66
; t4 found in R5
;   t4 is now in R5
; Reusing R6 for result t5
    ADD R6, R6, R5
; Freeing right operand register R5
; === Processing instruction #10: Call { result: None, function: Global("putchar"), args: [Temp(5)], result_type: Void } ===
; Getting register for temp t5
; Looking for t5 in registers
;   R6 contains t5
;   R7 contains stack_bank_67
;   R8 contains addr_t1_66
; t5 found in R6
;   t5 is now in R6
    ADD R3, R6, R0
    CALL putchar
; === Processing instruction #11: Call { result: None, function: Global("putchar"), args: [Constant(10)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_10_69' ===
; Clearing R6 which contained t5
; Clearing R7 which contained stack_bank_67
; Clearing R8 which contained addr_t1_66
; get_reg for 'const_10_69'
;   Allocated free register for const_10_69
    LI R8, 10
    ADD R3, R8, R0
    CALL putchar
; === Processing instruction #12: Return(Some(Constant(0))) ===
; === ModuleLowerer::get_reg for 'const_0_70' ===
; Clearing R8 which contained const_10_69
; get_reg for 'const_0_70'
;   Allocated free register for const_0_70
    LI R8, 0
    ADD R3, R8, R0
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
main_L2:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
