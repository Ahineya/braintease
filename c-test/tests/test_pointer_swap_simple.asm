; Generated by Ripple C99 Compiler (rcc)

_init_globals:
    RET
; Function: swap
swap:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
; === Processing instruction #0: Alloca { result: 2, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
; Alloca for t2 at FP+1 (fat ptr: stack bank)
    ADDI R7, R15, 1
; === Processing instruction #1: Load { result: 3, ptr: Temp(0), result_type: I16 } ===
; Load from [t0] to t3
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
; t0 found in R3
;   t0 is now in R3
; Pinning t0 in register to prevent spilling
; Getting bank tag for t0
; Looking for t100000 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
; t100000 found in R4
; === ModuleLowerer::get_reg for 'bank_select_0' ===
; get_reg for 'bank_select_0'
;   Allocated free register for bank_select_0
; Select bank register based on tag
    LI R8, 1
    BEQ R4, R8, swap_bank_stack_1
    ADD R8, R0, R0
    BEQ R0, R0, swap_bank_done_2
swap_bank_stack_1:
    ADD R8, R13, R0
swap_bank_done_2:
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   Allocated free register for t3
    LOAD R9, R8, R3
; === Processing instruction #2: Store { value: Temp(3), ptr: Temp(2) } ===
; === ModuleLowerer::get_reg for 'addr_t2_3' ===
; get_reg for 'addr_t2_3'
;   Allocated free register for addr_t2_3
    ADDI R10, R15, 1
; Store t3 to [t2]
; Getting register for temp t3
; Looking for t3 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
; t3 found in R?
;   t3 is now in R9
    STORE R9, R13, R10
; >>> Preserving registers: storing t3 from previous instruction
; === Processing instruction #3: Load { result: 4, ptr: Temp(1), result_type: I16 } ===
; Load from [t1] to t4
; Getting register for temp t1
; Looking for t1 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
; t1 found in R5
;   t1 is now in R5
; Pinning t1 in register to prevent spilling
; Getting bank tag for t1
; Looking for t100001 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
; t100001 found in R6
; === ModuleLowerer::get_reg for 'bank_select_7' ===
; get_reg for 'bank_select_7'
;   Allocated free register for bank_select_7
; Select bank register based on tag
    LI R11, 1
    BEQ R6, R11, swap_bank_stack_8
    ADD R11, R0, R0
    BEQ R0, R0, swap_bank_done_9
swap_bank_stack_8:
    ADD R11, R13, R0
swap_bank_done_9:
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   No free registers, need to spill for t4
;     R3 contains 't0'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill t0 from R3
; Spilling t0 to FP+2
    ADDI R12, R15, 2
    STORE R3, R13, R12
;   Now R3 will contain t4
    LOAD R3, R11, R5
; === Processing instruction #4: Store { value: Temp(4), ptr: Temp(0) } ===
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains t4
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
;   R? contains bank_for_t1
; get_reg for 't0'
;   No free registers, need to spill for t0
;     R3 contains 't4'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill t4 from R3
; Spilling t4 to FP+3
    ADDI R12, R15, 3
    STORE R3, R13, R12
;   Now R3 will contain t0
; Reloading t0 from FP+2
    ADDI R12, R15, 2
    LOAD R3, R13, R12
;   t0 is now in R3
; Getting bank tag for t0
; Looking for t100000 in registers
;   R3 contains ptr_preserve_10
;   R4 contains t100000
;   R5 contains t1
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
;   R? contains bank_for_t1
; t100000 found in R4
; === ModuleLowerer::get_reg for 'bank_select_11' ===
; get_reg for 'bank_select_11'
;   No free registers, need to spill for bank_select_11
;     R3 contains 'ptr_preserve_10'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill t1 from R5
; Spilling t1 to FP+4
    ADDI R12, R15, 4
    STORE R5, R13, R12
;   Now R5 will contain bank_select_11
; Select bank register based on tag
    LI R5, 1
    BEQ R4, R5, swap_bank_stack_12
    ADD R5, R0, R0
    BEQ R0, R0, swap_bank_done_13
swap_bank_stack_12:
    ADD R5, R13, R0
swap_bank_done_13:
; Store t4 to [t0]
; Getting register for temp t4
; Looking for t4 in registers
;   R3 contains ptr_preserve2_14
;   R4 contains t100000
;   R5 contains bank_preserve_15
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
;   R? contains bank_for_t1
; get_reg for 't4'
;   No free registers, need to spill for t4
;     R3 contains 'ptr_preserve2_14'
;     R4 contains 't100000'
;     R5 contains 'bank_preserve_15'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill t100000 from R4
; Spilling t100000 to FP+5
    ADDI R12, R15, 5
    STORE R4, R13, R12
;   Now R4 will contain t4
; Reloading t4 from FP+3
    ADDI R12, R15, 3
    LOAD R4, R13, R12
;   t4 is now in R4
    STORE R4, R5, R3
; >>> Preserving registers: storing t4 from previous instruction
; === Processing instruction #5: Load { result: 5, ptr: Temp(2), result_type: I16 } ===
; Load from [t2] to t5
; === ModuleLowerer::get_reg for 'addr_t2_16' ===
; get_reg for 'addr_t2_16'
;   No free registers, need to spill for addr_t2_16
;     R3 contains 'ptr_preserve2_14'
;     R4 contains 't4'
;     R5 contains 'bank_preserve_15'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill ptr_preserve2_14 from R3
; Spilling ptr_preserve2_14 to FP+6
    ADDI R12, R15, 6
    STORE R3, R13, R12
;   Now R3 will contain addr_t2_16
    ADDI R3, R15, 1
; Pinning addr_t2_16 in register to prevent spilling
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   No free registers, need to spill for t5
;     R3 contains 'addr_t2_16'
;     R4 contains 't4'
;     R5 contains 'bank_preserve_15'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill t4 from R4
; Spilling t4 to FP+3
    ADDI R12, R15, 3
    STORE R4, R13, R12
;   Now R4 will contain t5
    LOAD R4, R13, R3
; === Processing instruction #6: Store { value: Temp(5), ptr: Temp(1) } ===
; Getting register for temp t1
; Looking for t1 in registers
;   R3 contains addr_t2_16
;   R4 contains t5
;   R5 contains bank_preserve_15
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
;   R? contains bank_for_t1
; get_reg for 't1'
;   No free registers, need to spill for t1
;     R3 contains 'addr_t2_16'
;     R4 contains 't5'
;     R5 contains 'bank_preserve_15'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill addr_t2_16 from R3
; Spilling addr_t2_16 to FP+7
    ADDI R12, R15, 7
    STORE R3, R13, R12
;   Now R3 will contain t1
; Reloading t1 from FP+4
    ADDI R12, R15, 4
    LOAD R3, R13, R12
;   t1 is now in R3
; Getting bank tag for t1
; Looking for t100001 in registers
;   R3 contains ptr_preserve_17
;   R4 contains t5
;   R5 contains bank_preserve_15
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
;   R? contains bank_for_t1
; t100001 found in R6
; === ModuleLowerer::get_reg for 'bank_select_18' ===
; get_reg for 'bank_select_18'
;   No free registers, need to spill for bank_select_18
;     R3 contains 'ptr_preserve_17'
;     R4 contains 't5'
;     R5 contains 'bank_preserve_15'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill t5 from R4
; Spilling t5 to FP+8
    ADDI R12, R15, 8
    STORE R4, R13, R12
;   Now R4 will contain bank_select_18
; Select bank register based on tag
    LI R4, 1
    BEQ R6, R4, swap_bank_stack_19
    ADD R4, R0, R0
    BEQ R0, R0, swap_bank_done_20
swap_bank_stack_19:
    ADD R4, R13, R0
swap_bank_done_20:
; Store t5 to [t1]
; Getting register for temp t5
; Looking for t5 in registers
;   R3 contains ptr_preserve2_21
;   R4 contains bank_preserve_22
;   R5 contains bank_preserve_15
;   R6 contains t100001
;   R7 contains t2
;   R8 contains bank_for_t0
;   R? contains t3
;   R? contains ptr_preserve2_5
;   R? contains bank_for_t1
; get_reg for 't5'
;   No free registers, need to spill for t5
;     R3 contains 'ptr_preserve2_21'
;     R4 contains 'bank_preserve_22'
;     R5 contains 'bank_preserve_15'
;     R6 contains 't100001'
;     R7 contains 't2'
;     R8 contains 'bank_for_t0'
;     R9 contains 't3'
;     R10 contains 'ptr_preserve2_5'
;     R11 contains 'bank_for_t1'
;   Chose to spill bank_preserve_15 from R5
; Spilling bank_preserve_15 to FP+9
    ADDI R12, R15, 9
    STORE R5, R13, R12
;   Now R5 will contain t5
; Reloading t5 from FP+8
    ADDI R12, R15, 8
    LOAD R5, R13, R12
;   t5 is now in R5
    STORE R5, R4, R3
; >>> Preserving registers: storing t5 from previous instruction
; === Processing instruction #7: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
; Function: main
main:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
main_L1:
; === Processing instruction #0: Alloca { result: 0, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't0' ===
; get_reg for 't0'
;   Allocated free register for t0
; Alloca for t0 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #1: Store { value: Constant(1), ptr: Temp(0) } ===
; === ModuleLowerer::get_reg for 'addr_t0_23' ===
; get_reg for 'addr_t0_23'
;   Allocated free register for addr_t0_23
    ADDI R6, R15, 1
; Store 1 to [t0]
; === ModuleLowerer::get_reg for 'const_1_27' ===
; get_reg for 'const_1_27'
;   Allocated free register for const_1_27
    LI R7, 1
    STORE R7, R13, R6
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #2: Alloca { result: 1, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't1' ===
; get_reg for 't1'
;   Allocated free register for t1
; Alloca for t1 at FP+2 (fat ptr: stack bank)
    ADDI R5, R15, 2
; === Processing instruction #3: Store { value: Constant(2), ptr: Temp(1) } ===
; === ModuleLowerer::get_reg for 'addr_t1_28' ===
; get_reg for 'addr_t1_28'
;   Allocated free register for addr_t1_28
    ADDI R6, R15, 2
; Store 2 to [t1]
; === ModuleLowerer::get_reg for 'const_2_32' ===
; get_reg for 'const_2_32'
;   Allocated free register for const_2_32
    LI R7, 2
    STORE R7, R13, R6
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #4: Call { result: None, function: Global("swap"), args: [Temp(0), Temp(1)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t0_33' ===
; get_reg for 'addr_t0_33'
;   Allocated free register for addr_t0_33
    ADDI R5, R15, 1
; === ModuleLowerer::get_reg for 'bank_tag_stack_34' ===
; get_reg for 'bank_tag_stack_34'
;   Allocated free register for bank_tag_stack_34
    LI R6, 1
; === ModuleLowerer::get_reg for 'addr_t1_35' ===
; get_reg for 'addr_t1_35'
;   Allocated free register for addr_t1_35
    ADDI R7, R15, 2
; === ModuleLowerer::get_reg for 'bank_tag_stack_36' ===
; get_reg for 'bank_tag_stack_36'
;   Allocated free register for bank_tag_stack_36
    LI R8, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    ADD R5, R7, R0
    ADD R6, R8, R0
    CALL swap
; === Processing instruction #5: Load { result: 2, ptr: Temp(0), result_type: I16 } ===
; Load from [t0] to t2
; === ModuleLowerer::get_reg for 'addr_t0_37' ===
; Clearing R5 which contained addr_t0_33
; Clearing R6 which contained bank_tag_stack_34
; Clearing R7 which contained addr_t1_35
; Clearing R8 which contained bank_tag_stack_36
; get_reg for 'addr_t0_37'
;   Allocated free register for addr_t0_37
    ADDI R8, R15, 1
; Pinning addr_t0_37 in register to prevent spilling
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
    LOAD R7, R13, R8
; === Processing instruction #6: Binary { result: 3, op: Add, lhs: Constant(48), rhs: Temp(2), result_type: I16 } ===
; === Processing Binary t3 ===
; Binary: need(lhs)=1, need(rhs)=1
; === ModuleLowerer::get_reg for 'const_48_38' ===
; get_reg for 'const_48_38'
;   Allocated free register for const_48_38
    LI R6, 48
; Getting register for temp t2
; Looking for t2 in registers
;   R6 contains const_48_38
;   R7 contains t2
;   R8 contains addr_t0_37
; t2 found in R7
;   t2 is now in R7
; Reusing R6 for result t3
    ADD R6, R6, R7
; Freeing right operand register R7
; === Processing instruction #7: Call { result: None, function: Global("putchar"), args: [Temp(3)], result_type: Void } ===
; Getting register for temp t3
; Looking for t3 in registers
;   R6 contains t3
;   R8 contains addr_t0_37
; t3 found in R6
;   t3 is now in R6
    ADD R3, R6, R0
    CALL putchar
; === Processing instruction #8: Load { result: 4, ptr: Temp(1), result_type: I16 } ===
; Load from [t1] to t4
; === ModuleLowerer::get_reg for 'addr_t1_39' ===
; Clearing R6 which contained t3
; Clearing R8 which contained addr_t0_37
; get_reg for 'addr_t1_39'
;   Allocated free register for addr_t1_39
    ADDI R8, R15, 2
; Pinning addr_t1_39 in register to prevent spilling
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   Allocated free register for t4
    LOAD R6, R13, R8
; === Processing instruction #9: Binary { result: 5, op: Add, lhs: Constant(48), rhs: Temp(4), result_type: I16 } ===
; === Processing Binary t5 ===
; Binary: need(lhs)=1, need(rhs)=1
; === ModuleLowerer::get_reg for 'const_48_40' ===
; get_reg for 'const_48_40'
;   Allocated free register for const_48_40
    LI R7, 48
; Getting register for temp t4
; Looking for t4 in registers
;   R6 contains t4
;   R7 contains const_48_40
;   R8 contains addr_t1_39
; t4 found in R6
;   t4 is now in R6
; Reusing R7 for result t5
    ADD R7, R7, R6
; Freeing right operand register R6
; === Processing instruction #10: Call { result: None, function: Global("putchar"), args: [Temp(5)], result_type: Void } ===
; Getting register for temp t5
; Looking for t5 in registers
;   R7 contains t5
;   R8 contains addr_t1_39
; t5 found in R7
;   t5 is now in R7
    ADD R3, R7, R0
    CALL putchar
; === Processing instruction #11: Call { result: None, function: Global("putchar"), args: [Constant(10)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_10_41' ===
; Clearing R7 which contained t5
; Clearing R8 which contained addr_t1_39
; get_reg for 'const_10_41'
;   Allocated free register for const_10_41
    LI R8, 10
    ADD R3, R8, R0
    CALL putchar
; === Processing instruction #12: Return(Some(Constant(0))) ===
; === ModuleLowerer::get_reg for 'const_0_42' ===
; Clearing R8 which contained const_10_41
; get_reg for 'const_0_42'
;   Allocated free register for const_0_42
    LI R8, 0
    ADD R3, R8, R0
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
main_L2:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
