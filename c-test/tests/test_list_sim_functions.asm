; Generated by Ripple C99 Compiler (rcc)

_init_globals:
    RET
insert_char:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 15 slots for locals
    ADDI SP, SP, 15
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
; Load param 1 bank from A3
; Load param 2 from FP-7
    ADDI SC, FP, -7
    LOAD S1, SB, SC
; Load param 3 from FP-8
    ADDI SC, FP, -8
    LOAD S0, SB, SC
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADDI T6, T7, 1
    STORE A1, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S2, SB, T5
    ADDI T4, T5, 1
    STORE A3, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 4
    STORE S1, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 5
    STORE S0, SB, T2
    ADD T1, FP, R0
    ADDI T1, T1, 6
    LOAD T0, SB, T5
    ADDI T6, T5, 1
    LOAD T4, SB, T6
    LOAD T6, T4, T0
    STORE T6, SB, T1
    BEQ R0, R0, L_insert_char_1
; Unconditional branch to L_insert_char_1
L_insert_char_1:
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S3, SB, SC
    LOAD S3, SB, T1
; Spill t4 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T7, SB, SC
    LOAD T7, SB, T3
    SLT S3, T7, S3
    BEQ S3, R0, L_insert_char_3
; Branch to L_insert_char_3 if condition is false
    BEQ R0, R0, L_insert_char_2
; Unconditional branch to L_insert_char_2 (condition was true)
L_insert_char_2:
; Recompute alloca t4 at FP+0
    ADD T7, FP, R0
    LOAD S3, SB, T7
; Spill t1 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S2, SB, SC
    ADDI S2, T7, 1
; Spill t2 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S1, SB, SC
    LOAD S1, SB, S2
    LOAD S2, SB, T1
; Spill t3 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
; Spill t7 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T2, SB, SC
    ADD T2, S2, R0
    ADD S0, S3, T2
; Runtime bank overflow calculation for dynamic GEP
; Spill t5 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T5, SB, SC
; Spill t9 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T0, SB, SC
    LI T0, 4096
    DIV T5, S0, T0
; Spill load_f0_op10_t9_bank_val to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T4, SB, SC
    MOD T4, S0, T0
; Spill t10 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T6, SB, SC
    ADD T6, S1, T5
    ADD S0, T4, R0
    LOAD T2, SB, T7
    ADDI T5, T7, 1
    LOAD T0, SB, T5
    LOAD T4, SB, T1
    LI S3, 1
    SUB T4, T4, S3
    ADD S3, T4, R0
    ADD T5, T2, S3
; Runtime bank overflow calculation for dynamic GEP
; Spill t6 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T3, SB, SC
; Spill t16 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE S0, SB, SC
    LI S0, 4096
    DIV T3, T5, S0
; Spill t15 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE S2, SB, SC
    MOD S2, T5, S0
; Spill load_f0_op15_t14_bank_val to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE S1, SB, SC
    ADD S1, T0, T3
    ADD T5, S2, R0
    LOAD S3, S1, T5
; Reload t16 from slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 26
    LOAD T3, SB, SC
    STORE S3, T6, T3
    LOAD S0, SB, T1
    LI S2, 1
    SUB S0, S0, S2
    STORE S0, SB, T1
    BEQ R0, R0, L_insert_char_1
; Unconditional branch to L_insert_char_1
L_insert_char_3:
    LOAD T2, SB, T7
    ADDI S2, T7, 1
; Spill gep_new_bank_f0_op21_t16 to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE T6, SB, SC
    LOAD T6, SB, S2
; Recompute alloca t6 at FP+4
    ADD S2, FP, R0
    ADDI S2, S2, 4
; Spill t19 to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE T4, SB, SC
    LOAD T4, SB, S2
; Spill load_f0_op24_t17_bank_val to slot 16
    ADD SC, FP, R0
    ADDI SC, SC, 31
    STORE T0, SB, SC
; Spill gep_new_bank_f0_op30_t20 to slot 17
    ADD SC, FP, R0
    ADDI SC, SC, 32
    STORE S1, SB, SC
    ADD S1, T4, R0
    ADD T0, T2, S1
; Runtime bank overflow calculation for dynamic GEP
; Spill t20 to slot 18
    ADD SC, FP, R0
    ADDI SC, SC, 33
    STORE T5, SB, SC
; Spill t21 to slot 19
    ADD SC, FP, R0
    ADDI SC, SC, 34
    STORE S3, SB, SC
    LI S3, 4096
    DIV T5, T0, S3
; Spill t16 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T3, SB, SC
    MOD T3, T0, S3
; Spill t23 to slot 20
    ADD SC, FP, R0
    ADDI SC, SC, 35
    STORE S0, SB, SC
    ADD S0, T6, T5
    ADD T0, T3, R0
; Recompute alloca t7 at FP+5
    ADD S1, FP, R0
    ADDI S1, S1, 5
    LOAD T5, SB, S1
    STORE T5, S0, T0
; Recompute alloca t5 at FP+2
    ADD S3, FP, R0
    ADDI S3, S3, 2
    LOAD T3, SB, S3
    ADDI T2, S3, 1
; Spill t8 to slot 21
    ADD SC, FP, R0
    ADDI SC, SC, 36
    STORE T1, SB, SC
    LOAD T1, SB, T2
    LOAD T2, SB, S3
; Spill t4 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T7, SB, SC
    ADDI T7, S3, 1
; Spill t6 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE S2, SB, SC
    LOAD S2, SB, T7
    LOAD T7, S2, T2
; Spill t25 to slot 22
    ADD SC, FP, R0
    ADDI SC, SC, 37
    STORE T4, SB, SC
    LI T4, 1
    ADD T7, T7, T4
    STORE T7, T1, T3
; Jump to epilogue
    BEQ R0, R0, L_insert_char_99999
L_insert_char_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
delete_char:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
; Load param 1 bank from A3
; Load param 2 from FP-7
    ADDI SC, FP, -7
    LOAD S1, SB, SC
L_delete_char_4:
    ADD S0, FP, R0
    STORE S3, SB, S0
    ADDI T7, S0, 1
    STORE A1, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 2
    STORE S2, SB, T6
    ADDI T5, T6, 1
    STORE A3, SB, T5
    ADD T4, FP, R0
    ADDI T4, T4, 4
    STORE S1, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 5
    LOAD T2, SB, T4
    STORE T2, SB, T3
    BEQ R0, R0, L_delete_char_5
; Unconditional branch to L_delete_char_5
L_delete_char_5:
    LOAD T1, SB, T3
    LOAD T0, SB, T6
    ADDI T7, T6, 1
    LOAD T5, SB, T7
    LOAD T7, T5, T0
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
    LI S3, 1
    SUB T7, T7, S3
    SLT T1, T1, T7
    BEQ T1, R0, L_delete_char_7
; Branch to L_delete_char_7 if condition is false
    BEQ R0, R0, L_delete_char_6
; Unconditional branch to L_delete_char_6 (condition was true)
L_delete_char_6:
    LOAD S3, SB, S0
    ADDI T7, S0, 1
    LOAD T1, SB, T7
    LOAD T7, SB, T3
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
; Spill t2 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S1, SB, SC
    ADD S1, T7, R0
    ADD S2, S3, S1
; Runtime bank overflow calculation for dynamic GEP
; Spill t5 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T4, SB, SC
; Spill t7 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T2, SB, SC
    LI T2, 4096
    DIV T4, S2, T2
; Spill t4 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T6, SB, SC
    MOD T6, S2, T2
; Spill t9 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T0, SB, SC
    ADD T0, T1, T4
    ADD S2, T6, R0
    LOAD S1, SB, S0
    ADDI T4, S0, 1
    LOAD T2, SB, T4
    LOAD T6, SB, T3
    LI S3, 1
    ADD T6, T6, S3
    ADD S3, T6, R0
    ADD T4, S1, S3
; Runtime bank overflow calculation for dynamic GEP
; Spill load_f2_op11_t9_bank_val to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T5, SB, SC
; Spill t15 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE S2, SB, SC
    LI S2, 4096
    DIV T5, T4, S2
; Spill t14 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T7, SB, SC
    MOD T7, T4, S2
; Spill load_f2_op14_t13_bank_val to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T1, SB, SC
    ADD T1, T2, T5
    ADD T4, T7, R0
    LOAD S3, T1, T4
; Reload t15 from slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 22
    LOAD T5, SB, SC
    STORE S3, T0, T5
    LOAD S2, SB, T3
    LI T7, 1
    ADD S2, S2, T7
    STORE S2, SB, T3
    BEQ R0, R0, L_delete_char_5
; Unconditional branch to L_delete_char_5
L_delete_char_7:
; Recompute alloca t4 at FP+2
    ADD S1, FP, R0
    ADDI S1, S1, 2
    LOAD T7, SB, S1
; Spill gep_new_bank_f2_op20_t15 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T0, SB, SC
    ADDI T0, S1, 1
; Spill t3 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE S0, SB, SC
    LOAD S0, SB, T0
    LOAD T0, SB, S1
; Spill t18 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T6, SB, SC
    ADDI T6, S1, 1
; Spill load_f2_op23_t16_bank_val to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T2, SB, SC
    LOAD T2, SB, T6
    LOAD T6, T2, T0
; Spill gep_new_bank_f2_op29_t19 to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE T1, SB, SC
    LI T1, 1
    SUB T6, T6, T1
    STORE T6, S0, T7
; Jump to epilogue
    BEQ R0, R0, L_delete_char_99999
L_delete_char_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
print_chars:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 12 slots for locals
    ADDI SP, SP, 12
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
L_print_chars_8:
    ADD S1, FP, R0
    STORE S3, SB, S1
    ADDI S0, S1, 1
    STORE A1, SB, S0
    ADD T7, FP, R0
    ADDI T7, T7, 2
    STORE S2, SB, T7
    ADD T6, FP, R0
    ADDI T6, T6, 3
    LI T5, 0
    STORE T5, SB, T6
    BEQ R0, R0, L_print_chars_9
; Unconditional branch to L_print_chars_9
L_print_chars_9:
    LOAD T4, SB, T6
    LOAD T3, SB, T7
    SLT T4, T4, T3
    BEQ T4, R0, L_print_chars_11
; Branch to L_print_chars_11 if condition is false
    BEQ R0, R0, L_print_chars_10
; Unconditional branch to L_print_chars_10 (condition was true)
L_print_chars_10:
    LOAD T2, SB, S1
    ADDI T1, S1, 1
    LOAD T0, SB, T1
    LOAD S0, SB, T6
    ADD T3, S0, R0
    ADD T5, T2, T3
; Runtime bank overflow calculation for dynamic GEP
    LI T1, 4096
    DIV T4, T5, T1
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 12
    STORE S3, SB, SC
    MOD S3, T5, T1
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 13
    STORE S2, SB, SC
    ADD S2, T0, T4
    ADD T5, S3, R0
    LOAD T3, S2, T5
; Spill live registers before call
; Spill t3 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE T7, SB, SC
; Spill t2 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S1, SB, SC
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T6, SB, SC
; Spill t9 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S0, SB, SC
; Spill load_f4_op9_t8_bank_val to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T0, SB, SC
; Spill gep_new_bank_f4_op15_t10 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S2, SB, SC
; Spill t10 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T5, SB, SC
; Spill t11 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T3, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T3, R0
; Call function putchar
    CALL putchar
; Scalar return value for t12
; Recompute alloca t4 at FP+3
    ADD T4, FP, R0
    ADDI T4, T4, 3
    LOAD T1, SB, T4
    LI S3, 1
    ADD T1, T1, S3
    STORE T1, SB, T4
    BEQ R0, R0, L_print_chars_9
; Unconditional branch to L_print_chars_9
L_print_chars_11:
    LI T2, 10
; Spill live registers before call
; Spill t12 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE RV0, SB, SC
; Spill t14 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T1, SB, SC
; Spill t4 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T4, SB, SC
; Spill const_f4_op17_10 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T2, SB, SC
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T2, R0
; Call function putchar
    CALL putchar
; Scalar return value for t15
; Jump to epilogue
    BEQ R0, R0, L_print_chars_99999
L_print_chars_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
main:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 19 slots for locals
    ADDI SP, SP, 19
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_main_12:
    ADD S3, FP, R0
    ADD S2, FP, R0
    ADDI S2, S2, 10
    LI S1, 3
    STORE S1, SB, S2
    ADD S0, S3, R0
    LI T7, 65
    STORE T7, SB, S0
; Recompute alloca t0 at FP+0
    ADD T6, FP, R0
    ADDI T5, T6, 1
    LI T4, 66
    STORE T4, SB, T5
; Recompute alloca t0 at FP+0
    ADD T3, FP, R0
    ADDI T2, T3, 2
    LI T1, 67
    STORE T1, SB, T2
    LOAD T0, SB, S2
; Recompute alloca t0 at FP+0
    ADD S1, FP, R0
; Spill live registers before call
; Spill t2 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE S0, SB, SC
; Spill t3 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE T5, SB, SC
; Spill t4 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T2, SB, SC
; Spill t1 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE S2, SB, SC
; Spill t0 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S1, SB, SC
; Spill t5 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE T0, SB, SC
; Setting up 2 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, S1, R0
    ADD A1, SB, R0
; Arg 1 (scalar) to A2
    ADD A2, T0, R0
; Call function print_chars
    CALL print_chars
; Scalar return value for t6
; Recompute alloca t0 at FP+0
    ADD S3, FP, R0
; Recompute alloca t1 at FP+10
    ADD T7, FP, R0
    ADDI T7, T7, 10
    LI T6, 1
    LI T4, 88
; Spill live registers before call
; Spill t6 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE RV0, SB, SC
; Spill t0 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S3, SB, SC
; Spill t1 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T7, SB, SC
; Spill const_f6_op5_1 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T6, SB, SC
; Spill const_f6_op6_88 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE T4, SB, SC
; Pushing 2 arguments to stack
; Push arg 3 (scalar) to stack
    STORE T4, SB, SP
    ADDI SP, SP, 1
; Push arg 2 (scalar) to stack
    STORE T6, SB, SP
    ADDI SP, SP, 1
; Setting up 2 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, S3, R0
    ADD A1, SB, R0
; Arg 1 (fat ptr) to A2,A3
    ADD A2, T7, R0
    ADD A3, SB, R0
; Pushed 2 words to stack
; Call function insert_char
    CALL insert_char
; Scalar return value for t7
; Clean up 2 words from stack
    ADDI SP, SP, -2
; Recompute alloca t1 at FP+10
    ADD T3, FP, R0
    ADDI T3, T3, 10
    LOAD T1, SB, T3
; Recompute alloca t0 at FP+0
    ADD S0, FP, R0
; Spill live registers before call
; Spill t7 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE RV0, SB, SC
; Spill t1 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T3, SB, SC
; Spill t0 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S0, SB, SC
; Spill t8 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE T1, SB, SC
; Setting up 2 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, S0, R0
    ADD A1, SB, R0
; Arg 1 (scalar) to A2
    ADD A2, T1, R0
; Call function print_chars
    CALL print_chars
; Scalar return value for t9
; Recompute alloca t0 at FP+0
    ADD T5, FP, R0
; Recompute alloca t1 at FP+10
    ADD T2, FP, R0
    ADDI T2, T2, 10
    LI S2, 1
; Spill live registers before call
; Spill t9 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE RV0, SB, SC
; Spill t0 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T5, SB, SC
; Spill t1 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T2, SB, SC
; Spill const_f6_op8_1 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 31
    STORE S2, SB, SC
; Pushing 1 arguments to stack
; Push arg 2 (scalar) to stack
    STORE S2, SB, SP
    ADDI SP, SP, 1
; Setting up 2 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, T5, R0
    ADD A1, SB, R0
; Arg 1 (fat ptr) to A2,A3
    ADD A2, T2, R0
    ADD A3, SB, R0
; Pushed 1 words to stack
; Call function delete_char
    CALL delete_char
; Scalar return value for t10
; Clean up 1 words from stack
    ADDI SP, SP, -1
; Recompute alloca t1 at FP+10
    ADD S1, FP, R0
    ADDI S1, S1, 10
    LOAD T0, SB, S1
; Recompute alloca t0 at FP+0
    ADD S3, FP, R0
; Spill live registers before call
; Spill t10 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 32
    STORE RV0, SB, SC
; Spill t1 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE S1, SB, SC
; Spill t0 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE S3, SB, SC
; Spill t11 to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 33
    STORE T0, SB, SC
; Setting up 2 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, S3, R0
    ADD A1, SB, R0
; Arg 1 (scalar) to A2
    ADD A2, T0, R0
; Call function print_chars
    CALL print_chars
; Scalar return value for t12
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_main_99999
L_main_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
