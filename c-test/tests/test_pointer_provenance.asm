; Generated by Ripple C99 Compiler (rcc)

_init_globals:
; Global variable: global_var at address 100
    LI R3, 42
    LI R4, 100
    STORE R3, R0, R4
    RET
; Function: print_value
print_value:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 21
; === Processing instruction #0: Alloca { result: 1, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't1' ===
; get_reg for 't1'
;   Allocated free register for t1
; Alloca for t1 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #1: Load { result: 2, ptr: Temp(0), result_type: I16 } ===
; Load from [t0] to t2
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
; t0 found in R3
;   t0 is now in R3
; Pinning t0 in register to prevent spilling
; Getting bank tag for t0
; Looking for t100000 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
; t100000 found in R4
; === ModuleLowerer::get_reg for 'bank_select_0' ===
; get_reg for 'bank_select_0'
;   Allocated free register for bank_select_0
; Select bank register based on tag
    LI R6, 1
    BEQ R4, R6, print_value_bank_stack_1
    ADD R6, R0, R0
    BEQ R0, R0, print_value_bank_done_2
print_value_bank_stack_1:
    LI R6, 1
print_value_bank_done_2:
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
    LOAD R7, R6, R3
; === Processing instruction #2: Store { value: Temp(2), ptr: Temp(1) } ===
; === ModuleLowerer::get_reg for 'addr_t1_3' ===
; get_reg for 'addr_t1_3'
;   Allocated free register for addr_t1_3
    ADDI R8, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_5' ===
; get_reg for 'stack_bank_5'
;   Allocated free register for stack_bank_5
    LI R9, 1
; Store t2 to [t1]
; Getting register for temp t2
; Looking for t2 in registers
;   R3 contains t0
;   R4 contains t100000
;   R5 contains t1
;   R6 contains bank_for_t0
;   R7 contains t2
;   R8 contains ptr_preserve2_6
;   R? contains bank_preserve_7
; t2 found in R7
;   t2 is now in R7
    STORE R7, R9, R8
; >>> Preserving registers: storing t2 from previous instruction
; === Processing instruction #3: Load { result: 3, ptr: Temp(1), result_type: I16 } ===
; Load from [t1] to t3
; === ModuleLowerer::get_reg for 'addr_t1_8' ===
; get_reg for 'addr_t1_8'
;   Allocated free register for addr_t1_8
    ADDI R10, R15, 1
; Pinning addr_t1_8 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_9' ===
; get_reg for 'stack_bank_9'
;   Allocated free register for stack_bank_9
    LI R11, 1
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   No free registers, need to spill for t3
;     R3 contains 't0'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 'bank_for_t0'
;     R7 contains 't2'
;     R8 contains 'ptr_preserve2_6'
;     R9 contains 'bank_preserve_7'
;     R10 contains 'addr_t1_8'
;     R11 contains 'stack_bank_9'
;   Chose to spill t0 from R3
; Spilling t0 to FP+2
    ADDI R12, R15, 2
    STORE R3, R13, R12
;   Now R3 will contain t3
    LOAD R3, R11, R10
; === Processing instruction #4: Binary { result: 4, op: Eq, lhs: Temp(3), rhs: Constant(42), result_type: I16 } ===
; === Processing Binary t4 ===
; Binary: need(lhs)=1, need(rhs)=1
; Getting register for temp t3
; Looking for t3 in registers
;   R3 contains t3
;   R4 contains t100000
;   R5 contains t1
;   R6 contains bank_for_t0
;   R7 contains t2
;   R8 contains ptr_preserve2_6
;   R? contains bank_preserve_7
;   R? contains addr_t1_8
;   R? contains stack_bank_9
; t3 found in R3
;   t3 is now in R3
; === ModuleLowerer::get_reg for 'const_42_10' ===
; get_reg for 'const_42_10'
;   No free registers, need to spill for const_42_10
;     R3 contains 't3'
;     R4 contains 't100000'
;     R5 contains 't1'
;     R6 contains 'bank_for_t0'
;     R7 contains 't2'
;     R8 contains 'ptr_preserve2_6'
;     R9 contains 'bank_preserve_7'
;     R10 contains 'addr_t1_8'
;     R11 contains 'stack_bank_9'
;   Chose to spill t3 from R3
; Spilling t3 to FP+3
    ADDI R12, R15, 3
    STORE R3, R13, R12
;   Now R3 will contain const_42_10
    LI R3, 42
; Reusing R3 for result t4
; Spilling t100000 to FP+4
    ADDI R12, R15, 4
    STORE R4, R13, R12
; Spilling t1 to FP+5
    ADDI R12, R15, 5
    STORE R5, R13, R12
    SLTU R4, R3, R3
    SLTU R5, R3, R3
    OR R3, R4, R5
; === ModuleLowerer::get_reg for 'eq_inv_13' ===
; get_reg for 'eq_inv_13'
;   Allocated free register for eq_inv_13
    LI R5, 1
    SUB R3, R5, R3
; Freeing right operand register R3
; === Processing instruction #5: BranchCond { condition: Temp(4), true_label: 1, false_label: 2 } ===
; Getting register for temp t4
; Looking for t4 in registers
;   R3 contains t4
;   R4 contains eq_temp1_11
;   R6 contains bank_for_t0
;   R7 contains t2
;   R8 contains ptr_preserve2_6
;   R? contains bank_preserve_7
;   R? contains addr_t1_8
;   R? contains stack_bank_9
; t4 found in R3
;   t4 is now in R3
    BNE R3, R0, print_value_L1
    BEQ R0, R0, print_value_L2
print_value_L1:
; === Processing instruction #0: Call { result: None, function: Global("putchar"), args: [Constant(71)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_71_14' ===
; get_reg for 'const_71_14'
;   Allocated free register for const_71_14
    LI R5, 71
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #1: Branch(3) ===
    BEQ R0, R0, print_value_L3
print_value_L2:
; === Processing instruction #0: Load { result: 5, ptr: Temp(1), result_type: I16 } ===
; Load from [t1] to t5
; === ModuleLowerer::get_reg for 'addr_t1_15' ===
; Clearing R5 which contained const_71_14
; get_reg for 'addr_t1_15'
;   Allocated free register for addr_t1_15
    ADDI R5, R15, 1
; Pinning addr_t1_15 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_16' ===
; get_reg for 'stack_bank_16'
;   Allocated free register for stack_bank_16
    LI R6, 1
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   Allocated free register for t5
    LOAD R7, R6, R5
; === Processing instruction #1: Binary { result: 6, op: Eq, lhs: Temp(5), rhs: Constant(99), result_type: I16 } ===
; === Processing Binary t6 ===
; Binary: need(lhs)=1, need(rhs)=1
; Getting register for temp t5
; Looking for t5 in registers
;   R3 contains t4
;   R4 contains eq_temp1_11
;   R5 contains addr_t1_15
;   R6 contains stack_bank_16
;   R7 contains t5
; t5 found in R7
;   t5 is now in R7
; === ModuleLowerer::get_reg for 'const_99_17' ===
; get_reg for 'const_99_17'
;   Allocated free register for const_99_17
    LI R8, 99
; Reusing R7 for result t6
    SLTU R10, R7, R8
    SLTU R9, R8, R7
    OR R7, R10, R9
; === ModuleLowerer::get_reg for 'eq_inv_20' ===
; get_reg for 'eq_inv_20'
;   Allocated free register for eq_inv_20
    LI R9, 1
    SUB R7, R9, R7
; Freeing right operand register R8
; === Processing instruction #2: BranchCond { condition: Temp(6), true_label: 4, false_label: 5 } ===
; Getting register for temp t6
; Looking for t6 in registers
;   R3 contains t4
;   R4 contains eq_temp1_11
;   R5 contains addr_t1_15
;   R6 contains stack_bank_16
;   R7 contains t6
; t6 found in R7
;   t6 is now in R7
    BNE R7, R0, print_value_L4
    BEQ R0, R0, print_value_L5
print_value_L4:
; === Processing instruction #0: Call { result: None, function: Global("putchar"), args: [Constant(83)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_83_21' ===
; get_reg for 'const_83_21'
;   Allocated free register for const_83_21
    LI R5, 83
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #1: Branch(6) ===
    BEQ R0, R0, print_value_L6
print_value_L5:
; === Processing instruction #0: Call { result: None, function: Global("putchar"), args: [Constant(63)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_63_22' ===
; Clearing R5 which contained const_83_21
; get_reg for 'const_63_22'
;   Allocated free register for const_63_22
    LI R5, 63
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #1: Branch(6) ===
    BEQ R0, R0, print_value_L6
print_value_L6:
; === Processing instruction #0: Branch(3) ===
    BEQ R0, R0, print_value_L3
print_value_L3:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
; Function: main
main:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 28
main_L7:
; === Processing instruction #0: Call { result: None, function: Global("print_value"), args: [Global("global_var")], result_type: Void } ===
; === ModuleLowerer::get_reg for 'global_global_var_23' ===
; get_reg for 'global_global_var_23'
;   Allocated free register for global_global_var_23
    LI R5, 100
    ADD R3, R5, R0
    ADD R4, R0, R0
    CALL print_value
; === Processing instruction #1: Alloca { result: 0, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't0' ===
; Clearing R5 which contained global_global_var_23
; get_reg for 't0'
;   Allocated free register for t0
; Alloca for t0 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #2: Store { value: Constant(99), ptr: Temp(0) } ===
; === ModuleLowerer::get_reg for 'addr_t0_24' ===
; get_reg for 'addr_t0_24'
;   Allocated free register for addr_t0_24
    ADDI R6, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_26' ===
; get_reg for 'stack_bank_26'
;   Allocated free register for stack_bank_26
    LI R7, 1
; Store 99 to [t0]
; === ModuleLowerer::get_reg for 'const_99_29' ===
; get_reg for 'const_99_29'
;   Allocated free register for const_99_29
    LI R8, 99
    STORE R8, R7, R6
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #3: Call { result: None, function: Global("print_value"), args: [Temp(0)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t0_30' ===
; get_reg for 'addr_t0_30'
;   Allocated free register for addr_t0_30
    ADDI R5, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_31' ===
; get_reg for 'stack_bank_31'
;   Allocated free register for stack_bank_31
    LI R6, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    CALL print_value
; === Processing instruction #4: Alloca { result: 1, alloc_type: I16, count: Some(Constant(3)), result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't1' ===
; Clearing R5 which contained addr_t0_30
; Clearing R6 which contained stack_bank_31
; get_reg for 't1'
;   Allocated free register for t1
; Alloca for t1 at FP+2 (fat ptr: stack bank)
    ADDI R6, R15, 2
; === Processing instruction #5: GetElementPtr { result: 2, ptr: Temp(1), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t2 = t1 + offsets
; === ModuleLowerer::get_reg for 'addr_t1_32' ===
; get_reg for 'addr_t1_32'
;   Allocated free register for addr_t1_32
    ADDI R5, R15, 2
;   Base t1 in R5
; === ModuleLowerer::get_reg for 'const_0_33' ===
; get_reg for 'const_0_33'
;   Allocated free register for const_0_33
    LI R7, 0
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
    ADD R8, R5, R7
; === Processing instruction #6: Store { value: Constant(99), ptr: Temp(2) } ===
; Getting register for temp t2
; Looking for t2 in registers
;   R5 contains addr_t1_32
;   R6 contains t1
;   R7 contains const_0_33
;   R8 contains t2
; t2 found in R8
;   t2 is now in R8
; === ModuleLowerer::get_reg for 'stack_bank_35' ===
; get_reg for 'stack_bank_35'
;   Allocated free register for stack_bank_35
    LI R9, 1
; Store 99 to [t2]
; === ModuleLowerer::get_reg for 'const_99_38' ===
; get_reg for 'const_99_38'
;   Allocated free register for const_99_38
    LI R10, 99
    STORE R10, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #7: GetElementPtr { result: 3, ptr: Temp(1), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t3 = t1 + offsets
; === ModuleLowerer::get_reg for 'addr_t1_39' ===
; get_reg for 'addr_t1_39'
;   Allocated free register for addr_t1_39
    ADDI R5, R15, 2
;   Base t1 in R5
; === ModuleLowerer::get_reg for 'const_0_40' ===
; get_reg for 'const_0_40'
;   Allocated free register for const_0_40
    LI R6, 0
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   Allocated free register for t3
    ADD R7, R5, R6
; === Processing instruction #8: Call { result: None, function: Global("print_value"), args: [Temp(3)], result_type: Void } ===
; Getting register for temp t3
; Looking for t3 in registers
;   R5 contains addr_t1_39
;   R6 contains const_0_40
;   R7 contains t3
; t3 found in R7
;   t3 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_41' ===
; get_reg for 'stack_bank_41'
;   Allocated free register for stack_bank_41
    LI R8, 1
    ADD R3, R7, R0
    ADD R4, R8, R0
    CALL print_value
; === Processing instruction #9: Alloca { result: 4, alloc_type: Ptr(I16), count: None, result_type: Ptr(Ptr(I16)) } ===
; === ModuleLowerer::get_reg for 't4' ===
; Clearing R5 which contained addr_t1_39
; Clearing R6 which contained const_0_40
; Clearing R7 which contained t3
; Clearing R8 which contained stack_bank_41
; get_reg for 't4'
;   Allocated free register for t4
; Alloca for t4 at FP+5 (fat ptr: stack bank)
    ADDI R8, R15, 5
; === Processing instruction #10: Store { value: Temp(0), ptr: Temp(4) } ===
; === ModuleLowerer::get_reg for 'addr_t4_42' ===
; get_reg for 'addr_t4_42'
;   Allocated free register for addr_t4_42
    ADDI R7, R15, 5
; === ModuleLowerer::get_reg for 'stack_bank_44' ===
; get_reg for 'stack_bank_44'
;   Allocated free register for stack_bank_44
    LI R6, 1
; Store fat pointer t0 to [t4]
; === ModuleLowerer::get_reg for 'addr_t0_46' ===
; get_reg for 'addr_t0_46'
;   Allocated free register for addr_t0_46
    ADDI R5, R15, 1
    STORE R5, R6, R7
; === ModuleLowerer::get_reg for 'stack_bank_47' ===
; get_reg for 'stack_bank_47'
;   Allocated free register for stack_bank_47
    LI R9, 1
; === ModuleLowerer::get_reg for 'store_bank_48' ===
; get_reg for 'store_bank_48'
;   Allocated free register for store_bank_48
    LI R10, 1
; === ModuleLowerer::get_reg for 'next_addr_48' ===
; get_reg for 'next_addr_48'
;   Allocated free register for next_addr_48
    ADDI R11, R7, 1
    STORE R10, R6, R11
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #11: Alloca { result: 5, alloc_type: Ptr(I16), count: None, result_type: Ptr(Ptr(I16)) } ===
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   Allocated free register for t5
; Alloca for t5 at FP+7 (fat ptr: stack bank)
    ADDI R5, R15, 7
; === Processing instruction #12: Load { result: 6, ptr: Temp(4), result_type: Ptr(I16) } ===
; Load from [t4] to t6
; === ModuleLowerer::get_reg for 'addr_t4_49' ===
; get_reg for 'addr_t4_49'
;   Allocated free register for addr_t4_49
    ADDI R6, R15, 5
; Pinning addr_t4_49 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_50' ===
; get_reg for 'stack_bank_50'
;   Allocated free register for stack_bank_50
    LI R7, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't6' ===
; get_reg for 't6'
;   Allocated free register for t6
    LOAD R8, R7, R6
; === ModuleLowerer::get_reg for 'next_addr_51' ===
; get_reg for 'next_addr_51'
;   Allocated free register for next_addr_51
    ADDI R9, R6, 1
; === ModuleLowerer::get_reg for 'load_bank_52' ===
; get_reg for 'load_bank_52'
;   Allocated free register for load_bank_52
    LOAD R10, R7, R9
; === Processing instruction #13: Store { value: Temp(6), ptr: Temp(5) } ===
; === ModuleLowerer::get_reg for 'addr_t5_53' ===
; get_reg for 'addr_t5_53'
;   Allocated free register for addr_t5_53
    ADDI R11, R15, 7
; === ModuleLowerer::get_reg for 'stack_bank_55' ===
; get_reg for 'stack_bank_55'
;   No free registers, need to spill for stack_bank_55
;     R5 contains 't5'
;     R6 contains 'addr_t4_49'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve_54'
;   Chose to spill t5 from R5
; Spilling t5 to FP+9
    ADDI R12, R15, 9
    STORE R5, R13, R12
;   Now R5 will contain stack_bank_55
    LI R5, 1
; Store t6 to [t5]
; Getting register for temp t6
; Looking for t6 in registers
;   R5 contains bank_preserve_57
;   R6 contains addr_t4_49
;   R7 contains stack_bank_50
;   R8 contains t6
;   R? contains next_addr_51
;   R? contains t100006
;   R? contains ptr_preserve2_56
; t6 found in R8
;   t6 is now in R8
    STORE R8, R5, R11
; >>> Preserving registers: storing t6 from previous instruction
; === Processing instruction #14: Load { result: 7, ptr: Temp(5), result_type: Ptr(I16) } ===
; Load from [t5] to t7
; === ModuleLowerer::get_reg for 'addr_t5_58' ===
; get_reg for 'addr_t5_58'
;   No free registers, need to spill for addr_t5_58
;     R5 contains 'bank_preserve_57'
;     R6 contains 'addr_t4_49'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill bank_preserve_57 from R5
; Spilling bank_preserve_57 to FP+10
    ADDI R12, R15, 10
    STORE R5, R13, R12
;   Now R5 will contain addr_t5_58
    ADDI R5, R15, 7
; Pinning addr_t5_58 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_59' ===
; get_reg for 'stack_bank_59'
;   No free registers, need to spill for stack_bank_59
;     R5 contains 'addr_t5_58'
;     R6 contains 'addr_t4_49'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill addr_t4_49 from R6
; Spilling addr_t4_49 to FP+11
    ADDI R12, R15, 11
    STORE R6, R13, R12
;   Now R6 will contain stack_bank_59
    LI R6, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't7' ===
; get_reg for 't7'
;   No free registers, need to spill for t7
;     R5 contains 'addr_t5_58'
;     R6 contains 'stack_bank_59'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill stack_bank_59 from R6
; Spilling stack_bank_59 to FP+12
    ADDI R12, R15, 12
    STORE R6, R13, R12
;   Now R6 will contain t7
    LOAD R6, R6, R5
; === ModuleLowerer::get_reg for 'next_addr_60' ===
; get_reg for 'next_addr_60'
;   No free registers, need to spill for next_addr_60
;     R5 contains 'addr_t5_58'
;     R6 contains 't7'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill t7 from R6
; Spilling t7 to FP+13
    ADDI R12, R15, 13
    STORE R6, R13, R12
;   Now R6 will contain next_addr_60
    ADDI R6, R5, 1
; === ModuleLowerer::get_reg for 'load_bank_61' ===
; get_reg for 'load_bank_61'
;   No free registers, need to spill for load_bank_61
;     R5 contains 'addr_t5_58'
;     R6 contains 'next_addr_60'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill next_addr_60 from R6
; Spilling next_addr_60 to FP+14
    ADDI R12, R15, 14
    STORE R6, R13, R12
;   Now R6 will contain load_bank_61
    LOAD R6, R6, R6
; === Processing instruction #15: Store { value: Constant(99), ptr: Temp(7) } ===
; Getting register for temp t7
; Looking for t7 in registers
;   R5 contains addr_t5_58
;   R6 contains t100007
;   R7 contains stack_bank_50
;   R8 contains t6
;   R? contains next_addr_51
;   R? contains t100006
;   R? contains ptr_preserve2_56
; get_reg for 't7'
;   No free registers, need to spill for t7
;     R5 contains 'addr_t5_58'
;     R6 contains 't100007'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill addr_t5_58 from R5
; Spilling addr_t5_58 to FP+15
    ADDI R12, R15, 15
    STORE R5, R13, R12
;   Now R5 will contain t7
; Reloading t7 from FP+13
    ADDI R12, R15, 13
    LOAD R5, R13, R12
;   t7 is now in R5
; Getting bank tag for t7
; Looking for t100007 in registers
;   R5 contains ptr_preserve_62
;   R6 contains t100007
;   R7 contains stack_bank_50
;   R8 contains t6
;   R? contains next_addr_51
;   R? contains t100006
;   R? contains ptr_preserve2_56
; t100007 found in R6
; === ModuleLowerer::get_reg for 'bank_select_63' ===
; get_reg for 'bank_select_63'
;   No free registers, need to spill for bank_select_63
;     R5 contains 'ptr_preserve_62'
;     R6 contains 't100007'
;     R7 contains 'stack_bank_50'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill stack_bank_50 from R7
; Spilling stack_bank_50 to FP+16
    ADDI R12, R15, 16
    STORE R7, R13, R12
;   Now R7 will contain bank_select_63
; Select bank register based on tag
    LI R7, 1
    BEQ R6, R7, main_bank_stack_64
    ADD R7, R0, R0
    BEQ R0, R0, main_bank_done_65
main_bank_stack_64:
    LI R7, 1
main_bank_done_65:
; Store 99 to [t7]
; === ModuleLowerer::get_reg for 'const_99_68' ===
; get_reg for 'const_99_68'
;   No free registers, need to spill for const_99_68
;     R5 contains 'ptr_preserve2_66'
;     R6 contains 't100007'
;     R7 contains 'bank_preserve_67'
;     R8 contains 't6'
;     R9 contains 'next_addr_51'
;     R10 contains 't100006'
;     R11 contains 'ptr_preserve2_56'
;   Chose to spill t100007 from R6
; Spilling t100007 to FP+17
    ADDI R12, R15, 17
    STORE R6, R13, R12
;   Now R6 will contain const_99_68
    LI R6, 99
    STORE R6, R7, R5
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #16: Load { result: 8, ptr: Temp(5), result_type: Ptr(I16) } ===
; Load from [t5] to t8
; === ModuleLowerer::get_reg for 'addr_t5_69' ===
; get_reg for 'addr_t5_69'
;   Allocated free register for addr_t5_69
    ADDI R5, R15, 7
; Pinning addr_t5_69 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_70' ===
; get_reg for 'stack_bank_70'
;   Allocated free register for stack_bank_70
    LI R6, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't8' ===
; get_reg for 't8'
;   Allocated free register for t8
    LOAD R7, R6, R5
; === ModuleLowerer::get_reg for 'next_addr_71' ===
; get_reg for 'next_addr_71'
;   Allocated free register for next_addr_71
    ADDI R8, R5, 1
; === ModuleLowerer::get_reg for 'load_bank_72' ===
; get_reg for 'load_bank_72'
;   Allocated free register for load_bank_72
    LOAD R9, R6, R8
; === Processing instruction #17: Call { result: None, function: Global("print_value"), args: [Temp(8)], result_type: Void } ===
; Getting register for temp t8
; Looking for t8 in registers
;   R5 contains addr_t5_69
;   R6 contains stack_bank_70
;   R7 contains t8
;   R8 contains next_addr_71
;   R? contains t100008
; t8 found in R7
;   t8 is now in R7
    ADD R3, R7, R0
    CALL print_value
; === Processing instruction #18: Call { result: None, function: Global("putchar"), args: [Constant(10)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_10_73' ===
; Clearing R5 which contained addr_t5_69
; Clearing R6 which contained stack_bank_70
; Clearing R7 which contained t8
; Clearing R8 which contained next_addr_71
; get_reg for 'const_10_73'
;   Allocated free register for const_10_73
    LI R8, 10
    ADD R3, R8, R0
    CALL putchar
; === Processing instruction #19: Return(Some(Constant(0))) ===
; === ModuleLowerer::get_reg for 'const_0_74' ===
; Clearing R8 which contained const_10_73
; get_reg for 'const_0_74'
;   Allocated free register for const_0_74
    LI R8, 0
    ADD R3, R8, R0
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
main_L8:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
