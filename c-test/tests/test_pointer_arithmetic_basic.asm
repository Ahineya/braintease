; Generated by Ripple C99 Compiler (rcc)

_init_globals:
    RET
main:
; === Function Prologue ===
; Initialize SB as stack bank (1)
    LI SB, 1
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 23 slots for locals
    ADDI SP, SP, 23
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
    ADD S3, FP, R0
    ADD S2, S3, R0
    LI S1, 10
    STORE S1, SB, S2
    ADDI T7, S0, 1
    LI T6, 20
    STORE T6, SB, T7
    ADDI T4, T5, 2
    LI T3, 30
    STORE T3, SB, T4
    ADDI T1, T2, 3
    LI T0, 40
    STORE T0, SB, T1
    ADDI S1, S3, 4
    LI S0, 50
    STORE S0, SB, S1
    ADDI T5, T6, 5
    LI T3, 60
    STORE T3, SB, T5
    ADDI T0, T2, 6
    LI S3, 70
    STORE S3, SB, T0
    ADDI T6, S0, 7
    LI T3, 80
    STORE T3, SB, T6
    ADDI S3, T2, 8
    LI S0, 90
    STORE S0, SB, S3
    ADDI T2, T3, 9
    LI S0, 100
    STORE S0, SB, T2
    ADD T3, FP, R0
    ADDI T3, T3, 10
; Initialize SB as stack bank (1)
    LI SB, 1
; Spill t1 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE S2, SB, SC
    LI S2, 1
    STORE S0, SB, T3
; Spill t2 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE T7, SB, SC
    ADDI T7, T3, 1
    STORE S2, SB, T7
    ADD T7, FP, R0
    ADDI T7, T7, 12
    ADDI S2, T3, 5
    LI S0, 1
    STORE S2, SB, T7
    ADDI T3, T7, 1
    STORE S0, SB, T3
    LOAD T3, SB, T7
    LI S0, 60
    XOR S2, T3, S0
; Spill t3 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE T4, SB, SC
    LI T4, 1
    SLTU T3, S2, T4
    BEQ T3, R0, L_main_2
; Branch to L_main_2 if condition is false
    BEQ R0, R0, L_main_1
; Unconditional branch to L_main_1 (condition was true)
L_main_1:
    LI S2, 49
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_3
; Unconditional branch to L_main_3
L_main_2:
    LI T4, 78
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T4, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_3
; Unconditional branch to L_main_3
L_main_3:
    LI T3, 1
; Spill t4 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 19
    STORE T1, SB, SC
    STORE S0, SB, T1
; Spill t5 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 20
    STORE S1, SB, SC
    ADDI S1, T1, 1
    STORE T3, SB, S1
    ADDI S1, T1, 3
    LI T3, 1
    STORE S1, SB, S0
    ADDI T1, S0, 1
    STORE T3, SB, T1
    LOAD T1, SB, S0
    LI T3, 40
    XOR S1, T1, T3
; Spill t6 to slot 5
    ADD SC, FP, R0
    ADDI SC, SC, 21
    STORE T5, SB, SC
    LI T5, 1
    SLTU T1, S1, T5
    BEQ T1, R0, L_main_5
; Branch to L_main_5 if condition is false
    BEQ R0, R0, L_main_4
; Unconditional branch to L_main_4 (condition was true)
L_main_4:
    LI S1, 50
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_6
; Unconditional branch to L_main_6
L_main_5:
    LI T5, 78
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T5, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_6
; Unconditional branch to L_main_6
L_main_6:
    ADDI T1, T3, 7
    LI T3, 1
    STORE T1, SB, S0
; Spill t7 to slot 6
    ADD SC, FP, R0
    ADDI SC, SC, 22
    STORE T0, SB, SC
    ADDI T0, S0, 1
    STORE T3, SB, T0
    LI T0, 0
    LI T3, 2
    SUB T0, T0, T3
    ADD T3, T0, R0
    ADD T1, S0, T3
; Runtime bank overflow calculation for dynamic GEP
; Spill t8 to slot 7
    ADD SC, FP, R0
    ADDI SC, SC, 23
    STORE T6, SB, SC
; Spill t9 to slot 8
    ADD SC, FP, R0
    ADDI SC, SC, 24
    STORE S3, SB, SC
    LI S3, 4096
    DIV T6, T1, S3
; Spill t10 to slot 9
    ADD SC, FP, R0
    ADDI SC, SC, 25
    STORE T2, SB, SC
    MOD T2, T1, S3
; Spill t12 to slot 10
    ADD SC, FP, R0
    ADDI SC, SC, 26
    STORE T7, SB, SC
    ADD T7, SB, T6
    ADD T1, T2, R0
    LI T3, 1
    STORE T1, SB, T6
    ADDI S3, T6, 1
    STORE T3, SB, S3
    LOAD T2, SB, T6
    LI S0, 60
    XOR S3, T2, S0
    LI T3, 1
    SLTU T2, S3, T3
    BEQ T2, R0, L_main_8
; Branch to L_main_8 if condition is false
    BEQ R0, R0, L_main_7
; Unconditional branch to L_main_7 (condition was true)
L_main_7:
    LI T1, 51
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_9
; Unconditional branch to L_main_9
L_main_8:
    LI S3, 78
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S3, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_9
; Unconditional branch to L_main_9
L_main_9:
    ADDI S0, T3, 9
    LOAD T2, SB, S0
    LI T3, 100
; Spill const_f0_op16_49 to slot 11
    ADD SC, FP, R0
    ADDI SC, SC, 27
    STORE S2, SB, SC
    XOR S2, T2, T3
; Spill const_f0_op17_78 to slot 12
    ADD SC, FP, R0
    ADDI SC, SC, 28
    STORE T4, SB, SC
    LI T4, 1
    SLTU T2, S2, T4
    BEQ T2, R0, L_main_11
; Branch to L_main_11 if condition is false
    BEQ R0, R0, L_main_10
; Unconditional branch to L_main_10 (condition was true)
L_main_10:
    LI S2, 52
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S2, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_12
; Unconditional branch to L_main_12
L_main_11:
    LI T4, 78
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T4, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_12
; Unconditional branch to L_main_12
L_main_12:
    ADD T3, FP, R0
    ADDI T3, T3, 14
    LI T2, 6
    STORE T2, SB, T3
    LOAD T2, SB, T3
; Spill const_f0_op24_50 to slot 13
    ADD SC, FP, R0
    ADDI SC, SC, 29
    STORE S1, SB, SC
; Spill const_f0_op25_78 to slot 14
    ADD SC, FP, R0
    ADDI SC, SC, 30
    STORE T5, SB, SC
; Spill t20 to slot 15
    ADD SC, FP, R0
    ADDI SC, SC, 31
    STORE T0, SB, SC
    ADD T0, T2, R0
    ADD T5, S1, T0
; Runtime bank overflow calculation for dynamic GEP
; Spill gep_new_bank_f0_op32_t21 to slot 16
    ADD SC, FP, R0
    ADDI SC, SC, 32
    STORE T7, SB, SC
; Spill t11 to slot 17
    ADD SC, FP, R0
    ADDI SC, SC, 33
    STORE T6, SB, SC
    LI T6, 4096
    DIV T7, T5, T6
; Spill const_f0_op37_51 to slot 18
    ADD SC, FP, R0
    ADDI SC, SC, 34
    STORE T1, SB, SC
    MOD T1, T5, T6
; Spill const_f0_op38_78 to slot 19
    ADD SC, FP, R0
    ADDI SC, SC, 35
    STORE S3, SB, SC
    ADD S3, SB, T7
    ADD T5, T1, R0
    LOAD T0, SB, T5
    LI T7, 70
    XOR T6, T0, T7
    LI T1, 1
    SLTU T0, T6, T1
    BEQ T0, R0, L_main_14
; Branch to L_main_14 if condition is false
    BEQ R0, R0, L_main_13
; Unconditional branch to L_main_13 (condition was true)
L_main_13:
    LI S1, 53
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, S1, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_15
; Unconditional branch to L_main_15
L_main_14:
    LI T6, 78
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T6, R0
; Call function putchar
    CALL putchar
    BEQ R0, R0, L_main_15
; Unconditional branch to L_main_15
L_main_15:
    LI T1, 10
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Call function putchar
    CALL putchar
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_main_99999
L_main_16:
; Jump to epilogue
    BEQ R0, R0, L_main_99999
L_main_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
