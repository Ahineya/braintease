; Generated by Ripple C99 Compiler (rcc)

_init_globals:
; String literal Test! at address 100
    LI R3, 84
    LI R4, 100
    STORE R3, R0, R4
    LI R3, 101
    LI R4, 101
    STORE R3, R0, R4
    LI R3, 115
    LI R4, 102
    STORE R3, R0, R4
    LI R3, 116
    LI R4, 103
    STORE R3, R0, R4
    LI R3, 33
    LI R4, 104
    STORE R3, R0, R4
    LI R3, 0
    LI R4, 105
    STORE R3, R0, R4
    RET
; Function: main
main:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 35
; === Processing instruction #0: Alloca { result: 0, alloc_type: I8, count: Some(Constant(6)), result_type: Ptr(I8) } ===
; === ModuleLowerer::get_reg for 't0' ===
; get_reg for 't0'
;   Allocated free register for t0
; Alloca for t0 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #1: GetElementPtr { result: 1, ptr: Temp(0), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t1 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_0' ===
; get_reg for 'addr_t0_0'
;   Allocated free register for addr_t0_0
    ADDI R6, R15, 1
;   Base t0 in R6
; === ModuleLowerer::get_reg for 'const_0_1' ===
; get_reg for 'const_0_1'
;   Allocated free register for const_0_1
    LI R7, 0
; === ModuleLowerer::get_reg for 't1' ===
; get_reg for 't1'
;   Allocated free register for t1
    ADD R8, R6, R7
; === Processing instruction #2: Store { value: Constant(72), ptr: Temp(1) } ===
; Getting register for temp t1
; Looking for t1 in registers
;   R5 contains t0
;   R6 contains gep_base_1
;   R7 contains gep_index_1
;   R8 contains t1
; t1 found in R8
;   t1 is now in R8
; === ModuleLowerer::get_reg for 'stack_bank_3' ===
; get_reg for 'stack_bank_3'
;   Allocated free register for stack_bank_3
    LI R9, 1
; Store 72 to [t1]
; === ModuleLowerer::get_reg for 'const_72_6' ===
; get_reg for 'const_72_6'
;   Allocated free register for const_72_6
    LI R10, 72
    STORE R10, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #3: GetElementPtr { result: 2, ptr: Temp(0), indices: [Constant(1)], result_type: Ptr(I8) } ===
; GetElementPtr t2 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_7' ===
; get_reg for 'addr_t0_7'
;   Allocated free register for addr_t0_7
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_1_8' ===
; get_reg for 'const_1_8'
;   Allocated free register for const_1_8
    LI R6, 1
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
    ADD R7, R5, R6
; === Processing instruction #4: Store { value: Constant(101), ptr: Temp(2) } ===
; Getting register for temp t2
; Looking for t2 in registers
;   R5 contains gep_base_2
;   R6 contains gep_index_2
;   R7 contains t2
; t2 found in R7
;   t2 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_10' ===
; get_reg for 'stack_bank_10'
;   Allocated free register for stack_bank_10
    LI R8, 1
; Store 101 to [t2]
; === ModuleLowerer::get_reg for 'const_101_13' ===
; get_reg for 'const_101_13'
;   Allocated free register for const_101_13
    LI R9, 101
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #5: GetElementPtr { result: 3, ptr: Temp(0), indices: [Constant(2)], result_type: Ptr(I8) } ===
; GetElementPtr t3 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_14' ===
; get_reg for 'addr_t0_14'
;   Allocated free register for addr_t0_14
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_2_15' ===
; get_reg for 'const_2_15'
;   Allocated free register for const_2_15
    LI R6, 2
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   Allocated free register for t3
    ADD R7, R5, R6
; === Processing instruction #6: Store { value: Constant(108), ptr: Temp(3) } ===
; Getting register for temp t3
; Looking for t3 in registers
;   R5 contains gep_base_3
;   R6 contains gep_index_3
;   R7 contains t3
; t3 found in R7
;   t3 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_17' ===
; get_reg for 'stack_bank_17'
;   Allocated free register for stack_bank_17
    LI R8, 1
; Store 108 to [t3]
; === ModuleLowerer::get_reg for 'const_108_20' ===
; get_reg for 'const_108_20'
;   Allocated free register for const_108_20
    LI R9, 108
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #7: GetElementPtr { result: 4, ptr: Temp(0), indices: [Constant(3)], result_type: Ptr(I8) } ===
; GetElementPtr t4 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_21' ===
; get_reg for 'addr_t0_21'
;   Allocated free register for addr_t0_21
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_3_22' ===
; get_reg for 'const_3_22'
;   Allocated free register for const_3_22
    LI R6, 3
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   Allocated free register for t4
    ADD R7, R5, R6
; === Processing instruction #8: Store { value: Constant(108), ptr: Temp(4) } ===
; Getting register for temp t4
; Looking for t4 in registers
;   R5 contains gep_base_4
;   R6 contains gep_index_4
;   R7 contains t4
; t4 found in R7
;   t4 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_24' ===
; get_reg for 'stack_bank_24'
;   Allocated free register for stack_bank_24
    LI R8, 1
; Store 108 to [t4]
; === ModuleLowerer::get_reg for 'const_108_27' ===
; get_reg for 'const_108_27'
;   Allocated free register for const_108_27
    LI R9, 108
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #9: GetElementPtr { result: 5, ptr: Temp(0), indices: [Constant(4)], result_type: Ptr(I8) } ===
; GetElementPtr t5 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_28' ===
; get_reg for 'addr_t0_28'
;   Allocated free register for addr_t0_28
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_4_29' ===
; get_reg for 'const_4_29'
;   Allocated free register for const_4_29
    LI R6, 4
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   Allocated free register for t5
    ADD R7, R5, R6
; === Processing instruction #10: Store { value: Constant(111), ptr: Temp(5) } ===
; Getting register for temp t5
; Looking for t5 in registers
;   R5 contains gep_base_5
;   R6 contains gep_index_5
;   R7 contains t5
; t5 found in R7
;   t5 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_31' ===
; get_reg for 'stack_bank_31'
;   Allocated free register for stack_bank_31
    LI R8, 1
; Store 111 to [t5]
; === ModuleLowerer::get_reg for 'const_111_34' ===
; get_reg for 'const_111_34'
;   Allocated free register for const_111_34
    LI R9, 111
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #11: GetElementPtr { result: 6, ptr: Temp(0), indices: [Constant(5)], result_type: Ptr(I8) } ===
; GetElementPtr t6 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_35' ===
; get_reg for 'addr_t0_35'
;   Allocated free register for addr_t0_35
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_5_36' ===
; get_reg for 'const_5_36'
;   Allocated free register for const_5_36
    LI R6, 5
; === ModuleLowerer::get_reg for 't6' ===
; get_reg for 't6'
;   Allocated free register for t6
    ADD R7, R5, R6
; === Processing instruction #12: Store { value: Constant(0), ptr: Temp(6) } ===
; Getting register for temp t6
; Looking for t6 in registers
;   R5 contains gep_base_6
;   R6 contains gep_index_6
;   R7 contains t6
; t6 found in R7
;   t6 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_38' ===
; get_reg for 'stack_bank_38'
;   Allocated free register for stack_bank_38
    LI R8, 1
; Store 0 to [t6]
; === ModuleLowerer::get_reg for 'const_0_41' ===
; get_reg for 'const_0_41'
;   Allocated free register for const_0_41
    LI R9, 0
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #13: Call { result: None, function: Global("puts"), args: [Temp(0)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t0_42' ===
; get_reg for 'addr_t0_42'
;   Allocated free register for addr_t0_42
    ADDI R5, R15, 1
; === ModuleLowerer::get_reg for 'stack_bank_43' ===
; get_reg for 'stack_bank_43'
;   Allocated free register for stack_bank_43
    LI R6, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    CALL puts
; === Processing instruction #14: Alloca { result: 7, alloc_type: I8, count: Some(Constant(6)), result_type: Ptr(I8) } ===
; === ModuleLowerer::get_reg for 't7' ===
; Clearing R5 which contained addr_t0_42
; Clearing R6 which contained stack_bank_43
; get_reg for 't7'
;   Allocated free register for t7
; Alloca for t7 at FP+7 (fat ptr: stack bank)
    ADDI R6, R15, 7
; === Processing instruction #15: GetElementPtr { result: 8, ptr: Temp(7), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t8 = t7 + offsets
; === ModuleLowerer::get_reg for 'addr_t7_44' ===
; get_reg for 'addr_t7_44'
;   Allocated free register for addr_t7_44
    ADDI R5, R15, 7
;   Base t7 in R5
; === ModuleLowerer::get_reg for 'const_0_45' ===
; get_reg for 'const_0_45'
;   Allocated free register for const_0_45
    LI R7, 0
; === ModuleLowerer::get_reg for 't8' ===
; get_reg for 't8'
;   Allocated free register for t8
    ADD R8, R5, R7
; === Processing instruction #16: Store { value: Constant(87), ptr: Temp(8) } ===
; Getting register for temp t8
; Looking for t8 in registers
;   R5 contains gep_base_8
;   R6 contains t7
;   R7 contains gep_index_8
;   R8 contains t8
; t8 found in R8
;   t8 is now in R8
; === ModuleLowerer::get_reg for 'stack_bank_47' ===
; get_reg for 'stack_bank_47'
;   Allocated free register for stack_bank_47
    LI R9, 1
; Store 87 to [t8]
; === ModuleLowerer::get_reg for 'const_87_50' ===
; get_reg for 'const_87_50'
;   Allocated free register for const_87_50
    LI R10, 87
    STORE R10, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #17: GetElementPtr { result: 9, ptr: Temp(7), indices: [Constant(1)], result_type: Ptr(I8) } ===
; GetElementPtr t9 = t7 + offsets
; === ModuleLowerer::get_reg for 'addr_t7_51' ===
; get_reg for 'addr_t7_51'
;   Allocated free register for addr_t7_51
    ADDI R5, R15, 7
;   Base t7 in R5
; === ModuleLowerer::get_reg for 'const_1_52' ===
; get_reg for 'const_1_52'
;   Allocated free register for const_1_52
    LI R6, 1
; === ModuleLowerer::get_reg for 't9' ===
; get_reg for 't9'
;   Allocated free register for t9
    ADD R7, R5, R6
; === Processing instruction #18: Store { value: Constant(111), ptr: Temp(9) } ===
; Getting register for temp t9
; Looking for t9 in registers
;   R5 contains gep_base_9
;   R6 contains gep_index_9
;   R7 contains t9
; t9 found in R7
;   t9 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_54' ===
; get_reg for 'stack_bank_54'
;   Allocated free register for stack_bank_54
    LI R8, 1
; Store 111 to [t9]
; === ModuleLowerer::get_reg for 'const_111_57' ===
; get_reg for 'const_111_57'
;   Allocated free register for const_111_57
    LI R9, 111
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #19: GetElementPtr { result: 10, ptr: Temp(7), indices: [Constant(2)], result_type: Ptr(I8) } ===
; GetElementPtr t10 = t7 + offsets
; === ModuleLowerer::get_reg for 'addr_t7_58' ===
; get_reg for 'addr_t7_58'
;   Allocated free register for addr_t7_58
    ADDI R5, R15, 7
;   Base t7 in R5
; === ModuleLowerer::get_reg for 'const_2_59' ===
; get_reg for 'const_2_59'
;   Allocated free register for const_2_59
    LI R6, 2
; === ModuleLowerer::get_reg for 't10' ===
; get_reg for 't10'
;   Allocated free register for t10
    ADD R7, R5, R6
; === Processing instruction #20: Store { value: Constant(114), ptr: Temp(10) } ===
; Getting register for temp t10
; Looking for t10 in registers
;   R5 contains gep_base_10
;   R6 contains gep_index_10
;   R7 contains t10
; t10 found in R7
;   t10 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_61' ===
; get_reg for 'stack_bank_61'
;   Allocated free register for stack_bank_61
    LI R8, 1
; Store 114 to [t10]
; === ModuleLowerer::get_reg for 'const_114_64' ===
; get_reg for 'const_114_64'
;   Allocated free register for const_114_64
    LI R9, 114
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #21: GetElementPtr { result: 11, ptr: Temp(7), indices: [Constant(3)], result_type: Ptr(I8) } ===
; GetElementPtr t11 = t7 + offsets
; === ModuleLowerer::get_reg for 'addr_t7_65' ===
; get_reg for 'addr_t7_65'
;   Allocated free register for addr_t7_65
    ADDI R5, R15, 7
;   Base t7 in R5
; === ModuleLowerer::get_reg for 'const_3_66' ===
; get_reg for 'const_3_66'
;   Allocated free register for const_3_66
    LI R6, 3
; === ModuleLowerer::get_reg for 't11' ===
; get_reg for 't11'
;   Allocated free register for t11
    ADD R7, R5, R6
; === Processing instruction #22: Store { value: Constant(108), ptr: Temp(11) } ===
; Getting register for temp t11
; Looking for t11 in registers
;   R5 contains gep_base_11
;   R6 contains gep_index_11
;   R7 contains t11
; t11 found in R7
;   t11 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_68' ===
; get_reg for 'stack_bank_68'
;   Allocated free register for stack_bank_68
    LI R8, 1
; Store 108 to [t11]
; === ModuleLowerer::get_reg for 'const_108_71' ===
; get_reg for 'const_108_71'
;   Allocated free register for const_108_71
    LI R9, 108
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #23: GetElementPtr { result: 12, ptr: Temp(7), indices: [Constant(4)], result_type: Ptr(I8) } ===
; GetElementPtr t12 = t7 + offsets
; === ModuleLowerer::get_reg for 'addr_t7_72' ===
; get_reg for 'addr_t7_72'
;   Allocated free register for addr_t7_72
    ADDI R5, R15, 7
;   Base t7 in R5
; === ModuleLowerer::get_reg for 'const_4_73' ===
; get_reg for 'const_4_73'
;   Allocated free register for const_4_73
    LI R6, 4
; === ModuleLowerer::get_reg for 't12' ===
; get_reg for 't12'
;   Allocated free register for t12
    ADD R7, R5, R6
; === Processing instruction #24: Store { value: Constant(100), ptr: Temp(12) } ===
; Getting register for temp t12
; Looking for t12 in registers
;   R5 contains gep_base_12
;   R6 contains gep_index_12
;   R7 contains t12
; t12 found in R7
;   t12 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_75' ===
; get_reg for 'stack_bank_75'
;   Allocated free register for stack_bank_75
    LI R8, 1
; Store 100 to [t12]
; === ModuleLowerer::get_reg for 'const_100_78' ===
; get_reg for 'const_100_78'
;   Allocated free register for const_100_78
    LI R9, 100
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #25: GetElementPtr { result: 13, ptr: Temp(7), indices: [Constant(5)], result_type: Ptr(I8) } ===
; GetElementPtr t13 = t7 + offsets
; === ModuleLowerer::get_reg for 'addr_t7_79' ===
; get_reg for 'addr_t7_79'
;   Allocated free register for addr_t7_79
    ADDI R5, R15, 7
;   Base t7 in R5
; === ModuleLowerer::get_reg for 'const_5_80' ===
; get_reg for 'const_5_80'
;   Allocated free register for const_5_80
    LI R6, 5
; === ModuleLowerer::get_reg for 't13' ===
; get_reg for 't13'
;   Allocated free register for t13
    ADD R7, R5, R6
; === Processing instruction #26: Store { value: Constant(0), ptr: Temp(13) } ===
; Getting register for temp t13
; Looking for t13 in registers
;   R5 contains gep_base_13
;   R6 contains gep_index_13
;   R7 contains t13
; t13 found in R7
;   t13 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_82' ===
; get_reg for 'stack_bank_82'
;   Allocated free register for stack_bank_82
    LI R8, 1
; Store 0 to [t13]
; === ModuleLowerer::get_reg for 'const_0_85' ===
; get_reg for 'const_0_85'
;   Allocated free register for const_0_85
    LI R9, 0
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #27: Call { result: None, function: Global("puts"), args: [Temp(7)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t7_86' ===
; get_reg for 'addr_t7_86'
;   Allocated free register for addr_t7_86
    ADDI R5, R15, 7
; === ModuleLowerer::get_reg for 'stack_bank_87' ===
; get_reg for 'stack_bank_87'
;   Allocated free register for stack_bank_87
    LI R6, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    CALL puts
; === Processing instruction #28: Call { result: None, function: Global("puts"), args: [Global("__str_0_5465737421")], result_type: Void } ===
; === ModuleLowerer::get_reg for 'global_addr_88_88' ===
; Clearing R5 which contained addr_t7_86
; Clearing R6 which contained stack_bank_87
; get_reg for 'global_addr_88_88'
;   Allocated free register for global_addr_88_88
    LI R6, 100
    ADD R3, R6, R0
    ADD R4, R0, R0
    CALL puts
; === Processing instruction #29: Alloca { result: 14, alloc_type: I8, count: Some(Constant(1)), result_type: Ptr(I8) } ===
; === ModuleLowerer::get_reg for 't14' ===
; Clearing R6 which contained global_addr_88_88
; get_reg for 't14'
;   Allocated free register for t14
; Alloca for t14 at FP+13 (fat ptr: stack bank)
    ADDI R6, R15, 13
; === Processing instruction #30: GetElementPtr { result: 15, ptr: Temp(14), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t15 = t14 + offsets
; === ModuleLowerer::get_reg for 'addr_t14_89' ===
; get_reg for 'addr_t14_89'
;   Allocated free register for addr_t14_89
    ADDI R5, R15, 13
;   Base t14 in R5
; === ModuleLowerer::get_reg for 'const_0_90' ===
; get_reg for 'const_0_90'
;   Allocated free register for const_0_90
    LI R7, 0
; === ModuleLowerer::get_reg for 't15' ===
; get_reg for 't15'
;   Allocated free register for t15
    ADD R8, R5, R7
; === Processing instruction #31: Store { value: Constant(0), ptr: Temp(15) } ===
; Getting register for temp t15
; Looking for t15 in registers
;   R5 contains gep_base_15
;   R6 contains t14
;   R7 contains gep_index_15
;   R8 contains t15
; t15 found in R8
;   t15 is now in R8
; === ModuleLowerer::get_reg for 'stack_bank_92' ===
; get_reg for 'stack_bank_92'
;   Allocated free register for stack_bank_92
    LI R9, 1
; Store 0 to [t15]
; === ModuleLowerer::get_reg for 'const_0_95' ===
; get_reg for 'const_0_95'
;   Allocated free register for const_0_95
    LI R10, 0
    STORE R10, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #32: Call { result: None, function: Global("puts"), args: [Temp(14)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t14_96' ===
; get_reg for 'addr_t14_96'
;   Allocated free register for addr_t14_96
    ADDI R5, R15, 13
; === ModuleLowerer::get_reg for 'stack_bank_97' ===
; get_reg for 'stack_bank_97'
;   Allocated free register for stack_bank_97
    LI R6, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    CALL puts
; === Processing instruction #33: Alloca { result: 16, alloc_type: I8, count: Some(Constant(2)), result_type: Ptr(I8) } ===
; === ModuleLowerer::get_reg for 't16' ===
; Clearing R5 which contained addr_t14_96
; Clearing R6 which contained stack_bank_97
; get_reg for 't16'
;   Allocated free register for t16
; Alloca for t16 at FP+14 (fat ptr: stack bank)
    ADDI R6, R15, 14
; === Processing instruction #34: GetElementPtr { result: 17, ptr: Temp(16), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t17 = t16 + offsets
; === ModuleLowerer::get_reg for 'addr_t16_98' ===
; get_reg for 'addr_t16_98'
;   Allocated free register for addr_t16_98
    ADDI R5, R15, 14
;   Base t16 in R5
; === ModuleLowerer::get_reg for 'const_0_99' ===
; get_reg for 'const_0_99'
;   Allocated free register for const_0_99
    LI R7, 0
; === ModuleLowerer::get_reg for 't17' ===
; get_reg for 't17'
;   Allocated free register for t17
    ADD R8, R5, R7
; === Processing instruction #35: Store { value: Constant(88), ptr: Temp(17) } ===
; Getting register for temp t17
; Looking for t17 in registers
;   R5 contains gep_base_17
;   R6 contains t16
;   R7 contains gep_index_17
;   R8 contains t17
; t17 found in R8
;   t17 is now in R8
; === ModuleLowerer::get_reg for 'stack_bank_101' ===
; get_reg for 'stack_bank_101'
;   Allocated free register for stack_bank_101
    LI R9, 1
; Store 88 to [t17]
; === ModuleLowerer::get_reg for 'const_88_104' ===
; get_reg for 'const_88_104'
;   Allocated free register for const_88_104
    LI R10, 88
    STORE R10, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #36: GetElementPtr { result: 18, ptr: Temp(16), indices: [Constant(1)], result_type: Ptr(I8) } ===
; GetElementPtr t18 = t16 + offsets
; === ModuleLowerer::get_reg for 'addr_t16_105' ===
; get_reg for 'addr_t16_105'
;   Allocated free register for addr_t16_105
    ADDI R5, R15, 14
;   Base t16 in R5
; === ModuleLowerer::get_reg for 'const_1_106' ===
; get_reg for 'const_1_106'
;   Allocated free register for const_1_106
    LI R6, 1
; === ModuleLowerer::get_reg for 't18' ===
; get_reg for 't18'
;   Allocated free register for t18
    ADD R7, R5, R6
; === Processing instruction #37: Store { value: Constant(0), ptr: Temp(18) } ===
; Getting register for temp t18
; Looking for t18 in registers
;   R5 contains gep_base_18
;   R6 contains gep_index_18
;   R7 contains t18
; t18 found in R7
;   t18 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_108' ===
; get_reg for 'stack_bank_108'
;   Allocated free register for stack_bank_108
    LI R8, 1
; Store 0 to [t18]
; === ModuleLowerer::get_reg for 'const_0_111' ===
; get_reg for 'const_0_111'
;   Allocated free register for const_0_111
    LI R9, 0
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #38: Call { result: None, function: Global("puts"), args: [Temp(16)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'addr_t16_112' ===
; get_reg for 'addr_t16_112'
;   Allocated free register for addr_t16_112
    ADDI R5, R15, 14
; === ModuleLowerer::get_reg for 'stack_bank_113' ===
; get_reg for 'stack_bank_113'
;   Allocated free register for stack_bank_113
    LI R6, 1
    ADD R3, R5, R0
    ADD R4, R6, R0
    CALL puts
; === Processing instruction #39: Return(Some(Constant(0))) ===
; === ModuleLowerer::get_reg for 'const_0_114' ===
; Clearing R5 which contained addr_t16_112
; Clearing R6 which contained stack_bank_113
; get_reg for 'const_0_114'
;   Allocated free register for const_0_114
    LI R6, 0
    ADD R3, R6, R0
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
main_L1:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
