; Generated by Ripple C99 Compiler (rcc)

_init_globals:
; Global variable: global_counter at address 100
    LI R3, 5
    LI R4, 100
    STORE R3, R0, R4
; String literal OK! at address 101
    LI R3, 79
    LI R4, 101
    STORE R3, R0, R4
    LI R3, 75
    LI R4, 102
    STORE R3, R0, R4
    LI R3, 33
    LI R4, 103
    STORE R3, R0, R4
    LI R3, 0
    LI R4, 104
    STORE R3, R0, R4
    RET
; Function: main
main:
    STORE RA, R13, R14
    ADDI R14, R14, 1
    STORE R15, R13, R14
    ADDI R14, R14, 1
    ADD R15, R14, R0
    ADDI R14, R14, 32
; === Processing instruction #0: Alloca { result: 0, alloc_type: I16, count: Some(Constant(3)), result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't0' ===
; get_reg for 't0'
;   Allocated free register for t0
; Alloca for t0 at FP+1 (fat ptr: stack bank)
    ADDI R5, R15, 1
; === Processing instruction #1: GetElementPtr { result: 1, ptr: Temp(0), indices: [Constant(0)], result_type: Ptr(I16) } ===
; GetElementPtr t1 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_0' ===
; get_reg for 'addr_t0_0'
;   Allocated free register for addr_t0_0
    ADDI R6, R15, 1
;   Base t0 in R6
; === ModuleLowerer::get_reg for 'const_0_1' ===
; get_reg for 'const_0_1'
;   Allocated free register for const_0_1
    LI R7, 0
; === ModuleLowerer::get_reg for 't1' ===
; get_reg for 't1'
;   Allocated free register for t1
    ADD R8, R6, R7
; === Processing instruction #2: Store { value: Constant(77), ptr: Temp(1) } ===
; Getting register for temp t1
; Looking for t1 in registers
;   R5 contains t0
;   R6 contains addr_t0_0
;   R7 contains const_0_1
;   R8 contains t1
; t1 found in R8
;   t1 is now in R8
; === ModuleLowerer::get_reg for 'stack_bank_3' ===
; get_reg for 'stack_bank_3'
;   Allocated free register for stack_bank_3
    LI R9, 1
; Store 77 to [t1]
; === ModuleLowerer::get_reg for 'const_77_6' ===
; get_reg for 'const_77_6'
;   Allocated free register for const_77_6
    LI R10, 77
    STORE R10, R9, R8
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #3: GetElementPtr { result: 2, ptr: Temp(0), indices: [Constant(1)], result_type: Ptr(I16) } ===
; GetElementPtr t2 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_7' ===
; get_reg for 'addr_t0_7'
;   Allocated free register for addr_t0_7
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_1_8' ===
; get_reg for 'const_1_8'
;   Allocated free register for const_1_8
    LI R6, 1
; === ModuleLowerer::get_reg for 't2' ===
; get_reg for 't2'
;   Allocated free register for t2
    ADD R7, R5, R6
; === Processing instruction #4: Store { value: Constant(51), ptr: Temp(2) } ===
; Getting register for temp t2
; Looking for t2 in registers
;   R5 contains addr_t0_7
;   R6 contains const_1_8
;   R7 contains t2
; t2 found in R7
;   t2 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_10' ===
; get_reg for 'stack_bank_10'
;   Allocated free register for stack_bank_10
    LI R8, 1
; Store 51 to [t2]
; === ModuleLowerer::get_reg for 'const_51_13' ===
; get_reg for 'const_51_13'
;   Allocated free register for const_51_13
    LI R9, 51
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #5: GetElementPtr { result: 3, ptr: Temp(0), indices: [Constant(2)], result_type: Ptr(I16) } ===
; GetElementPtr t3 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_14' ===
; get_reg for 'addr_t0_14'
;   Allocated free register for addr_t0_14
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_2_15' ===
; get_reg for 'const_2_15'
;   Allocated free register for const_2_15
    LI R6, 2
; === ModuleLowerer::get_reg for 't3' ===
; get_reg for 't3'
;   Allocated free register for t3
    ADD R7, R5, R6
; === Processing instruction #6: Store { value: Constant(58), ptr: Temp(3) } ===
; Getting register for temp t3
; Looking for t3 in registers
;   R5 contains addr_t0_14
;   R6 contains const_2_15
;   R7 contains t3
; t3 found in R7
;   t3 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_17' ===
; get_reg for 'stack_bank_17'
;   Allocated free register for stack_bank_17
    LI R8, 1
; Store 58 to [t3]
; === ModuleLowerer::get_reg for 'const_58_20' ===
; get_reg for 'const_58_20'
;   Allocated free register for const_58_20
    LI R9, 58
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #7: GetElementPtr { result: 4, ptr: Temp(0), indices: [Constant(0)], result_type: Ptr(I16) } ===
; GetElementPtr t4 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_21' ===
; get_reg for 'addr_t0_21'
;   Allocated free register for addr_t0_21
    ADDI R5, R15, 1
;   Base t0 in R5
; === ModuleLowerer::get_reg for 'const_0_22' ===
; get_reg for 'const_0_22'
;   Allocated free register for const_0_22
    LI R6, 0
; === ModuleLowerer::get_reg for 't4' ===
; get_reg for 't4'
;   Allocated free register for t4
    ADD R7, R5, R6
; === Processing instruction #8: Load { result: 5, ptr: Temp(4), result_type: I16 } ===
; Load from [t4] to t5
; Getting register for temp t4
; Looking for t4 in registers
;   R5 contains addr_t0_21
;   R6 contains const_0_22
;   R7 contains t4
; t4 found in R7
;   t4 is now in R7
; Pinning t4 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_23' ===
; get_reg for 'stack_bank_23'
;   Allocated free register for stack_bank_23
    LI R8, 1
; === ModuleLowerer::get_reg for 't5' ===
; get_reg for 't5'
;   Allocated free register for t5
    LOAD R9, R8, R7
; === Processing instruction #9: Call { result: None, function: Global("putchar"), args: [Temp(5)], result_type: Void } ===
; Getting register for temp t5
; Looking for t5 in registers
;   R5 contains addr_t0_21
;   R6 contains const_0_22
;   R7 contains t4
;   R8 contains stack_bank_23
;   R? contains t5
; t5 found in R?
;   t5 is now in R9
    ADD R3, R9, R0
    CALL putchar
; === Processing instruction #10: GetElementPtr { result: 6, ptr: Temp(0), indices: [Constant(1)], result_type: Ptr(I16) } ===
; GetElementPtr t6 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_24' ===
; Clearing R5 which contained addr_t0_21
; Clearing R6 which contained const_0_22
; Clearing R7 which contained t4
; Clearing R8 which contained stack_bank_23
; get_reg for 'addr_t0_24'
;   Allocated free register for addr_t0_24
    ADDI R8, R15, 1
;   Base t0 in R8
; === ModuleLowerer::get_reg for 'const_1_25' ===
; get_reg for 'const_1_25'
;   Allocated free register for const_1_25
    LI R7, 1
; === ModuleLowerer::get_reg for 't6' ===
; get_reg for 't6'
;   Allocated free register for t6
    ADD R6, R8, R7
; === Processing instruction #11: Load { result: 7, ptr: Temp(6), result_type: I16 } ===
; Load from [t6] to t7
; Getting register for temp t6
; Looking for t6 in registers
;   R6 contains t6
;   R7 contains const_1_25
;   R8 contains addr_t0_24
;   R? contains t5
; t6 found in R6
;   t6 is now in R6
; Pinning t6 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_26' ===
; get_reg for 'stack_bank_26'
;   Allocated free register for stack_bank_26
    LI R5, 1
; === ModuleLowerer::get_reg for 't7' ===
; get_reg for 't7'
;   Allocated free register for t7
    LOAD R10, R5, R6
; === Processing instruction #12: Call { result: None, function: Global("putchar"), args: [Temp(7)], result_type: Void } ===
; Getting register for temp t7
; Looking for t7 in registers
;   R5 contains stack_bank_26
;   R6 contains t6
;   R7 contains const_1_25
;   R8 contains addr_t0_24
;   R? contains t5
;   R? contains t7
; t7 found in R?
;   t7 is now in R10
    ADD R3, R10, R0
    CALL putchar
; === Processing instruction #13: GetElementPtr { result: 8, ptr: Temp(0), indices: [Constant(2)], result_type: Ptr(I16) } ===
; GetElementPtr t8 = t0 + offsets
; === ModuleLowerer::get_reg for 'addr_t0_27' ===
; Clearing R5 which contained stack_bank_26
; Clearing R6 which contained t6
; Clearing R7 which contained const_1_25
; Clearing R8 which contained addr_t0_24
; get_reg for 'addr_t0_27'
;   Allocated free register for addr_t0_27
    ADDI R8, R15, 1
;   Base t0 in R8
; === ModuleLowerer::get_reg for 'const_2_28' ===
; get_reg for 'const_2_28'
;   Allocated free register for const_2_28
    LI R7, 2
; === ModuleLowerer::get_reg for 't8' ===
; get_reg for 't8'
;   Allocated free register for t8
    ADD R6, R8, R7
; === Processing instruction #14: Load { result: 9, ptr: Temp(8), result_type: I16 } ===
; Load from [t8] to t9
; Getting register for temp t8
; Looking for t8 in registers
;   R6 contains t8
;   R7 contains const_2_28
;   R8 contains addr_t0_27
;   R? contains t5
;   R? contains t7
; t8 found in R6
;   t8 is now in R6
; Pinning t8 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_29' ===
; get_reg for 'stack_bank_29'
;   Allocated free register for stack_bank_29
    LI R5, 1
; === ModuleLowerer::get_reg for 't9' ===
; get_reg for 't9'
;   Allocated free register for t9
    LOAD R11, R5, R6
; === Processing instruction #15: Call { result: None, function: Global("putchar"), args: [Temp(9)], result_type: Void } ===
; Getting register for temp t9
; Looking for t9 in registers
;   R5 contains stack_bank_29
;   R6 contains t8
;   R7 contains const_2_28
;   R8 contains addr_t0_27
;   R? contains t5
;   R? contains t7
;   R? contains t9
; t9 found in R?
;   t9 is now in R11
    ADD R3, R11, R0
    CALL putchar
; === Processing instruction #16: Call { result: None, function: Global("putchar"), args: [Constant(32)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_32_30' ===
; Clearing R5 which contained stack_bank_29
; Clearing R6 which contained t8
; Clearing R7 which contained const_2_28
; Clearing R8 which contained addr_t0_27
; get_reg for 'const_32_30'
;   Allocated free register for const_32_30
    LI R8, 32
    ADD R3, R8, R0
    CALL putchar
; === Processing instruction #17: Alloca { result: 10, alloc_type: Ptr(I8), count: None, result_type: Ptr(Ptr(I8)) } ===
; === ModuleLowerer::get_reg for 't10' ===
; Clearing R8 which contained const_32_30
; get_reg for 't10'
;   Allocated free register for t10
; Alloca for t10 at FP+4 (fat ptr: stack bank)
    ADDI R8, R15, 4
; === Processing instruction #18: Store { value: Global("__str_0_4f4b21"), ptr: Temp(10) } ===
; === ModuleLowerer::get_reg for 'addr_t10_31' ===
; get_reg for 'addr_t10_31'
;   Allocated free register for addr_t10_31
    ADDI R7, R15, 4
; === ModuleLowerer::get_reg for 'stack_bank_33' ===
; get_reg for 'stack_bank_33'
;   Allocated free register for stack_bank_33
    LI R6, 1
; Store fat pointer @__str_0_4f4b21 to [t10]
; === ModuleLowerer::get_reg for 'global___str_0_4f4b21_35' ===
; get_reg for 'global___str_0_4f4b21_35'
;   Allocated free register for global___str_0_4f4b21_35
    LI R5, 101
    STORE R5, R6, R7
; === ModuleLowerer::get_reg for 'store_bank_36' ===
; get_reg for 'store_bank_36'
;   No free registers, need to spill for store_bank_36
;     R5 contains 'global___str_0_4f4b21_35'
;     R6 contains 'bank_preserve_34'
;     R7 contains 'ptr_preserve_32'
;     R8 contains 't10'
;     R9 contains 't5'
;     R10 contains 't7'
;     R11 contains 't9'
;   Chose to spill global___str_0_4f4b21_35 from R5
; Spilling global___str_0_4f4b21_35 to FP+13
    ADDI R12, R15, 13
    STORE R5, R13, R12
;   Now R5 will contain store_bank_36
    LI R5, 0
; === ModuleLowerer::get_reg for 'next_addr_36' ===
; get_reg for 'next_addr_36'
;   No free registers, need to spill for next_addr_36
;     R5 contains 'store_bank_36'
;     R6 contains 'bank_preserve_34'
;     R7 contains 'ptr_preserve_32'
;     R8 contains 't10'
;     R9 contains 't5'
;     R10 contains 't7'
;     R11 contains 't9'
;   Chose to spill store_bank_36 from R5
; Spilling store_bank_36 to FP+14
    ADDI R12, R15, 14
    STORE R5, R13, R12
;   Now R5 will contain next_addr_36
    ADDI R5, R7, 1
    STORE R5, R6, R5
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #19: Load { result: 11, ptr: Temp(10), result_type: Ptr(I8) } ===
; Load from [t10] to t11
; === ModuleLowerer::get_reg for 'addr_t10_37' ===
; get_reg for 'addr_t10_37'
;   Allocated free register for addr_t10_37
    ADDI R5, R15, 4
; Pinning addr_t10_37 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_38' ===
; get_reg for 'stack_bank_38'
;   Allocated free register for stack_bank_38
    LI R6, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't11' ===
; get_reg for 't11'
;   Allocated free register for t11
    LOAD R7, R6, R5
; === ModuleLowerer::get_reg for 'next_addr_39' ===
; get_reg for 'next_addr_39'
;   Allocated free register for next_addr_39
    ADDI R8, R5, 1
; === ModuleLowerer::get_reg for 'load_bank_40' ===
; get_reg for 'load_bank_40'
;   Allocated free register for load_bank_40
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_38
; Bank register still valid in R6
    LOAD R9, R6, R8
; === Processing instruction #20: GetElementPtr { result: 12, ptr: Temp(11), indices: [Constant(0)], result_type: Ptr(I8) } ===
; GetElementPtr t12 = t11 + offsets
; Getting register for temp t11
; Looking for t11 in registers
;   R5 contains addr_t10_37
;   R6 contains stack_bank_38
;   R7 contains t11
;   R8 contains next_addr_39
;   R? contains t100011
; t11 found in R7
;   t11 is now in R7
;   Base t11 in R7
; === ModuleLowerer::get_reg for 'const_0_41' ===
; get_reg for 'const_0_41'
;   Allocated free register for const_0_41
    LI R10, 0
; === ModuleLowerer::get_reg for 't12' ===
; get_reg for 't12'
;   Allocated free register for t12
    ADD R11, R7, R10
;   Propagating bank tag from t100011 to t100012
; === Processing instruction #21: Load { result: 13, ptr: Temp(12), result_type: I8 } ===
; Load from [t12] to t13
; Getting register for temp t12
; Looking for t12 in registers
;   R5 contains addr_t10_37
;   R6 contains stack_bank_38
;   R7 contains t11
;   R8 contains next_addr_39
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t12 found in R?
;   t12 is now in R11
; Pinning t12 in register to prevent spilling
; Getting bank tag for t12
; Looking for t100012 in registers
;   R5 contains addr_t10_37
;   R6 contains stack_bank_38
;   R7 contains t11
;   R8 contains next_addr_39
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t100012 found in R?
; === ModuleLowerer::get_reg for 'bank_select_42' ===
; get_reg for 'bank_select_42'
;   No free registers, need to spill for bank_select_42
;     R5 contains 'addr_t10_37'
;     R6 contains 'stack_bank_38'
;     R7 contains 't11'
;     R8 contains 'next_addr_39'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill addr_t10_37 from R5
; Spilling addr_t10_37 to FP+15
    ADDI R12, R15, 15
    STORE R5, R13, R12
;   Now R5 will contain bank_select_42
; Select bank register based on tag
    LI R5, 1
    BEQ R9, R5, main_bank_stack_43
    ADD R5, R0, R0
    BEQ R0, R0, main_bank_done_44
main_bank_stack_43:
    LI R5, 1
main_bank_done_44:
; === ModuleLowerer::get_reg for 't13' ===
; get_reg for 't13'
;   No free registers, need to spill for t13
;     R5 contains 'bank_for_t12'
;     R6 contains 'stack_bank_38'
;     R7 contains 't11'
;     R8 contains 'next_addr_39'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill stack_bank_38 from R6
; Spilling stack_bank_38 to FP+16
    ADDI R12, R15, 16
    STORE R6, R13, R12
;   Now R6 will contain t13
    LOAD R6, R5, R11
; === Processing instruction #22: Call { result: None, function: Global("putchar"), args: [Temp(13)], result_type: Void } ===
; Getting register for temp t13
; Looking for t13 in registers
;   R5 contains bank_for_t12
;   R6 contains t13
;   R7 contains t11
;   R8 contains next_addr_39
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t13 found in R6
;   t13 is now in R6
    ADD R3, R6, R0
    CALL putchar
; === Processing instruction #23: Load { result: 14, ptr: Temp(10), result_type: Ptr(I8) } ===
; Load from [t10] to t14
; === ModuleLowerer::get_reg for 'addr_t10_45' ===
; Clearing R5 which contained bank_for_t12
; Clearing R6 which contained t13
; Clearing R7 which contained t11
; Clearing R8 which contained next_addr_39
; get_reg for 'addr_t10_45'
;   Allocated free register for addr_t10_45
    ADDI R8, R15, 4
; Pinning addr_t10_45 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_46' ===
; get_reg for 'stack_bank_46'
;   Allocated free register for stack_bank_46
    LI R7, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't14' ===
; get_reg for 't14'
;   Allocated free register for t14
    LOAD R6, R7, R8
; === ModuleLowerer::get_reg for 'next_addr_47' ===
; get_reg for 'next_addr_47'
;   Allocated free register for next_addr_47
    ADDI R5, R8, 1
; === ModuleLowerer::get_reg for 'load_bank_48' ===
; get_reg for 'load_bank_48'
;   No free registers, need to spill for load_bank_48
;     R5 contains 'next_addr_47'
;     R6 contains 't14'
;     R7 contains 'stack_bank_46'
;     R8 contains 'addr_t10_45'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill t14 from R6
; Spilling t14 to FP+17
    ADDI R12, R15, 17
    STORE R6, R13, R12
;   Now R6 will contain load_bank_48
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_46
; Bank register still valid in R7
    LOAD R6, R7, R5
; === Processing instruction #24: GetElementPtr { result: 15, ptr: Temp(14), indices: [Constant(1)], result_type: Ptr(I8) } ===
; GetElementPtr t15 = t14 + offsets
; Getting register for temp t14
; Looking for t14 in registers
;   R5 contains next_addr_47
;   R6 contains t100014
;   R7 contains stack_bank_46
;   R8 contains addr_t10_45
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; get_reg for 't14'
;   No free registers, need to spill for t14
;     R5 contains 'next_addr_47'
;     R6 contains 't100014'
;     R7 contains 'stack_bank_46'
;     R8 contains 'addr_t10_45'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill next_addr_47 from R5
; Spilling next_addr_47 to FP+18
    ADDI R12, R15, 18
    STORE R5, R13, R12
;   Now R5 will contain t14
; Reloading t14 from FP+17
    ADDI R12, R15, 17
    LOAD R5, R13, R12
;   t14 is now in R5
;   Base t14 in R5
; === ModuleLowerer::get_reg for 'const_1_49' ===
; get_reg for 'const_1_49'
;   No free registers, need to spill for const_1_49
;     R5 contains 't14'
;     R6 contains 't100014'
;     R7 contains 'stack_bank_46'
;     R8 contains 'addr_t10_45'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill t14 from R5
; Spilling t14 to FP+17
    ADDI R12, R15, 17
    STORE R5, R13, R12
;   Now R5 will contain const_1_49
    LI R5, 1
; === ModuleLowerer::get_reg for 't15' ===
; get_reg for 't15'
;   No free registers, need to spill for t15
;     R5 contains 'const_1_49'
;     R6 contains 't100014'
;     R7 contains 'stack_bank_46'
;     R8 contains 'addr_t10_45'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill const_1_49 from R5
; Spilling const_1_49 to FP+19
    ADDI R12, R15, 19
    STORE R5, R13, R12
;   Now R5 will contain t15
    ADD R5, R5, R5
;   Propagating bank tag from t100014 to t100015
; === Processing instruction #25: Load { result: 16, ptr: Temp(15), result_type: I8 } ===
; Load from [t15] to t16
; Getting register for temp t15
; Looking for t15 in registers
;   R5 contains t15
;   R6 contains t100015
;   R7 contains stack_bank_46
;   R8 contains addr_t10_45
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t15 found in R5
;   t15 is now in R5
; Pinning t15 in register to prevent spilling
; Getting bank tag for t15
; Looking for t100015 in registers
;   R5 contains t15
;   R6 contains t100015
;   R7 contains stack_bank_46
;   R8 contains addr_t10_45
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t100015 found in R6
; === ModuleLowerer::get_reg for 'bank_select_50' ===
; get_reg for 'bank_select_50'
;   No free registers, need to spill for bank_select_50
;     R5 contains 't15'
;     R6 contains 't100015'
;     R7 contains 'stack_bank_46'
;     R8 contains 'addr_t10_45'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill stack_bank_46 from R7
; Spilling stack_bank_46 to FP+20
    ADDI R12, R15, 20
    STORE R7, R13, R12
;   Now R7 will contain bank_select_50
; Select bank register based on tag
    LI R7, 1
    BEQ R6, R7, main_bank_stack_51
    ADD R7, R0, R0
    BEQ R0, R0, main_bank_done_52
main_bank_stack_51:
    LI R7, 1
main_bank_done_52:
; === ModuleLowerer::get_reg for 't16' ===
; get_reg for 't16'
;   No free registers, need to spill for t16
;     R5 contains 't15'
;     R6 contains 't100015'
;     R7 contains 'bank_for_t15'
;     R8 contains 'addr_t10_45'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill t100015 from R6
; Spilling t100015 to FP+21
    ADDI R12, R15, 21
    STORE R6, R13, R12
;   Now R6 will contain t16
    LOAD R6, R7, R5
; === Processing instruction #26: Call { result: None, function: Global("putchar"), args: [Temp(16)], result_type: Void } ===
; Getting register for temp t16
; Looking for t16 in registers
;   R5 contains t15
;   R6 contains t16
;   R7 contains bank_for_t15
;   R8 contains addr_t10_45
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t16 found in R6
;   t16 is now in R6
    ADD R3, R6, R0
    CALL putchar
; === Processing instruction #27: Load { result: 17, ptr: Temp(10), result_type: Ptr(I8) } ===
; Load from [t10] to t17
; === ModuleLowerer::get_reg for 'addr_t10_53' ===
; Clearing R5 which contained t15
; Clearing R6 which contained t16
; Clearing R7 which contained bank_for_t15
; Clearing R8 which contained addr_t10_45
; get_reg for 'addr_t10_53'
;   Allocated free register for addr_t10_53
    ADDI R8, R15, 4
; Pinning addr_t10_53 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_54' ===
; get_reg for 'stack_bank_54'
;   Allocated free register for stack_bank_54
    LI R7, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't17' ===
; get_reg for 't17'
;   Allocated free register for t17
    LOAD R6, R7, R8
; === ModuleLowerer::get_reg for 'next_addr_55' ===
; get_reg for 'next_addr_55'
;   Allocated free register for next_addr_55
    ADDI R5, R8, 1
; === ModuleLowerer::get_reg for 'load_bank_56' ===
; get_reg for 'load_bank_56'
;   No free registers, need to spill for load_bank_56
;     R5 contains 'next_addr_55'
;     R6 contains 't17'
;     R7 contains 'stack_bank_54'
;     R8 contains 'addr_t10_53'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill t17 from R6
; Spilling t17 to FP+22
    ADDI R12, R15, 22
    STORE R6, R13, R12
;   Now R6 will contain load_bank_56
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_54
; Bank register still valid in R7
    LOAD R6, R7, R5
; === Processing instruction #28: GetElementPtr { result: 18, ptr: Temp(17), indices: [Constant(2)], result_type: Ptr(I8) } ===
; GetElementPtr t18 = t17 + offsets
; Getting register for temp t17
; Looking for t17 in registers
;   R5 contains next_addr_55
;   R6 contains t100017
;   R7 contains stack_bank_54
;   R8 contains addr_t10_53
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; get_reg for 't17'
;   No free registers, need to spill for t17
;     R5 contains 'next_addr_55'
;     R6 contains 't100017'
;     R7 contains 'stack_bank_54'
;     R8 contains 'addr_t10_53'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill next_addr_55 from R5
; Spilling next_addr_55 to FP+23
    ADDI R12, R15, 23
    STORE R5, R13, R12
;   Now R5 will contain t17
; Reloading t17 from FP+22
    ADDI R12, R15, 22
    LOAD R5, R13, R12
;   t17 is now in R5
;   Base t17 in R5
; === ModuleLowerer::get_reg for 'const_2_57' ===
; get_reg for 'const_2_57'
;   No free registers, need to spill for const_2_57
;     R5 contains 't17'
;     R6 contains 't100017'
;     R7 contains 'stack_bank_54'
;     R8 contains 'addr_t10_53'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill t17 from R5
; Spilling t17 to FP+22
    ADDI R12, R15, 22
    STORE R5, R13, R12
;   Now R5 will contain const_2_57
    LI R5, 2
; === ModuleLowerer::get_reg for 't18' ===
; get_reg for 't18'
;   No free registers, need to spill for t18
;     R5 contains 'const_2_57'
;     R6 contains 't100017'
;     R7 contains 'stack_bank_54'
;     R8 contains 'addr_t10_53'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill const_2_57 from R5
; Spilling const_2_57 to FP+24
    ADDI R12, R15, 24
    STORE R5, R13, R12
;   Now R5 will contain t18
    ADD R5, R5, R5
;   Propagating bank tag from t100017 to t100018
; === Processing instruction #29: Load { result: 19, ptr: Temp(18), result_type: I8 } ===
; Load from [t18] to t19
; Getting register for temp t18
; Looking for t18 in registers
;   R5 contains t18
;   R6 contains t100018
;   R7 contains stack_bank_54
;   R8 contains addr_t10_53
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t18 found in R5
;   t18 is now in R5
; Pinning t18 in register to prevent spilling
; Getting bank tag for t18
; Looking for t100018 in registers
;   R5 contains t18
;   R6 contains t100018
;   R7 contains stack_bank_54
;   R8 contains addr_t10_53
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t100018 found in R6
; === ModuleLowerer::get_reg for 'bank_select_58' ===
; get_reg for 'bank_select_58'
;   No free registers, need to spill for bank_select_58
;     R5 contains 't18'
;     R6 contains 't100018'
;     R7 contains 'stack_bank_54'
;     R8 contains 'addr_t10_53'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill stack_bank_54 from R7
; Spilling stack_bank_54 to FP+25
    ADDI R12, R15, 25
    STORE R7, R13, R12
;   Now R7 will contain bank_select_58
; Select bank register based on tag
    LI R7, 1
    BEQ R6, R7, main_bank_stack_59
    ADD R7, R0, R0
    BEQ R0, R0, main_bank_done_60
main_bank_stack_59:
    LI R7, 1
main_bank_done_60:
; === ModuleLowerer::get_reg for 't19' ===
; get_reg for 't19'
;   No free registers, need to spill for t19
;     R5 contains 't18'
;     R6 contains 't100018'
;     R7 contains 'bank_for_t18'
;     R8 contains 'addr_t10_53'
;     R9 contains 't100012'
;     R10 contains 'const_0_41'
;     R11 contains 't12'
;   Chose to spill t100018 from R6
; Spilling t100018 to FP+26
    ADDI R12, R15, 26
    STORE R6, R13, R12
;   Now R6 will contain t19
    LOAD R6, R7, R5
; === Processing instruction #30: Call { result: None, function: Global("putchar"), args: [Temp(19)], result_type: Void } ===
; Getting register for temp t19
; Looking for t19 in registers
;   R5 contains t18
;   R6 contains t19
;   R7 contains bank_for_t18
;   R8 contains addr_t10_53
;   R? contains t100012
;   R? contains const_0_41
;   R? contains t12
; t19 found in R6
;   t19 is now in R6
    ADD R3, R6, R0
    CALL putchar
; === Processing instruction #31: Call { result: None, function: Global("putchar"), args: [Constant(10)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_10_61' ===
; Clearing R5 which contained t18
; Clearing R6 which contained t19
; Clearing R7 which contained bank_for_t18
; Clearing R8 which contained addr_t10_53
; get_reg for 'const_10_61'
;   Allocated free register for const_10_61
    LI R8, 10
    ADD R3, R8, R0
    CALL putchar
; === Processing instruction #32: Alloca { result: 20, alloc_type: I16, count: None, result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't20' ===
; Clearing R8 which contained const_10_61
; get_reg for 't20'
;   Allocated free register for t20
; Alloca for t20 at FP+6 (fat ptr: stack bank)
    ADDI R8, R15, 6
; === Processing instruction #33: Store { value: Constant(65), ptr: Temp(20) } ===
; === ModuleLowerer::get_reg for 'addr_t20_62' ===
; get_reg for 'addr_t20_62'
;   Allocated free register for addr_t20_62
    ADDI R7, R15, 6
; === ModuleLowerer::get_reg for 'stack_bank_64' ===
; get_reg for 'stack_bank_64'
;   Allocated free register for stack_bank_64
    LI R6, 1
; Store 65 to [t20]
; === ModuleLowerer::get_reg for 'const_65_67' ===
; get_reg for 'const_65_67'
;   Allocated free register for const_65_67
    LI R5, 65
    STORE R5, R6, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #34: Alloca { result: 21, alloc_type: Ptr(I16), count: None, result_type: Ptr(Ptr(I16)) } ===
; === ModuleLowerer::get_reg for 't21' ===
; get_reg for 't21'
;   Allocated free register for t21
; Alloca for t21 at FP+7 (fat ptr: stack bank)
    ADDI R5, R15, 7
; === Processing instruction #35: Store { value: Temp(20), ptr: Temp(21) } ===
; === ModuleLowerer::get_reg for 'addr_t21_68' ===
; get_reg for 'addr_t21_68'
;   Allocated free register for addr_t21_68
    ADDI R6, R15, 7
; === ModuleLowerer::get_reg for 'stack_bank_70' ===
; get_reg for 'stack_bank_70'
;   Allocated free register for stack_bank_70
    LI R7, 1
; Store fat pointer t20 to [t21]
; === ModuleLowerer::get_reg for 'addr_t20_72' ===
; get_reg for 'addr_t20_72'
;   Allocated free register for addr_t20_72
    ADDI R8, R15, 6
    STORE R8, R7, R6
; === ModuleLowerer::get_reg for 'stack_bank_73' ===
; get_reg for 'stack_bank_73'
;   Allocated free register for stack_bank_73
    LI R9, 1
; === ModuleLowerer::get_reg for 'store_bank_74' ===
; get_reg for 'store_bank_74'
;   Allocated free register for store_bank_74
    LI R10, 1
; === ModuleLowerer::get_reg for 'next_addr_74' ===
; get_reg for 'next_addr_74'
;   Allocated free register for next_addr_74
    ADDI R11, R6, 1
    STORE R10, R7, R11
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #36: Load { result: 22, ptr: Temp(21), result_type: Ptr(I16) } ===
; Load from [t21] to t22
; === ModuleLowerer::get_reg for 'addr_t21_75' ===
; get_reg for 'addr_t21_75'
;   Allocated free register for addr_t21_75
    ADDI R5, R15, 7
; Pinning addr_t21_75 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_76' ===
; get_reg for 'stack_bank_76'
;   Allocated free register for stack_bank_76
    LI R6, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't22' ===
; get_reg for 't22'
;   Allocated free register for t22
    LOAD R7, R6, R5
; === ModuleLowerer::get_reg for 'next_addr_77' ===
; get_reg for 'next_addr_77'
;   Allocated free register for next_addr_77
    ADDI R8, R5, 1
; === ModuleLowerer::get_reg for 'load_bank_78' ===
; get_reg for 'load_bank_78'
;   Allocated free register for load_bank_78
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_76
; Bank register still valid in R6
    LOAD R9, R6, R8
; === Processing instruction #37: Load { result: 23, ptr: Temp(22), result_type: I16 } ===
; Load from [t22] to t23
; Getting register for temp t22
; Looking for t22 in registers
;   R5 contains addr_t21_75
;   R6 contains stack_bank_76
;   R7 contains t22
;   R8 contains next_addr_77
;   R? contains t100022
; t22 found in R7
;   t22 is now in R7
; Pinning t22 in register to prevent spilling
; Getting bank tag for t22
; Looking for t100022 in registers
;   R5 contains addr_t21_75
;   R6 contains stack_bank_76
;   R7 contains t22
;   R8 contains next_addr_77
;   R? contains t100022
; t100022 found in R?
; === ModuleLowerer::get_reg for 'bank_select_79' ===
; get_reg for 'bank_select_79'
;   Allocated free register for bank_select_79
; Select bank register based on tag
    LI R10, 1
    BEQ R9, R10, main_bank_stack_80
    ADD R10, R0, R0
    BEQ R0, R0, main_bank_done_81
main_bank_stack_80:
    LI R10, 1
main_bank_done_81:
; === ModuleLowerer::get_reg for 't23' ===
; get_reg for 't23'
;   Allocated free register for t23
    LOAD R11, R10, R7
; === Processing instruction #38: Call { result: None, function: Global("putchar"), args: [Temp(23)], result_type: Void } ===
; Getting register for temp t23
; Looking for t23 in registers
;   R5 contains addr_t21_75
;   R6 contains stack_bank_76
;   R7 contains t22
;   R8 contains next_addr_77
;   R? contains t100022
;   R? contains bank_for_t22
;   R? contains t23
; t23 found in R?
;   t23 is now in R11
    ADD R3, R11, R0
    CALL putchar
; === Processing instruction #39: Alloca { result: 24, alloc_type: I16, count: Some(Constant(2)), result_type: Ptr(I16) } ===
; === ModuleLowerer::get_reg for 't24' ===
; Clearing R5 which contained addr_t21_75
; Clearing R6 which contained stack_bank_76
; Clearing R7 which contained t22
; Clearing R8 which contained next_addr_77
; get_reg for 't24'
;   Allocated free register for t24
; Alloca for t24 at FP+9 (fat ptr: stack bank)
    ADDI R8, R15, 9
; === Processing instruction #40: GetElementPtr { result: 25, ptr: Temp(24), indices: [Constant(0)], result_type: Ptr(I16) } ===
; GetElementPtr t25 = t24 + offsets
; === ModuleLowerer::get_reg for 'addr_t24_82' ===
; get_reg for 'addr_t24_82'
;   Allocated free register for addr_t24_82
    ADDI R7, R15, 9
;   Base t24 in R7
; === ModuleLowerer::get_reg for 'const_0_83' ===
; get_reg for 'const_0_83'
;   Allocated free register for const_0_83
    LI R6, 0
; === ModuleLowerer::get_reg for 't25' ===
; get_reg for 't25'
;   Allocated free register for t25
    ADD R5, R7, R6
; === Processing instruction #41: Store { value: Constant(66), ptr: Temp(25) } ===
; Getting register for temp t25
; Looking for t25 in registers
;   R5 contains t25
;   R6 contains const_0_83
;   R7 contains addr_t24_82
;   R8 contains t24
;   R? contains t100022
;   R? contains bank_for_t22
;   R? contains t23
; t25 found in R5
;   t25 is now in R5
; === ModuleLowerer::get_reg for 'stack_bank_85' ===
; get_reg for 'stack_bank_85'
;   No free registers, need to spill for stack_bank_85
;     R5 contains 'ptr_preserve_84'
;     R6 contains 'const_0_83'
;     R7 contains 'addr_t24_82'
;     R8 contains 't24'
;     R9 contains 't100022'
;     R10 contains 'bank_for_t22'
;     R11 contains 't23'
;   Chose to spill const_0_83 from R6
; Spilling const_0_83 to FP+27
    ADDI R12, R15, 27
    STORE R6, R13, R12
;   Now R6 will contain stack_bank_85
    LI R6, 1
; Store 66 to [t25]
; === ModuleLowerer::get_reg for 'const_66_88' ===
; get_reg for 'const_66_88'
;   No free registers, need to spill for const_66_88
;     R5 contains 'ptr_preserve2_86'
;     R6 contains 'bank_preserve_87'
;     R7 contains 'addr_t24_82'
;     R8 contains 't24'
;     R9 contains 't100022'
;     R10 contains 'bank_for_t22'
;     R11 contains 't23'
;   Chose to spill addr_t24_82 from R7
; Spilling addr_t24_82 to FP+28
    ADDI R12, R15, 28
    STORE R7, R13, R12
;   Now R7 will contain const_66_88
    LI R7, 66
    STORE R7, R6, R5
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #42: GetElementPtr { result: 26, ptr: Temp(24), indices: [Constant(1)], result_type: Ptr(I16) } ===
; GetElementPtr t26 = t24 + offsets
; === ModuleLowerer::get_reg for 'addr_t24_89' ===
; get_reg for 'addr_t24_89'
;   Allocated free register for addr_t24_89
    ADDI R5, R15, 9
;   Base t24 in R5
; === ModuleLowerer::get_reg for 'const_1_90' ===
; get_reg for 'const_1_90'
;   Allocated free register for const_1_90
    LI R6, 1
; === ModuleLowerer::get_reg for 't26' ===
; get_reg for 't26'
;   Allocated free register for t26
    ADD R7, R5, R6
; === Processing instruction #43: Store { value: Constant(67), ptr: Temp(26) } ===
; Getting register for temp t26
; Looking for t26 in registers
;   R5 contains addr_t24_89
;   R6 contains const_1_90
;   R7 contains t26
; t26 found in R7
;   t26 is now in R7
; === ModuleLowerer::get_reg for 'stack_bank_92' ===
; get_reg for 'stack_bank_92'
;   Allocated free register for stack_bank_92
    LI R8, 1
; Store 67 to [t26]
; === ModuleLowerer::get_reg for 'const_67_95' ===
; get_reg for 'const_67_95'
;   Allocated free register for const_67_95
    LI R9, 67
    STORE R9, R8, R7
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #44: Alloca { result: 27, alloc_type: Ptr(I16), count: None, result_type: Ptr(Ptr(I16)) } ===
; === ModuleLowerer::get_reg for 't27' ===
; get_reg for 't27'
;   Allocated free register for t27
; Alloca for t27 at FP+11 (fat ptr: stack bank)
    ADDI R5, R15, 11
; === Processing instruction #45: Store { value: Temp(24), ptr: Temp(27) } ===
; === ModuleLowerer::get_reg for 'addr_t27_96' ===
; get_reg for 'addr_t27_96'
;   Allocated free register for addr_t27_96
    ADDI R6, R15, 11
; === ModuleLowerer::get_reg for 'stack_bank_98' ===
; get_reg for 'stack_bank_98'
;   Allocated free register for stack_bank_98
    LI R7, 1
; Store fat pointer t24 to [t27]
; === ModuleLowerer::get_reg for 'addr_t24_100' ===
; get_reg for 'addr_t24_100'
;   Allocated free register for addr_t24_100
    ADDI R8, R15, 9
    STORE R8, R7, R6
; === ModuleLowerer::get_reg for 'stack_bank_101' ===
; get_reg for 'stack_bank_101'
;   Allocated free register for stack_bank_101
    LI R9, 1
; === ModuleLowerer::get_reg for 'store_bank_102' ===
; get_reg for 'store_bank_102'
;   Allocated free register for store_bank_102
    LI R10, 1
; === ModuleLowerer::get_reg for 'next_addr_102' ===
; get_reg for 'next_addr_102'
;   Allocated free register for next_addr_102
    ADDI R11, R6, 1
    STORE R10, R7, R11
; >>> Freeing all registers at Store statement boundary
; === Processing instruction #46: Load { result: 28, ptr: Temp(27), result_type: Ptr(I16) } ===
; Load from [t27] to t28
; === ModuleLowerer::get_reg for 'addr_t27_103' ===
; get_reg for 'addr_t27_103'
;   Allocated free register for addr_t27_103
    ADDI R5, R15, 11
; Pinning addr_t27_103 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_104' ===
; get_reg for 'stack_bank_104'
;   Allocated free register for stack_bank_104
    LI R6, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't28' ===
; get_reg for 't28'
;   Allocated free register for t28
    LOAD R7, R6, R5
; === ModuleLowerer::get_reg for 'next_addr_105' ===
; get_reg for 'next_addr_105'
;   Allocated free register for next_addr_105
    ADDI R8, R5, 1
; === ModuleLowerer::get_reg for 'load_bank_106' ===
; get_reg for 'load_bank_106'
;   Allocated free register for load_bank_106
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_104
; Bank register still valid in R6
    LOAD R9, R6, R8
; === Processing instruction #47: Load { result: 29, ptr: Temp(28), result_type: I16 } ===
; Load from [t28] to t29
; Getting register for temp t28
; Looking for t28 in registers
;   R5 contains addr_t27_103
;   R6 contains stack_bank_104
;   R7 contains t28
;   R8 contains next_addr_105
;   R? contains t100028
; t28 found in R7
;   t28 is now in R7
; Pinning t28 in register to prevent spilling
; Getting bank tag for t28
; Looking for t100028 in registers
;   R5 contains addr_t27_103
;   R6 contains stack_bank_104
;   R7 contains t28
;   R8 contains next_addr_105
;   R? contains t100028
; t100028 found in R?
; === ModuleLowerer::get_reg for 'bank_select_107' ===
; get_reg for 'bank_select_107'
;   Allocated free register for bank_select_107
; Select bank register based on tag
    LI R10, 1
    BEQ R9, R10, main_bank_stack_108
    ADD R10, R0, R0
    BEQ R0, R0, main_bank_done_109
main_bank_stack_108:
    LI R10, 1
main_bank_done_109:
; === ModuleLowerer::get_reg for 't29' ===
; get_reg for 't29'
;   Allocated free register for t29
    LOAD R11, R10, R7
; === Processing instruction #48: Call { result: None, function: Global("putchar"), args: [Temp(29)], result_type: Void } ===
; Getting register for temp t29
; Looking for t29 in registers
;   R5 contains addr_t27_103
;   R6 contains stack_bank_104
;   R7 contains t28
;   R8 contains next_addr_105
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; t29 found in R?
;   t29 is now in R11
    ADD R3, R11, R0
    CALL putchar
; === Processing instruction #49: Load { result: 30, ptr: Temp(27), result_type: Ptr(I16) } ===
; Load from [t27] to t30
; === ModuleLowerer::get_reg for 'addr_t27_110' ===
; Clearing R5 which contained addr_t27_103
; Clearing R6 which contained stack_bank_104
; Clearing R7 which contained t28
; Clearing R8 which contained next_addr_105
; get_reg for 'addr_t27_110'
;   Allocated free register for addr_t27_110
    ADDI R8, R15, 11
; Pinning addr_t27_110 in register to prevent spilling
; === ModuleLowerer::get_reg for 'stack_bank_111' ===
; get_reg for 'stack_bank_111'
;   Allocated free register for stack_bank_111
    LI R7, 1
; Loading fat pointer
; === ModuleLowerer::get_reg for 't30' ===
; get_reg for 't30'
;   Allocated free register for t30
    LOAD R6, R7, R8
; === ModuleLowerer::get_reg for 'next_addr_112' ===
; get_reg for 'next_addr_112'
;   Allocated free register for next_addr_112
    ADDI R5, R8, 1
; === ModuleLowerer::get_reg for 'load_bank_113' ===
; get_reg for 'load_bank_113'
;   No free registers, need to spill for load_bank_113
;     R5 contains 'next_addr_112'
;     R6 contains 't30'
;     R7 contains 'stack_bank_111'
;     R8 contains 'addr_t27_110'
;     R9 contains 't100028'
;     R10 contains 'bank_for_t28'
;     R11 contains 't29'
;   Chose to spill t30 from R6
; Spilling t30 to FP+29
    ADDI R12, R15, 29
    STORE R6, R13, R12
;   Now R6 will contain load_bank_113
; Checking bank register status for loading bank tag
; Bank value was: stack_bank_111
; Bank register still valid in R7
    LOAD R6, R7, R5
; === Processing instruction #50: GetElementPtr { result: 31, ptr: Temp(30), indices: [Constant(1)], result_type: Ptr(I16) } ===
; GetElementPtr t31 = t30 + offsets
; Getting register for temp t30
; Looking for t30 in registers
;   R5 contains next_addr_112
;   R6 contains t100030
;   R7 contains stack_bank_111
;   R8 contains addr_t27_110
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; get_reg for 't30'
;   No free registers, need to spill for t30
;     R5 contains 'next_addr_112'
;     R6 contains 't100030'
;     R7 contains 'stack_bank_111'
;     R8 contains 'addr_t27_110'
;     R9 contains 't100028'
;     R10 contains 'bank_for_t28'
;     R11 contains 't29'
;   Chose to spill next_addr_112 from R5
; Spilling next_addr_112 to FP+30
    ADDI R12, R15, 30
    STORE R5, R13, R12
;   Now R5 will contain t30
; Reloading t30 from FP+29
    ADDI R12, R15, 29
    LOAD R5, R13, R12
;   t30 is now in R5
;   Base t30 in R5
; === ModuleLowerer::get_reg for 'const_1_114' ===
; get_reg for 'const_1_114'
;   No free registers, need to spill for const_1_114
;     R5 contains 't30'
;     R6 contains 't100030'
;     R7 contains 'stack_bank_111'
;     R8 contains 'addr_t27_110'
;     R9 contains 't100028'
;     R10 contains 'bank_for_t28'
;     R11 contains 't29'
;   Chose to spill t30 from R5
; Spilling t30 to FP+29
    ADDI R12, R15, 29
    STORE R5, R13, R12
;   Now R5 will contain const_1_114
    LI R5, 1
; === ModuleLowerer::get_reg for 't31' ===
; get_reg for 't31'
;   No free registers, need to spill for t31
;     R5 contains 'const_1_114'
;     R6 contains 't100030'
;     R7 contains 'stack_bank_111'
;     R8 contains 'addr_t27_110'
;     R9 contains 't100028'
;     R10 contains 'bank_for_t28'
;     R11 contains 't29'
;   Chose to spill const_1_114 from R5
; Spilling const_1_114 to FP+31
    ADDI R12, R15, 31
    STORE R5, R13, R12
;   Now R5 will contain t31
    ADD R5, R5, R5
;   Propagating bank tag from t100030 to t100031
; === Processing instruction #51: Load { result: 32, ptr: Temp(31), result_type: I16 } ===
; Load from [t31] to t32
; Getting register for temp t31
; Looking for t31 in registers
;   R5 contains t31
;   R6 contains t100031
;   R7 contains stack_bank_111
;   R8 contains addr_t27_110
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; t31 found in R5
;   t31 is now in R5
; Pinning t31 in register to prevent spilling
; Getting bank tag for t31
; Looking for t100031 in registers
;   R5 contains t31
;   R6 contains t100031
;   R7 contains stack_bank_111
;   R8 contains addr_t27_110
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; t100031 found in R6
; === ModuleLowerer::get_reg for 'bank_select_115' ===
; get_reg for 'bank_select_115'
;   No free registers, need to spill for bank_select_115
;     R5 contains 't31'
;     R6 contains 't100031'
;     R7 contains 'stack_bank_111'
;     R8 contains 'addr_t27_110'
;     R9 contains 't100028'
;     R10 contains 'bank_for_t28'
;     R11 contains 't29'
;   Chose to spill stack_bank_111 from R7
; Spilling stack_bank_111 to FP+32
    ADDI R12, R15, 32
    STORE R7, R13, R12
;   Now R7 will contain bank_select_115
; Select bank register based on tag
    LI R7, 1
    BEQ R6, R7, main_bank_stack_116
    ADD R7, R0, R0
    BEQ R0, R0, main_bank_done_117
main_bank_stack_116:
    LI R7, 1
main_bank_done_117:
; === ModuleLowerer::get_reg for 't32' ===
; get_reg for 't32'
;   No free registers, need to spill for t32
;     R5 contains 't31'
;     R6 contains 't100031'
;     R7 contains 'bank_for_t31'
;     R8 contains 'addr_t27_110'
;     R9 contains 't100028'
;     R10 contains 'bank_for_t28'
;     R11 contains 't29'
;   Chose to spill t100031 from R6
; Spilling t100031 to FP+33
    ADDI R12, R15, 33
    STORE R6, R13, R12
;   Now R6 will contain t32
    LOAD R6, R7, R5
; === Processing instruction #52: Call { result: None, function: Global("putchar"), args: [Temp(32)], result_type: Void } ===
; Getting register for temp t32
; Looking for t32 in registers
;   R5 contains t31
;   R6 contains t32
;   R7 contains bank_for_t31
;   R8 contains addr_t27_110
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; t32 found in R6
;   t32 is now in R6
    ADD R3, R6, R0
    CALL putchar
; === Processing instruction #53: Call { result: None, function: Global("putchar"), args: [Constant(10)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_10_118' ===
; Clearing R5 which contained t31
; Clearing R6 which contained t32
; Clearing R7 which contained bank_for_t31
; Clearing R8 which contained addr_t27_110
; get_reg for 'const_10_118'
;   Allocated free register for const_10_118
    LI R8, 10
    ADD R3, R8, R0
    CALL putchar
; === Processing instruction #54: Load { result: 33, ptr: Global("global_counter"), result_type: I16 } ===
; Load from [@global_counter] to t33
; === ModuleLowerer::get_reg for 'load_addr_119' ===
; Clearing R8 which contained const_10_118
; get_reg for 'load_addr_119'
;   Allocated free register for load_addr_119
    LI R8, 100
; === ModuleLowerer::get_reg for 't33' ===
; get_reg for 't33'
;   Allocated free register for t33
    LOAD R7, R0, R8
; === Processing instruction #55: Binary { result: 34, op: Eq, lhs: Temp(33), rhs: Constant(5), result_type: I16 } ===
; === Processing Binary t34 ===
; Binary: need(lhs)=1, need(rhs)=1
; Getting register for temp t33
; Looking for t33 in registers
;   R7 contains t33
;   R8 contains load_addr_119
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; t33 found in R7
;   t33 is now in R7
; === ModuleLowerer::get_reg for 'const_5_120' ===
; get_reg for 'const_5_120'
;   Allocated free register for const_5_120
    LI R6, 5
; Reusing R7 for result t34
; Spilling load_addr_119 to FP+34
    ADDI R12, R15, 34
    STORE R8, R13, R12
    SLTU R5, R7, R6
    SLTU R8, R6, R7
    OR R7, R5, R8
; === ModuleLowerer::get_reg for 'eq_inv_123' ===
; get_reg for 'eq_inv_123'
;   Allocated free register for eq_inv_123
    LI R8, 1
    SUB R7, R8, R7
; Freeing right operand register R6
; === Processing instruction #56: BranchCond { condition: Temp(34), true_label: 1, false_label: 3 } ===
; Getting register for temp t34
; Looking for t34 in registers
;   R7 contains t34
;   R? contains t100028
;   R? contains bank_for_t28
;   R? contains t29
; t34 found in R7
;   t34 is now in R7
    BNE R7, R0, main_L1
    BEQ R0, R0, main_L3
main_L1:
; === Processing instruction #0: Call { result: None, function: Global("putchar"), args: [Constant(71)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_71_124' ===
; get_reg for 'const_71_124'
;   Allocated free register for const_71_124
    LI R5, 71
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #1: Call { result: None, function: Global("putchar"), args: [Constant(111)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_111_125' ===
; Clearing R5 which contained const_71_124
; get_reg for 'const_111_125'
;   Allocated free register for const_111_125
    LI R5, 111
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #2: Call { result: None, function: Global("putchar"), args: [Constant(111)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_111_126' ===
; Clearing R5 which contained const_111_125
; get_reg for 'const_111_126'
;   Allocated free register for const_111_126
    LI R5, 111
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #3: Call { result: None, function: Global("putchar"), args: [Constant(100)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_100_127' ===
; Clearing R5 which contained const_111_126
; get_reg for 'const_100_127'
;   Allocated free register for const_100_127
    LI R5, 100
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #4: Call { result: None, function: Global("putchar"), args: [Constant(33)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_33_128' ===
; Clearing R5 which contained const_100_127
; get_reg for 'const_33_128'
;   Allocated free register for const_33_128
    LI R5, 33
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #5: Call { result: None, function: Global("putchar"), args: [Constant(10)], result_type: Void } ===
; === ModuleLowerer::get_reg for 'const_10_129' ===
; Clearing R5 which contained const_33_128
; get_reg for 'const_10_129'
;   Allocated free register for const_10_129
    LI R5, 10
    ADD R3, R5, R0
    CALL putchar
; === Processing instruction #6: Branch(3) ===
    BEQ R0, R0, main_L3
main_L3:
; === Processing instruction #0: Return(Some(Constant(0))) ===
; === ModuleLowerer::get_reg for 'const_0_130' ===
; Clearing R5 which contained const_10_129
; get_reg for 'const_0_130'
;   Allocated free register for const_0_130
    LI R5, 0
    ADD R3, R5, R0
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
main_L4:
; === Processing instruction #0: Return(None) ===
    ADD R14, R15, R0
    ADDI R14, R14, -1
    LOAD R15, R13, R14
    ADDI R14, R14, -1
    LOAD RA, R13, R14
    RET
