; Generated by Ripple C99 Compiler (rcc)

; Function: test
test:
; === Processing instruction #0: Binary { result: 1, op: Eq, lhs: Temp(0), rhs: Constant(0), result_type: I16 } ===
; === Processing Binary t1 ===
; Binary: need(lhs)=1, need(rhs)=1
; Getting register for temp t0
; Looking for t0 in registers
;   R3 contains t0
;   R4 contains param_0_bank
; t0 found in R3
;   t0 is now in R3
; get_reg for 'const_0_0'
;   Allocated free register for const_0_0
    LI R5, 0
; Reusing R3 for result t1
    SLTU R7, R3, R5
    SLTU R6, R5, R3
    OR R3, R7, R6
; === ModuleLowerer::get_reg for 'eq_inv_2' ===
; get_reg for 'eq_inv_2'
;   Allocated free register for eq_inv_2
    LI R6, 1
    SUB R3, R6, R3
; Freeing right operand register R5
; === Processing instruction #1: BranchCond { condition: Temp(1), true_label: 1, false_label: 3 } ===
; Getting register for temp t1
; Looking for t1 in registers
;   R3 contains t1
;   R4 contains param_0_bank
; t1 found in R3
;   t1 is now in R3
    BNE R3, R0, test_L1
    BEQ R0, R0, test_L3
test_L1:
; === Processing instruction #0: Binary { result: 2, op: Sub, lhs: Constant(0), rhs: Constant(1), result_type: I16 } ===
; === Processing Binary t2 ===
; Binary: need(lhs)=1, need(rhs)=1
; get_reg for 'const_0_3'
;   Allocated free register for const_0_3
    LI R5, 0
; get_reg for 'const_1_4'
;   Allocated free register for const_1_4
    LI R6, 1
; Reusing R5 for result t2
    SUB R5, R5, R6
; Freeing right operand register R6
; === Processing instruction #1: Return(Some(Temp(2))) ===
; Getting register for temp t2
; Looking for t2 in registers
;   R5 contains t2
; t2 found in R5
;   t2 is now in R5
    ADD R3, R5, R0
    RET
test_L4:
; === Processing instruction #0: Branch(3) ===
    BEQ R0, R0, test_L3
test_L3:
; === Processing instruction #0: Return(Some(Constant(0))) ===
; get_reg for 'const_0_5'
;   Allocated free register for const_0_5
    LI R5, 0
    ADD R3, R5, R0
    RET
test_L5:
; === Processing instruction #0: Return(None) ===
    RET
