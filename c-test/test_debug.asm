; Generated by Ripple C99 Compiler (rcc)

_init_globals:
    RET
minimal_insert:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 14 slots for locals
    ADDI SP, SP, 14
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
; Load param 0 from A0
    ADD S3, A0, R0
; Load param 0 bank from A1
; Load param 1 from A2
    ADD S2, A2, R0
; Load param 1 bank from A3
; Load param 2 from FP-7
    ADDI SC, FP, -7
    LOAD S1, SB, SC
; Load param 3 from FP-8
    ADDI SC, FP, -8
    LOAD S0, SB, SC
    ADD T7, FP, R0
    STORE S3, SB, T7
    ADDI T6, T7, 1
    STORE A1, SB, T6
    ADD T5, FP, R0
    ADDI T5, T5, 2
    STORE S2, SB, T5
    ADDI T4, T5, 1
    STORE A3, SB, T4
    ADD T3, FP, R0
    ADDI T3, T3, 4
    STORE S1, SB, T3
    ADD T2, FP, R0
    ADDI T2, T2, 5
    STORE S0, SB, T2
    LOAD T1, SB, T7
    ADDI T0, T7, 1
    LOAD T6, SB, T0
    LOAD T4, SB, T3
; Spill t0 to slot 0
    ADD SC, FP, R0
    ADDI SC, SC, 14
    STORE S3, SB, SC
    ADD S3, T4, R0
    ADD T0, T1, S3
; Runtime bank overflow calculation for dynamic GEP
; Spill t1 to slot 1
    ADD SC, FP, R0
    ADDI SC, SC, 15
    STORE S2, SB, SC
; Spill t5 to slot 2
    ADD SC, FP, R0
    ADDI SC, SC, 16
    STORE T5, SB, SC
    LI T5, 4096
    DIV S2, T0, T5
; Spill t2 to slot 3
    ADD SC, FP, R0
    ADDI SC, SC, 17
    STORE S1, SB, SC
    MOD S1, T0, T5
; Spill t3 to slot 4
    ADD SC, FP, R0
    ADDI SC, SC, 18
    STORE S0, SB, SC
    ADD S0, T6, S2
    ADD T0, S1, R0
    LOAD S3, SB, T2
    STORE S3, S0, T0
; Jump to epilogue
    BEQ R0, R0, L_minimal_insert_99999
L_minimal_insert_99999:
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
main:
; === Function Prologue ===
; Save RA at SP
    STORE RA, SB, SP
    ADDI SP, SP, 1
; Save old FP
    STORE FP, SB, SP
    ADDI SP, SP, 1
; Save callee-saved registers S0-S3
    STORE S0, SB, SP
    ADDI SP, SP, 1
    STORE S1, SB, SP
    ADDI SP, SP, 1
    STORE S2, SB, SP
    ADDI SP, SP, 1
    STORE S3, SB, SP
    ADDI SP, SP, 1
; Set FP = SP
    ADD FP, SP, R0
; Allocate 13 slots for locals
    ADDI SP, SP, 13
; Reserve 20 spill slots above locals
    ADDI SP, SP, 20
L_main_1:
    ADD S3, FP, R0
    ADD S2, FP, R0
    ADDI S2, S2, 4
    LI S1, 0
    STORE S1, SB, S2
    ADD S0, S3, R0
    LI T7, 65
    STORE T7, SB, S0
; Recompute alloca t0 at FP+0
    ADD T6, FP, R0
    ADDI T5, T6, 1
    LI T4, 66
    STORE T4, SB, T5
; Recompute alloca t0 at FP+0
    ADD T3, FP, R0
    ADDI T2, T3, 2
    LI T1, 67
    STORE T1, SB, T2
; Recompute alloca t0 at FP+0
    ADD T0, FP, R0
    ADDI S1, T0, 3
    LI S3, 68
    STORE S3, SB, S1
; Recompute alloca t0 at FP+0
    ADD T7, FP, R0
    LI T6, 1
    LI T4, 88
; Pushing 2 arguments to stack
; Push arg 3 (scalar) to stack
    STORE T4, SB, SP
    ADDI SP, SP, 1
; Push arg 2 (scalar) to stack
    STORE T6, SB, SP
    ADDI SP, SP, 1
; Setting up 2 register arguments
; Arg 0 (fat ptr) to A0,A1
    ADD A0, T7, R0
    ADD A1, SB, R0
; Arg 1 (fat ptr) to A2,A3
    ADD A2, S2, R0
    ADD A3, SB, R0
; Pushed 2 words to stack
; Call function minimal_insert
    CALL minimal_insert
; Scalar return value for t6
; Clean up 2 words from stack
    ADDI SP, SP, -2
    ADD T3, T7, R0
    LOAD T1, SB, T3
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T1, R0
; Call function putchar
    CALL putchar
; Scalar return value for t9
; Recompute alloca t0 at FP+0
    ADD T0, FP, R0
    ADDI S3, T0, 1
    LOAD T7, SB, S3
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T7, R0
; Call function putchar
    CALL putchar
; Scalar return value for t12
    LI T0, 10
; Setting up 1 register arguments
; Arg 0 (scalar) to A0
    ADD A0, T0, R0
; Call function putchar
    CALL putchar
; Scalar return value for t13
    LI RV0, 0
; Jump to epilogue
    BEQ R0, R0, L_main_99999
L_main_99999:
; Return scalar value
; === Function Epilogue ===
; Restore SP = FP
    ADD SP, FP, R0
; Restore callee-saved registers S3-S0
    ADDI SC, FP, -1
    LOAD S3, SB, SC
    ADDI SC, FP, -2
    LOAD S2, SB, SC
    ADDI SC, FP, -3
    LOAD S1, SB, SC
    ADDI SC, FP, -4
    LOAD S0, SB, SC
; Restore old FP
    ADDI SP, SP, -5
    LOAD FP, SB, SP
; Restore RA
    ADDI SP, SP, -1
    LOAD RA, SB, SP
; Return to caller
    ADD PCB, RAB, R0
    JALR R0, R0, RA
