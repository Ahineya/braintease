Pavlo, the culprit is where you spill across the call: you write spills at FP+16.. above your current SP, then putchar’s prologue and local allocation grow SP up right through that region and trample your spills. After the call returns, you reload garbage → the second condition becomes false → 1N\n.

Evidence from your asm

Right before the first CALL putchar in the then arm:

; FP is fixed. Your current SP is lower than these addresses.
ADD SC, FP, R0
ADDI SC, SC, 16
STORE S1, SB, SC        ; spill #0 at FP+16

ADD SC, FP, R0
ADDI SC, SC, 17
STORE S3, SB, SC        ; spill #1 at FP+17

ADD SC, FP, R0
ADDI SC, SC, 18
STORE T3, SB, SC        ; spill #2 at FP+18

CALL putchar

But earlier you did:

; after prologue:
ADDI SP, SP, 10         ; allocate 10 locals

ADDI SP, SP, -1
MOVE S3, SP             ; a lives at (FP+9)

ADDI SP, SP, -1
MOVE S1, SP             ; b lives at (FP+8)

So at the moment of the call:
	•	FP = F
	•	SP = F + 8
	•	Your spills are at F+16..F+18 above SP.

Now look at your putchar prologue (L_0007):

STORE RA, SB, SP        ; uses caller’s SP (F+8)
ADDI SP, SP, 1
STORE FP, SB, SP
ADDI SP, SP, 1
STORE S0, SB, SP
ADDI SP, SP, 1
STORE S1, SB, SP
ADDI SP, SP, 1
STORE S2, SB, SP
ADDI SP, SP, 1
STORE S3, SB, SP
ADDI SP, SP, 1
ADD FP, SP, R0
ADDI SP, SP, 8          ; callee locals

Callee grows SP from F+8 up to F+22. That range overlaps your spills at F+16..F+18. Bye-bye &a, &b, and the '1' constant you spilled.

Later, you do:

; Reload t0 from slot 1
ADD SC, FP, R0
ADDI SC, SC, 17
LOAD T1, SB, SC         ; ← loads stomped value
LOAD T0, SB, T1
...
; Reload t1 from slot 0
ADD SC, FP, R0
ADDI SC, SC, 16
LOAD T4, SB, SC         ; ← loads stomped value
LOAD T6, SB, T4
...
AND T0, T0, T6
BEQ T0, R0, L_main_5    ; falls through to 'N'

That explains 1N\n exactly.

⸻

Fix it cleanly

You need a real frame for the caller that includes locals + spills you might need across calls, and you must ensure SP stays at or above the highest slot you’ll touch while the callee runs.

Pick one of these approaches:

Option A — Fixed-size frame (simple & robust)
	•	During lowering, compute a conservative max spill depth for the function (or just pick a safe upper bound for now).
	•	In the prologue, after FP ← SP, do:

SP += locals_size + max_spill_size


	•	Place locals and spills at FP + offset within that reserved frame.
	•	Never move SP down inside the body. With SP already above everything, callees can’t overwrite your frame.

Option B — On-demand grow before call
	•	Track the highest spill offset you’ve used so far (max_used_offset from FP).
	•	Right before a call, if SP < FP + max_used_offset + 1, do:

SP = FP + max_used_offset + 1

so your spills are inside the “active” stack when the callee pushes.

	•	After the call, you may keep SP there (simplest), or restore it if your ABI demands it. The key is: never leave spills above SP when calling.

Option C — True pushes for spills
	•	Instead of FP+k slots, push spill words on the stack:

STORE reg, SB, SP
SP += 1

and remember their SP-relative positions.

	•	After the call (or when done), pop them (or leave them if you treat them as part of the frame).
	•	This avoids FP math but needs a little book-keeping.

Bonus hygiene
	•	Make your register allocator/cg pass surface a frame_size and emit it once in the prologue.
	•	Add an assert in the emitter: if it ever tries to store to FP+K with SP <= FP+K, warn/fail in debug builds. That catches this class early.
	•	Unit test: tiny function that spills 3 temps, calls a function with a big frame, then reloads and uses them.

⸻

TL;DR

Your second if fails because callee’s frame overwrote caller’s spills: you stored spills at FP+16.. while SP was only FP+8, and the callee grew SP up to FP+22. Reserve/raise the caller’s SP to cover all FP+K spill slots before calling, or use a fixed-size frame that already includes them. After that, this test prints 12\n.